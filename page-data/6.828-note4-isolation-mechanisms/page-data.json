{"componentChunkName":"component---src-templates-blog-post-js","path":"/6.828-note4-isolation-mechanisms/","result":{"data":{"markdownRemark":{"html":"<p>这里会记录阅读6.828课程lecture note的我的个人笔记。可能会中英混杂，不是很适合外人阅读，也请见谅。</p>\n<h2>Lecture 5: Isolation mechanisms</h2>\n<p>多个进程同时运行导致了对操作系统的3项主要要求：</p>\n<ul>\n<li>multiplexing</li>\n<li>isolation</li>\n<li>interaction / sharing</li>\n</ul>\n<p>而这其中isolation是最不好完成的要求。</p>\n<p>那么isolation要完成什么呢？</p>\n<ul>\n<li>用隔离来包裹住错误</li>\n<li>进程是isolation的基本单元</li>\n<li>防止进程x监视进程y</li>\n<li>防止进程干预操作系统</li>\n</ul>\n<p>kernel用硬件机制来辅助得到process isolation</p>\n<ul>\n<li>processor有user / kernel mode flag</li>\n<li>每个进程有分配address spaces</li>\n<li>timeslicing</li>\n<li>system call interface</li>\n</ul>\n<p>先来说硬件上的user / kernel mode flag。</p>\n<ul>\n<li>控制instruction是否能有权限使用privileged h / w</li>\n<li>\n<p>在x86上叫CPL，是<code class=\"language-text\">%cs</code>的后两位</p>\n<p>CPL=0 -- kernel mode</p>\n<p>CPL=3 -- user mode</p>\n</li>\n<li>\n<p>x86 CPL保护了很多寄存器，包括：</p>\n<ul>\n<li>I / O port access</li>\n<li>control register access (eflag, <code class=\"language-text\">%cs4</code>)，包括<code class=\"language-text\">%cs</code>自己</li>\n<li><strong>间接</strong>影响内存访问</li>\n</ul>\n</li>\n<li>每个非娱乐性质的microprocessor都会有user / kernel mode flag</li>\n</ul>\n<p>如何用system call来切换CPL，考虑如下几个问题</p>\n<ul>\n<li>\n<p>可不可以设置一个system call直接</p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\">set CPL=0</code></pre></div>\n<p>这样肯定不行，因为用户可以直接设置CPL，就没有办法保护内核了。</p>\n</li>\n<li>那么如果要求这个system call必须要直接跳入kernel中的一个位置呢？</li>\n<li>这样也不好，因为可能会跳到一个很尴尬的位置，没法运行下去了</li>\n</ul>\n<p>所以x86给出的答案是：</p>\n<ul>\n<li>给出几个permissible kernel entry points</li>\n<li>INT 指令会设置CPL=0，然后跳到某一个entry point</li>\n<li>system call在返回的时候设置CPL=3，再运行user code</li>\n</ul>\n<p>这样就有well-defined notion of user vs kernel，不会出现再kernel mode运行user code，更不会有user mode里运行kernel code。</p>\n<p>之后来说如何隔离进程内存，也就是address space。</p>\n<ul>\n<li>address space的目的是让每个process可以有内存来访问自己的code, variables, heap, stack并不让其访问其他的内存。</li>\n</ul>\n<p>那么如何建立isolated address spaces呢？</p>\n<p>xv6用的是x86的memory management unit(MMU)里的 \"paging hardware\"，MMU会把所以地址进行翻译：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">CPU -> MMU -> RAM\n        |\n     pagetable\nVA -> PA</code></pre></div>\n<p>MMU会对所有memory reference进行翻译:user and kernel。</p>\n<p>instructions and data</p>\n<ul>\n<li>注意instruction用的永远都是virtual address(VA), 从来不用physical address (PA)</li>\n</ul>\n<p>最后来说xv6的system call是如何实现的</p>\n<p>xv6的process / stack diagram:</p>\n<ul>\n<li>user process ; kernel thread</li>\n<li>user stack ; kernel stack</li>\n<li>two mechanisms:\nswitch between user/kernel\nswitch between kernel threads</li>\n<li>trap frame</li>\n<li>kernel function calls...</li>\n<li>struct context</li>\n</ul>\n<p>简单的xv6的user/kernel virtual address-space设置：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  FFFFFFFF:\n            ...\n  80000000: kernel\n            user stack\n            user data\n  00000000: user instructions</code></pre></div>\n<p>kernel通过设置MMU来让user code只能访问到lower half。每个进程会有不同的address space，但是kernel的mapping都是一样的。</p>\n<h3>xv6 中system call的流程</h3>\n<p>下面来看看xv6的代码层面是如何完成的调用一个system call并返回的。</p>\n<p>我们选择的system call是<code class=\"language-text\">sh.asm</code>里的<code class=\"language-text\">write</code>，注意这里note有误，应该是<code class=\"language-text\">b * 0x0d32</code>而不是<code class=\"language-text\">0d42</code>。而且运行<code class=\"language-text\">x/3i</code>的结果和<code class=\"language-text\">sh.asm</code>里面记录的内容也不一样。。。神奇...正常运行的代码应该是：</p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\">00000d32 &lt;write&gt;:\nSYSCALL(write)\n     d32:\tb8 10 00 00 00       \tmov    $0x10,%eax\n     d37:\tcd 40                \tint    $0x40\n     d39:\tc3                   \tret    </code></pre></div>\n<p>其中<code class=\"language-text\">0x10</code>是write的system call number。这里还有一个疑问，就是系统是怎么在启动之后自动调用shell的，没太明白。下面就是按照lecture中的要求进行调试：</p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\">(gdb) b * 0x0d32\nBreakpoint 1 at 0xd32\n(gdb) c\nContinuing.\n...\n(gdb) info reg\neax            0x3f7a   16250\necx            0x24     36\nedx            0x0      0\nebx            0x24     36\nesp            0x3f4c   0x3f4c\nebp            0x3f98   0x3f98\nesi            0x11b9   4537\nedi            0x0      0\neip            0xd32    0xd32\neflags         0x216    [ PF AF IF ]\ncs             0x1b     27\nss             0x23     35\nds             0x23     35\nes             0x23     35\nfs             0x0      0\ngs             0x0      0</code></pre></div>\n<p>可以看到这时的<code class=\"language-text\">%cs</code>是<code class=\"language-text\">0x1b</code>也就是CPL=3，处于user mode。</p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\">(gdb) x/4x $esp\n0x3f4c: 0x00000ea5      0x00000002      0x00003f7a      0x00000001</code></pre></div>\n<p><code class=\"language-text\">esp</code>的这4个值分别是<code class=\"language-text\">ebf</code>(return address？这里存疑...)，2是fd，<code class=\"language-text\">0x3f7a</code>是buffer的地址，1是count，对应的就是<code class=\"language-text\">write(2, 0x3f7a, 1)</code></p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\">(gdb) x/c 0x3f7a\n0x3f7a: 36 &#39;$&#39;</code></pre></div>\n<p>就是说buffer里面存的就是要写出的<code class=\"language-text\">$</code>。如果继续往下运行，运行两步之后</p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\">(gdb) info reg\neax            0x10     16\necx            0x24     36\nedx            0x0      0\nebx            0x24     36\nesp            0x8dffefe8       0x8dffefe8\nebp            0x3f98   0x3f98\nesi            0x11b9   4537\nedi            0x0      0\neip            0x80105d49       0x80105d49 &lt;vector64+2&gt;\neflags         0x216    [ PF AF IF ]\ncs             0x8      8\nss             0x10     16\nds             0x23     35\nes             0x23     35\nfs             0x0      0\ngs             0x0      0</code></pre></div>\n<p><code class=\"language-text\">%cs</code>变为8，也就是CPL=0，进入了kernel模式，且注意<code class=\"language-text\">eip</code>已经进入了kernel memory里面，<code class=\"language-text\">esp</code>已经在kernel stack中。</p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\">(gdb) x/6wx $esp\n0x8dffefe8:     0x00000000      0x00000d39      0x0000001b      0x00000216\n0x8dffeff8:     0x00003f4c      0x00000023</code></pre></div>\n<p>可以看到<code class=\"language-text\">INT</code>指令把一些之前的register放在堆栈保存起来了，保存在了kernel stack。保存的register包括<code class=\"language-text\">err</code>, <code class=\"language-text\">eip</code>, <code class=\"language-text\">cs</code>, <code class=\"language-text\">eflags</code>, <code class=\"language-text\">esp</code>, <code class=\"language-text\">ss</code>。之所以会进行保存，是因为<code class=\"language-text\">INT</code>会overwrite这些register。</p>\n<p>总结来说<code class=\"language-text\">INT</code>做了如下的内容：</p>\n<ul>\n<li>切换为kernel stack（调整esp）</li>\n<li>保存用户的register于kernel stack</li>\n<li>设置CPL=0</li>\n<li>让eip指向kernel-supplied vector。</li>\n</ul>\n<p>前文我们知道<code class=\"language-text\">eip</code>是给定的kernel-supplied vector，那么<code class=\"language-text\">esp</code>来源于哪里呢？</p>\n<ul>\n<li>kernel会在创建进程的时候告诉硬件应该用哪个kernel stack。</li>\n</ul>\n<p>为什么INT需要保存用户状态？应该保存多少状态？</p>\n<ul>\n<li>transparency vs speed (这里<a href=\"https://en.wikipedia.org/wiki/Transparency_(human%E2%80%93computer_interaction)\">transparency</a>指在调用system call的时候不会对外部状态造成太多影响）</li>\n</ul>\n<p>而保存剩余的register用的是<code class=\"language-text\">trapasm.S</code>里头的<code class=\"language-text\">alltraps</code>函数。</p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\">  # vectors.S sends all traps here.\n.globl alltraps\nalltraps:\n  # Build trap frame.\n  pushl %ds\n  pushl %es\n  pushl %fs\n  pushl %gs\n  pushal\n  \n  # Set up data segments.\n  movw $(SEG_KDATA&lt;&lt;3), %ax\n  movw %ax, %ds\n  movw %ax, %es\n\n  # Call trap(tf), where tf=%esp\n  pushl %esp\n  call trap\n  addl $4, %esp\n\n  # Return falls through to trapret...\n.globl trapret\ntrapret:\n  popal\n  popl %gs\n  popl %fs\n  popl %es\n  popl %ds\n  addl $0x8, %esp  # trapno and errcode\n  iret</code></pre></div>\n<p>这个函数就是现在<code class=\"language-text\">eip</code>对应的<code class=\"language-text\">0x80105d49</code>对应的位置。所以堆栈里面存有的是19words:</p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\">    ss\n    esp\n    eflags\n    cs\n    eip\n    err    -- INT saved from here up\n    trapno\n    ds\n    es\n    fs\n    gs\n    eax..edi</code></pre></div>\n<p>这些都是之后会被恢复的。同时有的时候kernel的C code需要对这些尽心读写，就通过<code class=\"language-text\">x86.h</code>中的<code class=\"language-text\">struct trapframe</code>进行操作。</p>\n<p>可以看到调用了<code class=\"language-text\">trap</code>函数(在<code class=\"language-text\">trap.c</code>文件中)，其中<code class=\"language-text\">pushl %esp</code>就是<code class=\"language-text\">trap</code>函数的参数<code class=\"language-text\">tf</code>。进入这个函数之后，有：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(gdb) print tf\n$1 = (struct trapframe *) 0x8dffefb4\n(gdb) print *tf\n$2 = {edi = 0, esi = 4537, ebp = 16280, oesp = 2382360532, ebx = 36, edx = 0,\n  ecx = 36, eax = 16, gs = 0, padding1 = 0, fs = 0, padding2 = 0, es = 35,\n  padding3 = 0, ds = 35, padding4 = 0, trapno = 64, err = 0, eip = 3385,\n  cs = 27, padding5 = 0, eflags = 534, esp = 16204, ss = 35, padding6 = 0}</code></pre></div>\n<p><code class=\"language-text\">trap</code>函数的代码如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">void</span>\n<span class=\"token function\">trap</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">trapframe</span> <span class=\"token operator\">*</span>tf<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>tf<span class=\"token operator\">-></span>trapno <span class=\"token operator\">==</span> T_SYSCALL<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token function\">myproc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-></span>killed<span class=\"token punctuation\">)</span>\n      <span class=\"token function\">exit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">myproc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-></span>tf <span class=\"token operator\">=</span> tf<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">syscall</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token function\">myproc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-></span>killed<span class=\"token punctuation\">)</span>\n      <span class=\"token function\">exit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></code></pre></div>\n<p>进入trap函数的不只有system call，还有interrupt和fault，所以会先判断一下<code class=\"language-text\">tf->trapno</code>是不是<code class=\"language-text\">T_SYSCALL</code>。在本次运行的代码里，的确是（注意<code class=\"language-text\">T_SYSCALL</code>是60就是<code class=\"language-text\">INT</code>调用的<code class=\"language-text\">0x40</code>）。</p>\n<p>判断完就会运行<code class=\"language-text\">myproc()</code>（函数在<code class=\"language-text\">proc.c</code>中，函数返回的<code class=\"language-text\">struct proc</code>在<code class=\"language-text\">proc.h</code>中）。<code class=\"language-text\">myproc()->tf = tf;</code>会被当成当前的system call的单数。注意这个<code class=\"language-text\">myproc</code>函数很重要，返回的永远都是当前的process，所以可以在其他函数中通过调用它达到共享参数的功能：</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// Disable interrupts so that we are not rescheduled</span>\n<span class=\"token comment\">// while reading proc from the cpu structure</span>\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">proc</span><span class=\"token operator\">*</span>\n<span class=\"token function\">myproc</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">struct</span> <span class=\"token class-name\">cpu</span> <span class=\"token operator\">*</span>c<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">struct</span> <span class=\"token class-name\">proc</span> <span class=\"token operator\">*</span>p<span class=\"token punctuation\">;</span>\n  <span class=\"token function\">pushcli</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  c <span class=\"token operator\">=</span> <span class=\"token function\">mycpu</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  p <span class=\"token operator\">=</span> c<span class=\"token operator\">-></span>proc<span class=\"token punctuation\">;</span>\n  <span class=\"token function\">popcli</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> p<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>然后就调用<code class=\"language-text\">sycall()</code>，在<code class=\"language-text\">syscall.c</code>中</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">void</span>\n<span class=\"token function\">syscall</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">int</span> num<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">struct</span> <span class=\"token class-name\">proc</span> <span class=\"token operator\">*</span>curproc <span class=\"token operator\">=</span> <span class=\"token function\">myproc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  num <span class=\"token operator\">=</span> curproc<span class=\"token operator\">-></span>tf<span class=\"token operator\">-></span>eax<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>num <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> num <span class=\"token operator\">&lt;</span> <span class=\"token function\">NELEM</span><span class=\"token punctuation\">(</span>syscalls<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> syscalls<span class=\"token punctuation\">[</span>num<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    curproc<span class=\"token operator\">-></span>tf<span class=\"token operator\">-></span>eax <span class=\"token operator\">=</span> syscalls<span class=\"token punctuation\">[</span>num<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">cprintf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d %s: unknown sys call %d\\n\"</span><span class=\"token punctuation\">,</span>\n            curproc<span class=\"token operator\">-></span>pid<span class=\"token punctuation\">,</span> curproc<span class=\"token operator\">-></span>name<span class=\"token punctuation\">,</span> num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    curproc<span class=\"token operator\">-></span>tf<span class=\"token operator\">-></span>eax <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>用<code class=\"language-text\">curproc->tf->eax</code>得到当前的system call的序号，这里是<code class=\"language-text\">0x10</code>，对应的函数是<code class=\"language-text\">sys_write</code>，而<code class=\"language-text\">sys_write</code>在<code class=\"language-text\">sysfile.c</code>中，</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span>\n<span class=\"token function\">sys_write</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">struct</span> <span class=\"token class-name\">file</span> <span class=\"token operator\">*</span>f<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>p<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token function\">argfd</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>f<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span> <span class=\"token operator\">||</span> <span class=\"token function\">argint</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>n<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span> <span class=\"token operator\">||</span> <span class=\"token function\">argptr</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>p<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">filewrite</span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>上面的<code class=\"language-text\">arg*</code>函数会从user stack中读取<code class=\"language-text\">write(fd, buf, n)</code>的参数，例如<code class=\"language-text\">argint</code>函数在<code class=\"language-text\">syscall.c</code>中：</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// Fetch the nth 32-bit system call argument.</span>\n<span class=\"token keyword\">int</span>\n<span class=\"token function\">argint</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>ip<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">fetchint</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token function\">myproc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-></span>tf<span class=\"token operator\">-></span>esp<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">4</span> <span class=\"token operator\">+</span> <span class=\"token number\">4</span><span class=\"token operator\">*</span>n<span class=\"token punctuation\">,</span> ip<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>就是从<code class=\"language-text\">myproc()</code>中读出整数。等写入完了，也就是<code class=\"language-text\">sys_write</code>中的<code class=\"language-text\">filewrite</code>返回了，就开始一层一层返回，最终要还原user register。我们来一步一步看这个。</p>\n<p><code class=\"language-text\">syscall</code>函数把<code class=\"language-text\">filewrite</code>的返回值设为了<code class=\"language-text\">curproc->tf->eax</code>，之后就一步一步没有操作得返回到了<code class=\"language-text\">trapasm.S</code>。之后一连串直接运行到<code class=\"language-text\">iret</code>。在运行<code class=\"language-text\">iret</code>之前，就已经把除了<code class=\"language-text\">int</code>保存的那5个register以外的都恢复了，<code class=\"language-text\">iret</code>会把<code class=\"language-text\">eip</code>, <code class=\"language-text\">cs</code>, <code class=\"language-text\">eflags</code>, <code class=\"language-text\">esp</code>, <code class=\"language-text\">ss</code>这5个还原，因为还原了<code class=\"language-text\">cs</code>，所以也把模式 还原到了CPL=3，user mode。从而完成了</p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\">(gdb) info reg\neax            0x3f7a   16250\necx            0x20     32\nedx            0x0      0\nebx            0x20     32\nesp            0x3f4c   0x3f4c\nebp            0x3f98   0x3f98\nesi            0x11ba   4538\nedi            0x0      0\neip            0xd32    0xd32\neflags         0x216    [ PF AF IF ]\ncs             0x1b     27\nss             0x23     35\nds             0x23     35\nes             0x23     35\nfs             0x0      0\ngs             0x0      0</code></pre></div>\n<p>还原之后的register（不是很知道这些许的不同是什么意思，不过不同的都不是<code class=\"language-text\">iret</code>还原的，应该就是调用system call所需要产生的变化吧）。</p>\n<p>总结一下：</p>\n<ul>\n<li>INT -> alltrap -> trap -> syscall -> syswrite -> IRET</li>\n<li>user/kernel transition是很复杂的，如果出了个bug就gg了。</li>\n<li>kernel必须假设process是有敌意的，不能相信user stack，而且需要在kernel里面检查argument（应该是指syswrite里的argument检查）。</li>\n<li>下一讲会讲解page table是怎么限制user program可以读写的内存的。</li>\n</ul>","frontmatter":{"title":"6.828 笔记4","date":"2019-02-18T11:20:00.000Z","tags":["OS","6.828"]}}},"pageContext":{"slug":"/6.828-note4-isolation-mechanisms/"}},"staticQueryHashes":["3159585216"]}