{"componentChunkName":"component---src-templates-blog-post-js","path":"/把书读薄——C++模版-第二版/","webpackCompilationHash":"86a3b66fca16ecb8917b","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<p> 没想到自己已经俗成这样，要用高中老师的指导方针给博文命名了。</p>\n</blockquote>\n<p>上学的时候，老师常说，学习就是先把书读薄，再把书读厚，其实也就是先归纳框架，再抓住细节，或者拽一点就是先结构再解构。技术书则不然，因为技术书的框架往往简单，却又遍布细节，那么所谓讲技术书读薄，其实是挑选出对于个人来说那些重要而又记不住的细节。本文大致就是这样的思路，打算把《C++ 模版（第二版）》这个书里的这些记不住的细节提取出来，让我在又一次想要重学 C++ 模版的时候，能不用重翻那几百页的 pdf。</p>\n<h2>Ch1 Function Templates</h2>\n<h3>实例化</h3>\n<p><strong>实例化模版</strong>时，会分 2 阶段编译：</p>\n<ol>\n<li>\n<p>模版定义阶段，不检查参数类型，只检查：</p>\n<ul>\n<li>语法（例如少了分号）</li>\n<li>使用了未定义的类型名、函数名等不依赖于模版参数的名称（类似 unbounded variable）</li>\n<li>未使用模版参数的 static assertions</li>\n</ul>\n</li>\n<li>模版实例化阶段，再去检查对于这个具体的类型，有没有啥错误。</li>\n</ol>\n<h3>类型推断</h3>\n<p>类型推断中的类型转换：</p>\n<ul>\n<li>如果参数是按引用传递的，任何类型转换都不被允许；</li>\n<li>如果参数是按值传递的，可以 decay，也就是可以忽略 <code class=\"language-text\">const</code> 与 <code class=\"language-text\">volatile</code>，引用类型被转化成被引用的类型，raw array 和函数被转为指针类型。</li>\n</ul>\n<p>类型推断<strong>不适用</strong>于默认调用参数，需要在模版参数中声明默认参数，例如：</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span> <span class=\"token operator\">=</span> std<span class=\"token operator\">::</span>string<span class=\"token operator\">></span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>T <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>类型推断不会考虑<strong>返回类型</strong>，需要显示指示，所以如果需要这么搞的话，最好把返回类型放最前面：</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">RT</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">typename</span> <span class=\"token class-name\">T1</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">typename</span> <span class=\"token class-name\">T2</span><span class=\"token operator\">></span>\nRT <span class=\"token function\">max</span><span class=\"token punctuation\">(</span>T1 a<span class=\"token punctuation\">,</span> T2<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token operator\">::</span>max<span class=\"token operator\">&lt;</span><span class=\"token keyword\">double</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">7.2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>但是实际上在 C++14 就已经可以直接用 <code class=\"language-text\">auto</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T1</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">typename</span> <span class=\"token class-name\">T2</span><span class=\"token operator\">></span>\n<span class=\"token keyword\">auto</span> <span class=\"token function\">max</span><span class=\"token punctuation\">(</span>T1 a<span class=\"token punctuation\">,</span> T2 b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> b <span class=\"token operator\">&lt;</span> a <span class=\"token operator\">?</span> a <span class=\"token operator\">:</span> b<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span></code></pre></div>\n<p>C++14 之前，需要用 trailing return type，注意这里需要的只是类型，所以标注成 <code class=\"language-text\">decltype(true ? a : b)</code> 就行了：</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T1</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">typename</span> <span class=\"token class-name\">T2</span><span class=\"token operator\">></span>\n<span class=\"token keyword\">auto</span> <span class=\"token function\">max</span><span class=\"token punctuation\">(</span>T1 a<span class=\"token punctuation\">,</span> T2 b<span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token keyword\">decltype</span><span class=\"token punctuation\">(</span>b <span class=\"token operator\">&lt;</span> a <span class=\"token operator\">?</span> a <span class=\"token operator\">:</span> b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> b <span class=\"token operator\">&lt;</span> a <span class=\"token operator\">?</span> a <span class=\"token operator\">:</span> b<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>不过这里 <code class=\"language-text\">T1</code>、<code class=\"language-text\">T2</code> 可能是引用类型，所以我们应该 decay 一下：</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T1</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">typename</span> <span class=\"token class-name\">T2</span><span class=\"token operator\">></span>\n<span class=\"token keyword\">auto</span> <span class=\"token function\">max</span><span class=\"token punctuation\">(</span>T1 a<span class=\"token punctuation\">,</span> T2 b<span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> std<span class=\"token operator\">::</span>decay_t<span class=\"token operator\">&lt;</span><span class=\"token keyword\">decltype</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span> <span class=\"token operator\">?</span> a <span class=\"token operator\">:</span> b<span class=\"token punctuation\">)</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">}</span></code></pre></div>\n<p>这里要注意，用 <code class=\"language-text\">auto</code> 初始化的变量会自动 decay，所以最上面纯 C++14 的那种也会自动 decay：</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> <span class=\"token keyword\">const</span><span class=\"token operator\">&amp;</span> ir <span class=\"token operator\">=</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">auto</span> a <span class=\"token operator\">=</span> ir<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// a 为 int 类型</span></code></pre></div>\n<p>还有一个方法，可以用 <code class=\"language-text\">common_type</code>，不过这个东西返回的类型和 <code class=\"language-text\">? :</code> 差不多，但是 <code class=\"language-text\">common_type</code> 是会做 decay 的：</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T1</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">typename</span> <span class=\"token class-name\">T2</span><span class=\"token operator\">></span>\nstd<span class=\"token operator\">::</span>common_type_t<span class=\"token operator\">&lt;</span>T1<span class=\"token punctuation\">,</span> T2<span class=\"token operator\">></span> <span class=\"token function\">max</span><span class=\"token punctuation\">(</span>T1 a<span class=\"token punctuation\">,</span> T2 b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">}</span></code></pre></div>\n<h3>函数重载</h3>\n<p>函数重载会在有多个重名函数的情况下出现。</p>\n<p>没有模版的时候，重载大致是这么搞的：</p>\n<ul>\n<li>把所有重名的函数都拿出来，形成一个 <em>overload set</em></li>\n<li>适当做一些调整，例如 template argument deduction 和 substitution，从而可以人掉一些模版函数</li>\n<li>丢掉任何在考虑了默认参数和隐式类型转化都还不能匹配上的函数，得到一个 <em>viable function candidates</em> set</li>\n<li>找到最合适的那个，如果没有最合适的，则判断为 ambiguous，报错</li>\n<li>检查最合适的那个有没有问题，例如是不是 <code class=\"language-text\">= delete</code>，或者是 private member funciton，如果有问题，那就针对着报错</li>\n</ul>\n<p>在找最合适的（overload resolution）时候，是这么排序的：</p>\n<ol>\n<li>prefect match：类型就是对的，或者 argument（传进来的那个东西）是 parameter（函数定义里的那个东西）的引用（这个引用可以带着 <code class=\"language-text\">const</code> 和/或 <code class=\"language-text\">volatile</code>）</li>\n<li>match with minor adjustment：把数组类型 decay 成指针，或者类似于把 <code class=\"language-text\">int**</code> 转成 <code class=\"language-text\">int const * const *</code></li>\n<li>match with promotion：类似于把 <code class=\"language-text\">char</code> 转成 <code class=\"language-text\">int</code>，把 <code class=\"language-text\">float</code> 转成 <code class=\"language-text\">double</code></li>\n<li>match with standard conversions only：例如把 int 转成 float，把衍生类转成基类，不过这个类型转换一定不涉及用户自己写的那种转换构造函数</li>\n<li>match with user-defined conversions：任何 impllicit conversion</li>\n<li>match with ellipsis（<code class=\"language-text\">...</code>）：一个 ellipsis 可以匹配任何东西，不过 Class types with a nontrivial copy constructor may or may not be valid (implementations are free to allow or disallow this).</li>\n</ol>\n<p>然后有一些超级细节，可以直接看附录 C...</p>\n<p>有模版了之后：</p>\n<ul>\n<li>如果有参数类型完全匹配的非模版函数（常规函数），会先调用那个函数。不过可以用 <code class=\"language-text\">::max&lt;&gt;</code> 这样的方式来调用模版函数，并仍然去推断类型</li>\n<li>\n<p>模版函数不能自动类型转换，但是常规函数可以，例如 <code class=\"language-text\">::max(&#39;a&#39;, 42.7)</code> 是会去调用常规函数 <code class=\"language-text\">int max(int, int)</code> 的。这是因为模版函数 deduction 会在 overload resolution 前进行，且不考虑各种类型转化，一个更详细的例子是：</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">MyString</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n<span class=\"token function\">MyString</span><span class=\"token punctuation\">(</span>T <span class=\"token keyword\">const</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// converting constructor</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span>\nMyString<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token function\">truncate</span><span class=\"token punctuation\">(</span>MyString<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token keyword\">const</span><span class=\"token operator\">&amp;</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\nMyString<span class=\"token operator\">&lt;</span><span class=\"token keyword\">char</span><span class=\"token operator\">></span> str1<span class=\"token punctuation\">,</span> str2<span class=\"token punctuation\">;</span>\nstr1 <span class=\"token operator\">=</span> truncate<span class=\"token operator\">&lt;</span><span class=\"token keyword\">char</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello World\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// OK</span>\nstr2 <span class=\"token operator\">=</span> <span class=\"token function\">truncate</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello World\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ERROR, as there is no viable function when not considering implicit conversion.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>C++ 有定义顺序的问题，如果一个位置在优先级高的函数前面调用重载函数，那会调用到前面的优先级低的函数。</li>\n</ul>\n<h3>Miscellaneous</h3>\n<ol>\n<li>用值传递，模版和引用混到一起太复杂了，实在要用引用，可以用 <code class=\"language-text\">std::ref</code> 和 <code class=\"language-text\">std::cref</code></li>\n<li>模版函数不需要写 <code class=\"language-text\">inline</code></li>\n</ol>\n<h2>Ch2 Class Templates</h2>\n<p>如果在模板类内部直接使用类名（例如 <code class=\"language-text\">Stack</code>），而不是带着类型参数的话，表示这个内部类的模版参数和模板类相同，例如：</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Stack</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">Stack</span><span class=\"token punctuation\">(</span>Stack <span class=\"token keyword\">const</span><span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// copy constructor</span>\n  Stack<span class=\"token operator\">&amp;</span> <span class=\"token keyword\">operator</span><span class=\"token operator\">=</span><span class=\"token punctuation\">(</span>Stack <span class=\"token keyword\">const</span><span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// assignment operator</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>其等同于：</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Stack</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">Stack</span><span class=\"token punctuation\">(</span>Stack<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token keyword\">const</span><span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// copy constructor</span>\n  Stack<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> <span class=\"token keyword\">operator</span><span class=\"token operator\">=</span><span class=\"token punctuation\">(</span>Stack<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token keyword\">const</span><span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// assignment operator</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>在写成员函数的时候，也需要写上 <code class=\"language-text\">template &lt;typename T&gt;</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span>\n<span class=\"token keyword\">void</span> <span class=\"token class-name\">Stack</span><span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token operator\">::</span><span class=\"token function\">push</span> <span class=\"token punctuation\">(</span>T <span class=\"token keyword\">const</span><span class=\"token operator\">&amp;</span> elem<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  elems<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>elem<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// append copy of passed elem</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>模版函数和模版成员函数都是只有被调用的时候才会实例化，例如说有一个成员函数里有 <code class=\"language-text\">a++</code>，但仍然可以有 <code class=\"language-text\">A&lt;string&gt;</code> 这样的类。</p>\n<h3>特化</h3>\n<p>全部特化应该这么写 </p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Stack</span><span class=\"token operator\">&lt;</span>std<span class=\"token operator\">::</span>string<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token class-name\">Stack</span><span class=\"token operator\">&lt;</span>std<span class=\"token operator\">::</span>string<span class=\"token operator\">></span><span class=\"token operator\">::</span><span class=\"token function\">push</span> <span class=\"token punctuation\">(</span>std<span class=\"token operator\">::</span>string <span class=\"token keyword\">const</span><span class=\"token operator\">&amp;</span> elem<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  elems<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>elem<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// append copy of passed elem</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>部分特化可以：</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Stack</span><span class=\"token operator\">&lt;</span>T<span class=\"token operator\">*</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span>\nT<span class=\"token operator\">*</span> <span class=\"token class-name\">Stack</span><span class=\"token operator\">&lt;</span>T<span class=\"token operator\">*</span><span class=\"token operator\">></span><span class=\"token operator\">::</span><span class=\"token function\">pop</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">assert</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>elems<span class=\"token punctuation\">.</span><span class=\"token function\">empty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  T<span class=\"token operator\">*</span> p <span class=\"token operator\">=</span> elems<span class=\"token punctuation\">.</span><span class=\"token function\">back</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  elems<span class=\"token punctuation\">.</span><span class=\"token function\">pop_back</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// remove last element</span>\n  <span class=\"token keyword\">return</span> p<span class=\"token punctuation\">;</span> <span class=\"token comment\">// and return it (unlike in the general case)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>多模版参数的部分特化：</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\">// partial specialization: both template parameters have same type</span>\n<span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">MyClass</span><span class=\"token operator\">&lt;</span>T<span class=\"token punctuation\">,</span>T<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// partial specialization: second type is int</span>\n<span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">MyClass</span><span class=\"token operator\">&lt;</span>T<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// partial specialization: both template parameters are pointer types</span>\n<span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">T1</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">typename</span> <span class=\"token class-name\">T2</span><span class=\"token operator\">></span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">MyClass</span><span class=\"token operator\">&lt;</span>T1<span class=\"token operator\">*</span><span class=\"token punctuation\">,</span>T2<span class=\"token operator\">*</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h2>Ch16 Specialization and Overloading</h2>\n<p>Ch1 和 Ch2 只是简单讲了讲对应 specialization 的 overloading 的规则，这章会更展开一些。</p>\n<h3>function signatures</h3>\n<p>签名不同的函数可以 coexist，所以</p>\n<p>虽然可以 coexist，但是调用会出现 ambiguity</p>","frontmatter":{"title":"把书读薄——C++ 模版（第二版）","date":"2023-07-05T12:30:00.000Z","tags":["C++"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/把书读薄——C++模版-第二版/"}}}