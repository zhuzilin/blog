{"componentChunkName":"component---src-templates-blog-post-js","path":"/EOPL-读书笔记-Ch4/","webpackCompilationHash":"cb894d9b8b35d24cbcd1","result":{"data":{"markdownRemark":{"html":"<p>继续看 EOPL。</p>\n<h2>Ch4 State</h2>\n<h3>4.1 Computational Effects</h3>\n<p>求值和产生 effect 的区别是什么呢？effect 是 global 的，整个计算都能观察到，并影响整个计算。</p>\n<p>我们主要关心一个 effect：向某个内存位置赋值。</p>\n<p>赋值和绑定的区别是什么呢？binding 是 local 的，但是赋值可能是全局的。</p>\n<p>我们将把 memory 建模为从 location 到 storable values 的 finite map。一般来说 storable values 和 expressed values 是相同的。</p>\n<p>表示 location 的数据结构称为 reference。reference 有时被称为 L-values，表示其往往出现在赋值语句的左边。类似地，expressed values 被称为 R-values。</p>\n<p>在本章中，我们会考虑 2 种设计，explicit references 和 implicit references。</p>\n<h3>4.2 EXPLICIT_REFS: A Langauge with Explicit References</h3>\n<p>在 explicit references 中，我们会把 reference 作为一种新的 expressed value：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">ExpVal = Int + Bool + Proc + Ref(ExpVal)\nDenVal = ExpVal</code></pre></div>\n<p>我们要加入 3 个新操作：</p>\n<ul>\n<li><code class=\"language-text\">newref</code>：分配新 location，并返回其 reference</li>\n<li><code class=\"language-text\">deref</code>：返回 reference 指向的 location 里面存储的值</li>\n<li><code class=\"language-text\">setref</code>：改变 reference 指向的 location 里面存储的值</li>\n</ul>\n<p>一个 EXPLICIT_REFS 语言的例子如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"lisp\"><pre class=\"language-lisp\"><code class=\"language-lisp\">let g = let counter = newref<span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n\t\t\t\tin proc <span class=\"token punctuation\">(</span><span class=\"token car\">dummy</span><span class=\"token punctuation\">)</span>\n             begin\n              setref<span class=\"token punctuation\">(</span><span class=\"token car\">counter</span>, -<span class=\"token punctuation\">(</span><span class=\"token car\">deref</span><span class=\"token punctuation\">(</span><span class=\"token car\">counter</span><span class=\"token punctuation\">)</span>, <span class=\"token number\">-1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token comment\">;</span>\n              deref<span class=\"token punctuation\">(</span><span class=\"token car\">counter</span><span class=\"token punctuation\">)</span>\n          \t end\nin let a = <span class=\"token punctuation\">(</span><span class=\"token car\">g</span> <span class=\"token number\">11</span><span class=\"token punctuation\">)</span>\n  in let b = <span class=\"token punctuation\">(</span><span class=\"token car\">g</span> <span class=\"token number\">11</span><span class=\"token punctuation\">)</span>\n\t\tin -<span class=\"token punctuation\">(</span><span class=\"token car\">a</span><span class=\"token splice symbol variable\">,b</span><span class=\"token punctuation\">)</span></code></pre></div>\n<h4>4.2.1 Store-Passing Specifications</h4>\n<p>store-passing specification 中 store 会作为 <code class=\"language-text\">value-of</code> 的显示输入，并作为输出的一部分：</p>\n<div class=\"gatsby-highlight\" data-language=\"lisp\"><pre class=\"language-lisp\"><code class=\"language-lisp\"><span class=\"token punctuation\">(</span><span class=\"token car\">value-of</span> exp1 ρ σ0<span class=\"token punctuation\">)</span> = <span class=\"token punctuation\">(</span><span class=\"token car\">val1</span>,σ1<span class=\"token punctuation\">)</span></code></pre></div>\n<p>根据这点，我们可以更新之前的 specification。</p>\n<p>constant：</p>\n<div class=\"gatsby-highlight\" data-language=\"lisp\"><pre class=\"language-lisp\"><code class=\"language-lisp\"><span class=\"token punctuation\">(</span><span class=\"token car\">value-of</span> <span class=\"token punctuation\">(</span><span class=\"token car\">const-exp</span> n<span class=\"token punctuation\">)</span> ρ σ<span class=\"token punctuation\">)</span> = <span class=\"token punctuation\">(</span><span class=\"token car\">n</span>,σ<span class=\"token punctuation\">)</span></code></pre></div>\n<p>difference:</p>\n<p><img src=\"https://i.loli.net/2021/05/06/4o7nuTpa3YH21qx.png\" alt=\"image.png\"></p>\n<p>注意，假设中两次 <code class=\"language-text\">value-of</code> 的 store 都不一样。</p>\n<p>if:</p>\n<p><img src=\"https://i.loli.net/2021/05/06/ZIOJf7ktRA9LDbl.png\" alt=\"image.png\"></p>\n<h4>4.2.2 Specifying Operations on Explicit References</h4>\n<p>这一节我们来看一下 <code class=\"language-text\">newref</code>、<code class=\"language-text\">deref</code> 和 <code class=\"language-text\">setref</code> 的 specification。</p>\n<p>首先是 <code class=\"language-text\">newref</code>：</p>\n<p><img src=\"https://i.loli.net/2021/05/06/BULNVtEdGsCM38k.png\" alt=\"image.png\"></p>\n<p>其次是 <code class=\"language-text\">deref</code>：</p>\n<p><img src=\"https://i.loli.net/2021/05/06/wbJ8D4OTjPylntF.png\" alt=\"image.png\"></p>\n<p>最后是 <code class=\"language-text\">setref</code>：</p>\n<p><img src=\"https://i.loli.net/2021/05/06/V9lWhBzILqrFyQm.png\" alt=\"image.png\"></p>\n<p>这里返回的 23 是个任意数。</p>\n<h4>4.2.3 Implementation</h4>\n<p>我们不打算如 specification 指示的去把 store 作为 <code class=\"language-text\">value-of</code> 的输入输出，而是打算使用 Scheme（Racket）本身的 store。为了简单起见，我们把 store 做成了一个 list，reference 就是 list 的位置。</p>\n<div class=\"gatsby-highlight\" data-language=\"lisp\"><pre class=\"language-lisp\"><code class=\"language-lisp\"><span class=\"token comment\">; empty-store : () → Sto</span>\n<span class=\"token punctuation\">(</span><span class=\"token car\">define</span> empty-store\n  <span class=\"token punctuation\">(</span><span class=\"token lambda\"><span class=\"token keyword\">lambda</span> <span class=\"token punctuation\">(</span><span class=\"token arguments\"></span><span class=\"token punctuation\">)</span></span> ’<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">; usage: A Scheme variable containing the current state</span>\n<span class=\"token comment\">; of the store. Initially set to a dummy value.</span>\n<span class=\"token punctuation\">(</span><span class=\"token car\">define</span> the-store ’uninitialized<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">; get-store : () → Sto</span>\n<span class=\"token punctuation\">(</span><span class=\"token car\">define</span> get-store\n  <span class=\"token punctuation\">(</span><span class=\"token lambda\"><span class=\"token keyword\">lambda</span> <span class=\"token punctuation\">(</span><span class=\"token arguments\"></span><span class=\"token punctuation\">)</span></span> the-store<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">; initialize-store! : () → Unspecified</span>\n<span class=\"token comment\">; usage: (initialize-store!) sets the-store to the empty store</span>\n<span class=\"token punctuation\">(</span><span class=\"token car\">define</span> initialize-store!\n  <span class=\"token punctuation\">(</span><span class=\"token lambda\"><span class=\"token keyword\">lambda</span> <span class=\"token punctuation\">(</span><span class=\"token arguments\"></span><span class=\"token punctuation\">)</span></span>\n    <span class=\"token punctuation\">(</span><span class=\"token car\">set!</span> the-store <span class=\"token punctuation\">(</span><span class=\"token car\">empty-store</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">; reference? : SchemeVal → Bool</span>\n<span class=\"token punctuation\">(</span><span class=\"token car\">define</span> reference?\n  <span class=\"token punctuation\">(</span><span class=\"token lambda\"><span class=\"token keyword\">lambda</span> <span class=\"token punctuation\">(</span><span class=\"token arguments\"><span class=\"token argument variable\">v</span></span><span class=\"token punctuation\">)</span></span>\n    <span class=\"token punctuation\">(</span><span class=\"token car\">integer</span>? v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>从而得到了如下的实现：</p>\n<div class=\"gatsby-highlight\" data-language=\"lisp\"><pre class=\"language-lisp\"><code class=\"language-lisp\"><span class=\"token comment\">; newref : ExpVal → Ref</span>\n<span class=\"token punctuation\">(</span><span class=\"token car\">define</span> newref\n  <span class=\"token punctuation\">(</span><span class=\"token lambda\"><span class=\"token keyword\">lambda</span> <span class=\"token punctuation\">(</span><span class=\"token arguments\"><span class=\"token argument variable\">val</span></span><span class=\"token punctuation\">)</span></span>\n    <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token car\">next-ref</span> <span class=\"token punctuation\">(</span><span class=\"token car\">length</span> the-store<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">(</span><span class=\"token car\">set!</span> the-store <span class=\"token punctuation\">(</span><span class=\"token keyword\">append</span> the-store <span class=\"token punctuation\">(</span><span class=\"token car\">list</span> val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      next-ref<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">; deref : Ref → ExpVal</span>\n<span class=\"token punctuation\">(</span><span class=\"token car\">define</span> deref\n  <span class=\"token punctuation\">(</span><span class=\"token lambda\"><span class=\"token keyword\">lambda</span> <span class=\"token punctuation\">(</span><span class=\"token arguments\"><span class=\"token argument variable\">ref</span></span><span class=\"token punctuation\">)</span></span>\n    <span class=\"token punctuation\">(</span><span class=\"token car\">list-ref</span> the-store ref<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">; setref! : Ref × ExpVal → Unspecified</span>\n<span class=\"token comment\">; usage: sets the-store to a state like the original, but with</span>\n<span class=\"token comment\">; position ref containing val.</span>\n<span class=\"token punctuation\">(</span><span class=\"token car\">define</span> setref!\n  <span class=\"token punctuation\">(</span><span class=\"token lambda\"><span class=\"token keyword\">lambda</span> <span class=\"token punctuation\">(</span><span class=\"token arguments\"><span class=\"token argument variable\">ref</span> <span class=\"token argument variable\">val</span></span><span class=\"token punctuation\">)</span></span>\n    <span class=\"token punctuation\">(</span><span class=\"token car\">set!</span> the-store\n    <span class=\"token punctuation\">(</span><span class=\"token car\">letrec</span>\n      <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token car\">setref-inner</span>\n        <span class=\"token comment\">; usage: returns a list like store1, except that</span>\n        <span class=\"token comment\">; position ref1 contains val.</span>\n        <span class=\"token punctuation\">(</span><span class=\"token lambda\"><span class=\"token keyword\">lambda</span> <span class=\"token punctuation\">(</span><span class=\"token arguments\"><span class=\"token argument variable\">store1</span> <span class=\"token argument variable\">ref1</span></span><span class=\"token punctuation\">)</span></span>\n          <span class=\"token punctuation\">(</span><span class=\"token keyword\">cond</span>\n          \t<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token car\">null</span>? store1<span class=\"token punctuation\">)</span>\n          \t\t<span class=\"token punctuation\">(</span><span class=\"token car\">report-invalid-reference</span> ref the-store<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n          \t<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token car\">zero</span>? ref1<span class=\"token punctuation\">)</span>\n          \t\t<span class=\"token punctuation\">(</span><span class=\"token keyword\">cons</span> val <span class=\"token punctuation\">(</span><span class=\"token car\">cdr</span> store1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n          \t<span class=\"token punctuation\">(</span><span class=\"token car\">else</span>\n          \t\t<span class=\"token punctuation\">(</span><span class=\"token keyword\">cons</span>\n          \t\t\t<span class=\"token punctuation\">(</span><span class=\"token car\">car</span> store1<span class=\"token punctuation\">)</span>\n          \t\t\t<span class=\"token punctuation\">(</span><span class=\"token car\">setref-inner</span> <span class=\"token punctuation\">(</span><span class=\"token car\">cdr</span> store1<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token car\">-</span> ref1 <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">(</span><span class=\"token car\">setref-inner</span> the-store ref<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>直接看代码就好，还是挺清楚的。</p>\n<h3>4.3 IMPLICIT-REFS: A Language with Implicit References</h3>\n<p>很多语言把 reference 和 dereference 的过程隐藏起来了，也就是说所有的变量表示的都是 reference：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">ExpVal = Int + Bool + Proc\nDenVal = Ref(ExpVal)</code></pre></div>\n<p>在每次 binding 的时候会创建 location，也就是每次的 procedure call, <code class=\"language-text\">let</code> 或 <code class=\"language-text\">letrec</code>。</p>\n<p>当 variable 出现在 expression 中时，我们会查看 environment 来查看它 bound 的 location，之后查看 store 来找到值。也就是我们的 <code class=\"language-text\">var-exp</code> 是一个双层的系统。</p>\n<p>location 中的值可以通过 <code class=\"language-text\">set</code> 表达式来改变，也就是新语法：</p>\n<div class=\"gatsby-highlight\" data-language=\"lisp\"><pre class=\"language-lisp\"><code class=\"language-lisp\">Expression :<span class=\"token lisp-property property\">:=</span> set Identifier = Expression\n               assign-exp <span class=\"token punctuation\">(</span><span class=\"token car\">var</span> exp1<span class=\"token punctuation\">)</span></code></pre></div>\n<p>这里的 Identifier 不是 expression 的一部分，所以不会被 dereference。</p>\n<p>这种设计，我们称变量是可变的（mutable）。这种设计则被称为 call-by-value 或 implicit reference。大多数编程语言，包括 Scheme 在内，都采用了这种设计的某种变形。</p>\n<div class=\"gatsby-highlight\" data-language=\"lisp\"><pre class=\"language-lisp\"><code class=\"language-lisp\">let g = let count = <span class=\"token number\">0</span>\n        in proc <span class=\"token punctuation\">(</span><span class=\"token car\">dummy</span><span class=\"token punctuation\">)</span>\n            begin\n              set count = -<span class=\"token punctuation\">(</span><span class=\"token car\">count</span><span class=\"token splice symbol variable\">,-1</span><span class=\"token punctuation\">)</span><span class=\"token comment\">;</span>\n              count\n            end\nin let a = <span class=\"token punctuation\">(</span><span class=\"token car\">g</span> <span class=\"token number\">11</span><span class=\"token punctuation\">)</span>\n  in let b = <span class=\"token punctuation\">(</span><span class=\"token car\">g</span> <span class=\"token number\">11</span><span class=\"token punctuation\">)</span>\n\t\tin -<span class=\"token punctuation\">(</span><span class=\"token car\">a</span><span class=\"token splice symbol variable\">,b</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>上面是 implicit reference 的一个例子，可以和上面的 explicit 的例子比较一下。</p>\n<h4>4.3.1 Specification</h4>\n<p>首先是取值：</p>\n<div class=\"gatsby-highlight\" data-language=\"lisp\"><pre class=\"language-lisp\"><code class=\"language-lisp\"><span class=\"token punctuation\">(</span><span class=\"token car\">value-of</span> <span class=\"token punctuation\">(</span><span class=\"token car\">var-exp</span> var<span class=\"token punctuation\">)</span> ρ σ<span class=\"token punctuation\">)</span> = <span class=\"token punctuation\">(</span>σ<span class=\"token punctuation\">(</span>ρ<span class=\"token punctuation\">(</span><span class=\"token car\">var</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>, σ<span class=\"token punctuation\">)</span></code></pre></div>\n<p>然后是 assign，也就是 <code class=\"language-text\">set</code>：</p>\n<p><img src=\"https://i.loli.net/2021/05/06/ANI4quGL8l7tQsE.png\" alt=\"image.png\"></p>\n<p>这里的 27 也是个随机数。</p>\n<p>然后是 <code class=\"language-text\">apply-procedure</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"lisp\"><pre class=\"language-lisp\"><code class=\"language-lisp\"><span class=\"token punctuation\">(</span><span class=\"token car\">apply-procedure</span> <span class=\"token punctuation\">(</span><span class=\"token car\">procedure</span> var body ρ<span class=\"token punctuation\">)</span> val σ<span class=\"token punctuation\">)</span>\n= <span class=\"token punctuation\">(</span><span class=\"token car\">value-of</span> body <span class=\"token punctuation\">[</span>var = l<span class=\"token punctuation\">]</span>ρ <span class=\"token punctuation\">[</span>l = val<span class=\"token punctuation\">]</span>σ<span class=\"token punctuation\">)</span></code></pre></div>\n<p>注意这里是没有垃圾回收的，每次调用都会使用新的 location。</p>\n<h4>4.3.2 Implementation</h4>\n<p>照着 specification 写就行。里面还是要用到 4.2 中定义的 <code class=\"language-text\">newref</code>，<code class=\"language-text\">deref</code> 和 <code class=\"language-text\">setref!</code> 的。</p>\n<h3>4.4 MUTABLE-PAIRS: A Language with Mutable Pairs</h3>\n<p>在练习 3.9 中，我们在语言中加入了 list，不过当时的 list 是不可变的（也就是没有 scheme 中的 <code class=\"language-text\">set-car!</code> 和 <code class=\"language-text\">set-cdr!</code>）。在这一节中，我们将给 IMPLICIT-REFS 中加上 mutable pairs。这样 expressed value 变成：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">ExpVal = Int + Bool + Proc + MutPair\nDenVal = Ref(ExpVal)\nMutPair = Ref(ExpVal) × Ref(ExpVal)</code></pre></div>\n<p>还有加入下列 interface：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">newpair  : Expval × Expval → MutPair\nleft     : MutPair → Expval\nright    : MutPair → Expval\nsetleft  : MutPair × Expval → Unspecified\nsetright : MutPair × Expval → Unspecified</code></pre></div>\n<h4>4.4.1 Implementation</h4>\n<h4>4.4.2 Another Representation of Mutable Pairs</h4>\n<p>我们知道 <code class=\"language-text\">MutPair</code> 的两个值的存储位置相邻，所以实际上我们可以只用左边的元素的 reference 表示整体的 reference。</p>\n<h3>4.5 Parameter-Passing Variations</h3>\n<h4>4.5.1 CALL-BY-REFERENCE</h4>\n<h4>4.5.2 Lazy Evaluation: CALL-BY-NAME and CALL-BY-NEED</h4>\n<p>如果 body 不使用其参数，那么我们就不需要 evaluate 它。</p>\n<div class=\"gatsby-highlight\" data-language=\"lisp\"><pre class=\"language-lisp\"><code class=\"language-lisp\">letrec infinite-loop <span class=\"token punctuation\">(</span><span class=\"token car\">x</span><span class=\"token punctuation\">)</span> = infinite-loop<span class=\"token punctuation\">(</span><span class=\"token car\">-</span><span class=\"token punctuation\">(</span><span class=\"token car\">x</span><span class=\"token splice symbol variable\">,-1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\nin let f = proc <span class=\"token punctuation\">(</span><span class=\"token car\">z</span><span class=\"token punctuation\">)</span> <span class=\"token number\">11</span>\n  in <span class=\"token punctuation\">(</span><span class=\"token car\">f</span> <span class=\"token punctuation\">(</span><span class=\"token car\">infinite-loop</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>在上面这个例子中 <code class=\"language-text\">infinite-loop</code> 是不会停止的，但是在 lazy evaluation 的情况下，这个程序会直接返回 11，因为并不会 evalutate 参数的值。</p>\n<p>下面让我们来把我们的语言改成 lazy evaluation 的。为了表明</p>","frontmatter":{"title":"EOPL 读书笔记 Ch4","date":"2021-05-06T09:30:00.000Z","tags":["PL"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/EOPL-读书笔记-Ch4/"}}}