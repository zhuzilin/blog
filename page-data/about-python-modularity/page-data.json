{"componentChunkName":"component---src-templates-blog-post-js","path":"/about-python-modularity/","webpackCompilationHash":"f06ec16250d3012c8cc2","result":{"data":{"markdownRemark":{"html":"<p>This post is full of quote right now. Maybe sometime I will add some of my own understanding. But at the moment, the words in the reference has already good enough.</p>\n<h2>module</h2>\n<p>From the document, the definition of module in python is</p>\n<blockquote>\n<p>A module is a file containing Python definitions and statements. The file name is the module name with the suffix <code class=\"language-text\">.py</code> appended.</p>\n</blockquote>\n<p>The use of modules saves the authors of different modules from having to worry about each other’s global variable names.</p>\n<h3>__name__</h3>\n<blockquote>\n<p>Within a module, the module’s name (as a string) is available as the value of the global variable<code class=\"language-text\">__name__</code></p>\n</blockquote>\n<p>Therefore, any <code class=\"language-text\">.py</code> file is a module.  And any module can be imported by the <code class=\"language-text\">import</code> statement with its <code class=\"language-text\">__name__</code>.</p>\n<p>Then what is <code class=\"language-text\">if __name__ == &quot;__main__&quot;:</code>? </p>\n<blockquote>\n<p><code class=\"language-text\">&#39;__main__&#39;</code> is the name of the scope in which top-level code executes. A module’s <strong>name</strong> is set equal to <code class=\"language-text\">&#39;__main__&#39;</code> when read from standard input, a script, or from an interactive prompt.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ python\n<span class=\"token operator\">>></span><span class=\"token operator\">></span> __name__\n<span class=\"token string\">'__main__'</span></code></pre></div>\n<p>Notice that if a module is run by <code class=\"language-text\">python -m</code>, the name would also be set as <code class=\"language-text\">&#39;__main__&#39;</code>. But there is a solution for the renaming case: <a href=\"https://www.python.org/dev/peps/pep-0366/\">PEP 366</a> introduced the <code class=\"language-text\">__package__</code> attribute.</p>\n<blockquote>\n<p>The major proposed change is the introduction of a new module level attribute, <code class=\"language-text\">__package__</code>. When it is present, relative imports will be based on this attribute rather than the module <code class=\"language-text\">__name__</code> attribute.</p>\n</blockquote>\n<p>Therefore, we could use the following code to solve the problem:</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">if</span> __name__ <span class=\"token operator\">==</span> <span class=\"token string\">\"__main__\"</span> <span class=\"token keyword\">and</span> __package__ <span class=\"token keyword\">is</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n    __package__ <span class=\"token operator\">=</span> <span class=\"token string\">\"expected.package.name\"</span></code></pre></div>\n<h3>Relative importing</h3>\n<p>If the module is not renamed as <code class=\"language-text\">__main__</code>, we could use the relative importing to refer the packages according to the relative path.</p>\n<h3>Symbol table</h3>\n<blockquote>\n<p>Each module has its own private symbol table, which is used as the global symbol table by all functions defined in the module. Thus, the author of a module can use global variables in the module without worrying about accidental clashes with a user’s global variables.</p>\n</blockquote>\n<blockquote>\n<p>The imported module names are placed in the importing module’s global symbol table</p>\n</blockquote>\n<h3>.pyc</h3>\n<blockquote>\n<p>Python checks the modification date of the source against the compiled version to see if it’s out of date and needs to be recompiled. This is a completely automatic process. Also, the compiled modules are platform-independent, so the same library can be shared among systems with different architectures.</p>\n<p>Python does not check the cache in two circumstances. First, it always recompiles and does not store the result for the module that’s loaded directly from the command line. Second, it does not check the cache if there is no source module. To support a non-source (compiled only) distribution, the compiled module must be in the source directory, and there must not be a source module.</p>\n</blockquote>\n<h2>package</h2>\n<p>Also from the document, a package is:</p>\n<blockquote>\n<p>Packages are a way of structuring Python’s module namespace by using “dotted module names”. For example, the module name <code class=\"language-text\">A.B</code> designates a submodule named <code class=\"language-text\">B</code> in a package named <code class=\"language-text\">A</code>.</p>\n</blockquote>\n<p>It is possible and convenient that we could have the same module name in different package.</p>\n<blockquote>\n<p>You can think of packages as the directories on a file system and modules as files within directories, but don’t take this analogy too literally since packages and modules need not originate from the file system.</p>\n</blockquote>\n<p>In fact, package is a special kind of module:</p>\n<blockquote>\n<p>It’s important to keep in mind that all packages are modules, but not all modules are packages. Or put another way, packages are just a special kind of module. Specifically, any module that contains a <code class=\"language-text\">__path__</code> attribute is considered a package.</p>\n</blockquote>\n<p>There are two kinds of packages: regular packages and namespace packages, here we will only talk about the regular ones.</p>\n<h3>__init__.py</h3>\n<blockquote>\n<p>A regular package is typically implemented as a directory containing an <code class=\"language-text\">__init__.py</code> file. When a regular package is imported, this <code class=\"language-text\">__init__.py</code> file is implicitly executed, and the objects it defines are bound to names in the package’s namespace. The <code class=\"language-text\">__init__.py</code> file can contain the same Python code that any other module can contain, and Python will add some additional attributes to the module when it is imported.</p>\n</blockquote>\n<h3>__main__.py</h3>\n<p>Many may have heard of <code class=\"language-text\">__init__.py</code> but I believe few have heard of <code class=\"language-text\">__main__.py</code>. This file would be run as the entrance of a directory. </p>\n<blockquote>\n<p>For a package, the same effect can be achieved by including a <code class=\"language-text\">__main__.py</code> module, the contents of which will be executed when the module is run with <code class=\"language-text\">-m</code>.</p>\n</blockquote>\n<p>For example, if the file directory is (to show the directory, use <a href=\"https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/tree\">tree</a>)</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">hello\n    hello.py\n    __main__.py</code></pre></div>\n<p>With the code:</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># __main__.py</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"This is __main__\"</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># hello.py</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello world\"</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>And we run python on the </p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ python hello/\nThis is __main__</code></pre></div>\n<p>If we delete the <code class=\"language-text\">__main__.py</code> and run again, the result would be</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ python hello/\nXXX: can<span class=\"token string\">'t find '</span>__main__<span class=\"token string\">' module in '</span>hello'</code></pre></div>\n<h2>Import</h2>\n<blockquote>\n<p>Note that relative imports are based on the name of the current module. Since the name of the main module is always <code class=\"language-text\">&quot;__main__&quot;</code>, modules intended for use as the main module of a Python application must always use absolute imports.</p>\n</blockquote>\n<h2>Reference</h2>\n<ol>\n<li><a href=\"https://docs.python.org/3/tutorial/modules.html\">https://docs.python.org/3/tutorial/modules.html</a></li>\n<li><a href=\"https://docs.python.org/3/reference/import.html\">https://docs.python.org/3/reference/import.html</a></li>\n<li><a href=\"https://docs.python.org/3/library/%5C_%5C_main%5C_%5C_.html\">https://docs.python.org/3/library/\\_\\_main\\_\\_.html</a></li>\n</ol>","frontmatter":{"title":"About Python modularity","date":"2019-02-10T03:49:00.000Z","tags":["python"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/about-python-modularity/"}}}