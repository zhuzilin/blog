{"componentChunkName":"component---src-templates-blog-post-js","path":"/6.828-note2-x86-and-pc-architecture/","webpackCompilationHash":"17e2514cd1b5f04e33f0","result":{"data":{"markdownRemark":{"html":"<p>这里会记录阅读6.828课程lecture note的我的个人笔记。可能会中英混杂，不是很适合外人阅读，也请见谅。</p>\n<h2>Lecture 2: x86 and PC architecture</h2>\n<h3>PC architecture</h3>\n<p>一个完整的CPU有：</p>\n<ul>\n<li>x86 CPU与其寄存器，执行单元和内存管理部分</li>\n<li>CPU chip pins, include address and data signals</li>\n<li>内存</li>\n<li>硬盘</li>\n<li>键盘</li>\n<li>显示器</li>\n<li>其他资源：BIOS, ROM, clock, ...</li>\n</ul>\n<p>我们从零来一步一步得到一个CPU:</p>\n<ul>\n<li>可以把CPU就想成一个无穷循环</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\trun next instruction\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>为了更多空间，加入寄存器</li>\n</ul>\n<p>加入4个16位寄存器AX, BX, CX, DX，每个都可以分成两个8位的，如AH和AL。他们速度非常快。</p>\n<ul>\n<li>为了更多空间，加入内存</li>\n</ul>\n<p>内存，通过CPU sends out address on address lines (wires, one bit per wire)(这个是memory bus嘛？)，以读写数据。</p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\">movl  %eax, %edx   # edx = eax; register mode\nmovl $0x123 %edx   # edx = 0x123; immediate\nmovl 0x123, %edx   # edx = *(int32_t*)0x123; direct\nmovl (%ebx), %edx  # edx = *(int32_t*)ebx; indirect\nmovl 4(%ebx), %edx # edx = *(int32_t*)(ebx+4); displaced</code></pre></div>\n<p>上面几行具体的address mode的解释可以看<a href=\"https://www.tutorialspoint.com/assembly_programming/assembly_addressing_modes.htm\">这里</a>。大致区别是：</p>\n<ol>\n<li>register mode: 寄存器到寄存器</li>\n<li>immediate mode: 指令里头带的常数到寄存器</li>\n<li>后面几种都是计算到内存位置的</li>\n<li>address registers (栈与和栈类似的东西)</li>\n</ol>\n<p>为了满足如上需求，就需要有address registers，他们的作用是pointers into memory，有以下4个</p>\n<ol>\n<li>SP：stack pointer，指向当前的栈顶</li>\n<li>BP：frame base pointer，指向当前函数的帧顶</li>\n<li>SI：source index </li>\n<li>DI</li>\n<li>读取指令</li>\n</ol>\n<p>需要注意，instructions是存在内存中的，用EIP指向instruction，每执行一个就会增加EIP，而CALL, RET, JMP等汇编指令可以改变IP。</p>\n<ul>\n<li>FLAGS</li>\n</ul>\n<p>除了以上内容，我们还需要条件语句进行conditional jump，这就需要FLAGS，有各种各样的FLAGS。</p>\n<ul>\n<li>I/O</li>\n</ul>\n<p>有了以上功能的CPU仍然是一个没什么意思的程序，因为其没有IO。</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// write a byte to line printer</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> DATA_PORT    0x378</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> STATUS_PORT  0x379</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span>   BUSY 0x80</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> CONTROL_PORT 0x37A</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span>   STROBE 0x01</span>\n<span class=\"token keyword\">void</span>\n<span class=\"token function\">lpt_putc</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> c<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">/* wait for printer to consume previous byte */</span>\n  <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token function\">inb</span><span class=\"token punctuation\">(</span>STATUS_PORT<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;</span> BUSY<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">/* put the byte on the parallel lines */</span>\n  <span class=\"token function\">outb</span><span class=\"token punctuation\">(</span>DATA_PORT<span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">/* tell the printer to look at the data */</span>\n  <span class=\"token function\">outb</span><span class=\"token punctuation\">(</span>CONTROL_PORT<span class=\"token punctuation\">,</span> STROBE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">outb</span><span class=\"token punctuation\">(</span>CONTROL_PORT<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>上面的这段代码是传统的PC architecture: use dedicated I/O space. </p>\n<p>没太看懂，但是感觉这里的outb和inb和manul里的是不同的。。。</p>\n<p> 这种方式有如下的几个特点：</p>\n<ul>\n<li>和memory access类似，但是需要set I/O signal (代码里面的strobe是这个signal？)</li>\n<li>只有1024 I/O address，(1024是0x3ff，所以和上面PORT挺对应的)。</li>\n<li>需要特殊的指令（IN, OUT）</li>\n</ul>\n<p>而现在都是用Memory-Mapped I/O，大致就是把I/O装置当成物理内存之外扩充的一部分内存，从而把I/O就当成内存用。每个PORT耶直接映射到了内存地址上。</p>\n<p>其特点是：</p>\n<ul>\n<li>\n<p>Use normal physical memory addresses</p>\n<ul>\n<li>Gets around limited size of I/O address space</li>\n<li>No need for special instructions</li>\n<li>System controller routes to appropriate device</li>\n</ul>\n</li>\n<li>\n<p>Works like \"magic'' memory:</p>\n<ul>\n<li><em>Addressed</em> and <em>accessed</em> like memory, but ...</li>\n<li>... does not <em>behave</em> like memory!</li>\n<li>Reads and writes can have <code class=\"language-text\"></code>side effects''</li>\n<li>Read results can change due to external events</li>\n</ul>\n</li>\n<li>如何使用不止2^16bytes的内存</li>\n</ul>\n<p>虽然IP只有16位，但是加入了CS之后就可以有20位了。</p>\n<p>注意，这个20位的情况只出现在<a href=\"https://en.wikipedia.org/wiki/Protected_mode\">real mode</a>，也就是一个用于兼容之前的16位cpu用的。这个模式没有任何保护，只能访问1M内存，可以直接访问BIOS及周边内存，现在只有在boot的过程中才是用这种情况。而之后下面提到支持32位地址之后，在Boot完成之后，会转化为<a href=\"https://en.wikipedia.org/wiki/Protected_mode\">protected mode</a>，就直接只用一个32位的<code class=\"language-text\">eip</code>寄存器了。</p>\n<ul>\n<li>希望有超过16位的address</li>\n</ul>\n<p>80386首次支持32位地址。Boot的时候是16位，通过<code class=\"language-text\">boot.S</code>转换为32位。</p>\n<p>其寄存器也都是32位的，所以叫EAX而不是AX了。在32位模式下，通过前面加0x66前缀来toggle between 16-bit and 32-bit。而<code class=\"language-text\">boot.s</code>中的<code class=\"language-text\">.code32</code>正是做的这一点。如：</p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\">b8 cd ab\t\t16-bit CPU,  AX &lt;- 0xabcd\nb8 34 12 cd ab  32-bit CPU, EAX &lt;- 0xabcd1234\n66 b8 cd ab\t\t32-bit CPU,  AX &lt;- 0xabcd</code></pre></div>\n<h3>x86 Physical Memory Map</h3>\n<ul>\n<li>The physical address space mostly looks like ordinary RAM</li>\n<li>Except some low-memory addresses actually refer to other things</li>\n<li>Writes to VGA memory appear on the screen</li>\n<li>Reset or power-on jumps to ROM at 0xfffffff0 (so must be ROM at top...)</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">+------------------+  &lt;- 0xFFFFFFFF (4GB)\n|      32-bit      |\n|  memory mapped   |\n|     devices      |\n|                  |\n/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\\n\n/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\\n|                  |\n|      Unused      |\n|                  |\n+------------------+  &lt;- depends on amount of RAM\n|                  |\n|                  |\n| Extended Memory  |\n|                  |\n|                  |\n+------------------+  &lt;- 0x00100000 (1MB)\n|     BIOS ROM     |\n+------------------+  &lt;- 0x000F0000 (960KB)\n|  16-bit devices, |\n|  expansion ROMs  |\n+------------------+  &lt;- 0x000C0000 (768KB)\n|   VGA Display    |\n+------------------+  &lt;- 0x000A0000 (640KB)\n|                  |\n|    Low Memory    |\n|                  |\n+------------------+  &lt;- 0x00000000</code></pre></div>\n<p>这里的图在lab1中出现过，在lab1中有更详细的讲解。</p>\n<h3>x86 Instruction Set</h3>\n<p>对于本课使用的AT&#x26;T(gcc/gas) syntax: op src, dst。</p>\n<p>使用b, w, l来表示不同大小的操作。</p>\n<ul>\n<li>data movement: MOV, PUSH, POP, ...</li>\n<li>arithmetic: TEST, SHL, ADD, AND, ...</li>\n<li>i/o: IN, OUT, ...</li>\n<li>control: JMP, JZ, JNZ, CALL, RET</li>\n<li>string: REP MOVSB, ...</li>\n<li>system: IRET, INT</li>\n</ul>\n<h2>gcc x86 calling conventions</h2>\n<p>这里主要讲解了如何调用函数，也就是如何使用栈。</p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\">pushl %eax   &lt;=&gt; subl $4, %esp # esp -= 4\n\t\t\t     movl %eax, (%esp) # *(esp) = eax\npopl %eax    &lt;=&gt; movl (%esp), %eax # eax = *(esp)\n\t\t\t     addl $4, %esp # esp += 4\ncall 0x12345 &lt;=&gt; pushl %eip(*) # 存起来call指令的地址\n\t\t\t\t movl $0x12345, %eip(*) # 下一个指令执行函数\nret \t\t &lt;=&gt; popl %eip(*) # 回到call指令\n# (*) mean it is not real instruction</code></pre></div>\n<p>GCC dictates 该如何使用栈. 在x86上，caller和callee之间的协议(Contract)如下:</p>\n<ul>\n<li>\n<p>在函数的入口处 (i.e. just after call):</p>\n<ul>\n<li>%eip 指向函数的首个指令的地址</li>\n<li>%esp+4 指首个参数（其实就是首个参数被push了）</li>\n<li>%esp 指向返回地址（return address）</li>\n</ul>\n</li>\n<li>\n<p>运行ret指令之后（函数返回之后）:</p>\n<ul>\n<li>%eip 包含%esp的值，也就是返回地址</li>\n<li>%esp 因为重新被addl 4, 所以指向首个参数</li>\n<li>函数可能有trashed argument（没懂什么意思）</li>\n<li>%eax (and %edx, if return type is 64-bit) 存有返回值 (or trash if function is <code class=\"language-text\">void</code>)</li>\n<li>%eax, %edx (above), and %ecx may be trashed</li>\n<li>%ebp, %ebx, %esi, %edi must contain contents from time of <code class=\"language-text\">call</code>（比如ebx是输入参数，ebp是caller的frame address）</li>\n</ul>\n</li>\n<li>\n<p>Terminology:</p>\n<ul>\n<li>%eax, %ecx, %edx are \"caller save\" registers</li>\n<li>%ebp, %ebx, %esi, %edi are \"callee save\" registers</li>\n</ul>\n</li>\n</ul>\n<p>这里原note中写的非常清楚，应仔细阅读。</p>\n<p>只要不违反上述contract，Function什么都可以做，根据习惯，GCC会：</p>\n<ul>\n<li>\n<p>each function has a stack frame marked by %ebp, %esp</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">     +------------+   |\n     | arg 2      |   \\\n     +------------+    &gt;- previous function&#39;s stack frame\n     | arg 1      |   /\n     +------------+   |\n     | ret %eip   |   /\n     +============+   \n     | saved %ebp |   \\\n%ebp-&gt; +------------+   |\n     |            |   |\n     |   local    |   \\\n     | variables, |    &gt;- current function&#39;s stack frame\n     |    etc.    |   /\n     |            |   |\n     |            |   |\n%esp-&gt; +------------+   /</code></pre></div>\n</li>\n<li>可以通过移动%esp来增大减小（应该就是通过push和pop，那到底有没有一个frame大小作为限制呢？）</li>\n<li>%ebp指向之前函数的%ebp，从而形成链（可以看后面两部分的代码）</li>\n<li>\n<p>function prologue:</p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\">pushl %ebp  # 把当前的frame address存在esp对应的地址里\nmovl %esp, %ebp\t # 把现在的esp的值存在ebp里，\n\t\t\t\t # 可以理解为*(ebp) = ebp_old\n\t\t\t\t # 从而组成了一个frame address的链</code></pre></div>\n<p>or</p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\">enter $0, $0</code></pre></div>\n<p>enter usually not used: 4 bytes vs 3 for pushl+movl, not on hardware fast-path anymore</p>\n</li>\n<li>\n<p>function epilogue can easily find return EIP on stack:</p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\">movl %ebp, %esp # esp = ebp，注意这时*(ebp) = ebp_old\npopl %ebp # 把*(ebp)也就是ebp_old重新赋给ebp, ebp = *(ebp)\n\t\t  # 同时esp也恢复到调用这个函数之前的值</code></pre></div>\n<p>or</p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\">leave\t</code></pre></div>\n<p>leave used often because it's 1 byte, vs 3 for movl+popl</p>\n</li>\n</ul>\n<p>这里有一个简单的调用的例子：</p>\n<ul>\n<li>\n<p>C code</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token number\">8</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> <span class=\"token function\">g</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">g</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> x<span class=\"token operator\">+</span><span class=\"token number\">3</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\t\t</code></pre></div>\n</li>\n<li>\n<p>assembler</p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\">_main:\n\t\t\t\tprologue\n\tpushl %ebp\n\tmovl %esp, %ebp\n\t\t\t\tbody\n\tpushl $8 # 在调用前，把8，也就是参数推进栈\n  call _f # 调用\n  addl $1, %eax # 返回值存在eax中\n  \t\t\tepilogue\n\tmovl %ebp, %esp\n\tpopl %ebp\n\tret\n_f:\n\t\t\t\tprologue\n\tpushl %ebp # ebp为main的frame address\n\tmovl %esp, %ebp # ebp为f的frame address，指向main的\n\t\t\t\tbody\n\tpushl 8(%esp) # 这里的8(%esp)是x的地址对应的值，是调用函数前放进去的\n\t\t\t\t  # 把传入的x再次放入栈中\n\tcall _g\n\t\t\t\tepilogue\n\tmovl %ebp, %esp\n\tpopl %ebp\n\tret\n\n_g:\n\t\t\t\tprologue\n\tpushl %ebp\n\tmovl %esp, %ebp\n\t\t\t\tsave %ebx\n\tpushl %ebx # 这里不懂。。。\n\t\t\t\tbody\n\tmovl 8(%ebp), %ebx # 取出传入的x\n\taddl $3, %ebx\n\tmovl %ebx, %eax # 把计算结果存给eax\n\t\t\t\trestore %ebx\n\tpopl %ebx\n\t\t\t\tepilogue\n\tmovl %ebp, %esp\n\tpopl %ebp\n\tret</code></pre></div>\n<p>注意，如果使用<code class=\"language-text\">objdump -d</code>进行反汇编，会有出入。</p>\n</li>\n<li>\n<p>Super-small _g:</p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\">_g:\n\tmovl 4(%esp), %eax\n\taddl $3, %eax\n\tret</code></pre></div>\n</li>\n</ul>\n<p>编译</p>\n<p>编译语言的方式可以见我之前的帖子How is python run.</p>\n<h3>PC emulation</h3>\n<p>The Bochs emulator(和qemu是不同的软件，不过差不多) works by</p>\n<ul>\n<li>和PC做完全一样的事</li>\n<li>全部只用软件实现</li>\n</ul>\n<p>而实际上只是host的一个普通进程。</p>\n<p>用进程的存储来模拟硬件状态，如：</p>\n<ul>\n<li>\n<p>把寄存器存为全局变量</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">int32_t regs<span class=\"token punctuation\">[</span><span class=\"token number\">8</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> REG_EAX 1;</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> REG_EBX 2;</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> REG_ECX 3;</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\nint32_t eip<span class=\"token punctuation\">;</span>\nint16_t segregs<span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></code></pre></div>\n</li>\n<li>\n<p>用一个数组模拟物理内存。</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">char</span> mem<span class=\"token punctuation\">[</span><span class=\"token number\">256</span><span class=\"token operator\">*</span><span class=\"token number\">1024</span><span class=\"token operator\">*</span><span class=\"token number\">1024</span><span class=\"token punctuation\">]</span>         </code></pre></div>\n</li>\n</ul>\n<p>通过死循环来执行指令（可以和上面的CPU最开始对比）</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token function\">read_instruction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span><span class=\"token function\">decode_instruction_opcode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">case</span> OPCODE_ADD<span class=\"token operator\">:</span>\n\t\t\t<span class=\"token keyword\">int</span> src <span class=\"token operator\">=</span> <span class=\"token function\">decode_src_reg</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token keyword\">int</span> dst <span class=\"token operator\">=</span> <span class=\"token function\">decode_dst_reg</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\tregs<span class=\"token punctuation\">[</span>dst<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> regs<span class=\"token punctuation\">[</span>dst<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> regs<span class=\"token punctuation\">[</span>src<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">case</span> OPCODE_SUB<span class=\"token operator\">:</span>\n\t\t\t<span class=\"token keyword\">int</span> src <span class=\"token operator\">=</span> <span class=\"token function\">decode_src_reg</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token keyword\">int</span> dst <span class=\"token operator\">=</span> <span class=\"token function\">decode_dst_reg</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\tregs<span class=\"token punctuation\">[</span>dst<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> regs<span class=\"token punctuation\">[</span>dst<span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span> regs<span class=\"token punctuation\">[</span>src<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token punctuation\">}</span>\n\teip <span class=\"token operator\">+=</span> instruction_length<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>内存的布局和实际上的物理内存一样（分成lower, BIOS, extension...）</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> KB\t\t1024</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> MB\t\t1024*1024</span>\n\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> LOW_MEMORY\t640*KB</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> EXT_MEMORY\t10*MB</span>\n\nuint8_t low_mem<span class=\"token punctuation\">[</span>LOW_MEMORY<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nuint8_t ext_mem<span class=\"token punctuation\">[</span>EXT_MEMORY<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nuint8_t bios_rom<span class=\"token punctuation\">[</span><span class=\"token number\">64</span><span class=\"token operator\">*</span>KB<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\nuint8_t <span class=\"token function\">read_byte</span><span class=\"token punctuation\">(</span>uint32_t phys_addr<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>phys_addr <span class=\"token operator\">&lt;</span> LOW_MEMORY<span class=\"token punctuation\">)</span>\n\t\t<span class=\"token keyword\">return</span> low_mem<span class=\"token punctuation\">[</span>phys_addr<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>phys_addr <span class=\"token operator\">>=</span> <span class=\"token number\">960</span><span class=\"token operator\">*</span>KB <span class=\"token operator\">&amp;&amp;</span> phys_addr <span class=\"token operator\">&lt;</span> <span class=\"token number\">1</span><span class=\"token operator\">*</span>MB<span class=\"token punctuation\">)</span>\n\t\t<span class=\"token keyword\">return</span> rom_bios<span class=\"token punctuation\">[</span>phys_addr <span class=\"token operator\">-</span> <span class=\"token number\">960</span><span class=\"token operator\">*</span>KB<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>phys_addr <span class=\"token operator\">>=</span> <span class=\"token number\">1</span><span class=\"token operator\">*</span>MB <span class=\"token operator\">&amp;&amp;</span> phys_addr <span class=\"token operator\">&lt;</span> <span class=\"token number\">1</span><span class=\"token operator\">*</span>MB<span class=\"token operator\">+</span>EXT_MEMORY<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">return</span> ext_mem<span class=\"token punctuation\">[</span>phys_addr<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token operator\">*</span>MB<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">else</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">write_byte</span><span class=\"token punctuation\">(</span>uint32_t phys_addr<span class=\"token punctuation\">,</span> uint8_t val<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>phys_addr <span class=\"token operator\">&lt;</span> LOW_MEMORY<span class=\"token punctuation\">)</span>\n\t\tlow_mem<span class=\"token punctuation\">[</span>phys_addr<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> val<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>phys_addr <span class=\"token operator\">>=</span> <span class=\"token number\">960</span><span class=\"token operator\">*</span>KB <span class=\"token operator\">&amp;&amp;</span> phys_addr <span class=\"token operator\">&lt;</span> <span class=\"token number\">1</span><span class=\"token operator\">*</span>MB<span class=\"token punctuation\">)</span>\n\t\t<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* ignore attempted write to ROM! */</span>\n\t<span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>phys_addr <span class=\"token operator\">>=</span> <span class=\"token number\">1</span><span class=\"token operator\">*</span>MB <span class=\"token operator\">&amp;&amp;</span> phys_addr <span class=\"token operator\">&lt;</span> <span class=\"token number\">1</span><span class=\"token operator\">*</span>MB<span class=\"token operator\">+</span>EXT_MEMORY<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\text_mem<span class=\"token punctuation\">[</span>phys_addr<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token operator\">*</span>MB<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> val<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">else</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span>\n\t</code></pre></div>\n<p>通过检查对“特殊”内存及I/O space的访问并按照真是情况进行模拟来模拟I/O等，如,</p>\n<ul>\n<li>把对模拟的硬盘的读写转化成对host机上的文件的读写。</li>\n<li>对模拟VGA硬件的写入转化为drawing into an X window</li>\n<li>模拟的键盘读入转化为reads from X input event queue</li>\n</ul>","frontmatter":{"title":"6.828 笔记2 x86 and PC architecture","date":"2019-02-13T11:51:00.000Z","tags":["OS","6.828"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/6.828-note2-x86-and-pc-architecture/"}}}