{"componentChunkName":"component---src-templates-blog-post-js","path":"/docker-basics/","result":{"data":{"markdownRemark":{"html":"<p>本文假设读者已经正确安装了docker。同时，下述指令运行的平台为RHEL 7（因为领英只给我配了这么台东西....）。以及基本指令来自于《第一本docker书——修订版》。</p>\n<h2>docker常用指令</h2>\n<p>检查是否正常工作。</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">sudo</span> <span class=\"token function\">docker</span> info</code></pre></div>\n<p>查询系统的container列表：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">sudo</span> <span class=\"token function\">docker</span> <span class=\"token function\">ps</span> <span class=\"token parameter variable\">-a</span></code></pre></div>\n<p>查看所有容器的运行状态：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">sudo</span> <span class=\"token function\">docker</span> stats</code></pre></div>\n<p>这个指令可以后面跟一个或多个container名字来检测这些。</p>\n<h2>container相关</h2>\n<p>运行容器：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">sudo</span> <span class=\"token function\">docker</span> run <span class=\"token parameter variable\">--name</span> terminal <span class=\"token parameter variable\">-i</span> <span class=\"token parameter variable\">-t</span> ubuntu /bin/bash\r\n$ /<span class=\"token comment\">#</span></code></pre></div>\n<p><code class=\"language-text\">--name</code>给container命名</p>\n<p><code class=\"language-text\">-i</code>保证容器中STDIN是开启的（不懂是什么意思）</p>\n<p><code class=\"language-text\">-t</code>为容器分配一个伪tty终端（不懂什么意思）</p>\n<p>在推出了上面运行开启的ubuntu里的bash之后，在bash中运行<code class=\"language-text\">exit</code>会推出这个bash，同时退出这个container。</p>\n<p>重新启动：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">docker</span> start terminal</code></pre></div>\n<p>重新启动会按照最开始<code class=\"language-text\">docker run</code>的参数来运行，所以也会重新启动出一个交互式shell。如果需要连接这个shell，可以使用：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">docker</span> attach terminal</code></pre></div>\n<p>来重新附着到容器的会话。</p>\n<p>如果要使用守护进程（daemon），也就是没有交互，在后台运行的进程，那么要加入<code class=\"language-text\">-d</code>标记</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">docker</span> run <span class=\"token parameter variable\">--name</span> daemon_hw <span class=\"token parameter variable\">-d</span> ubuntu /bin/sh <span class=\"token parameter variable\">-c</span>  <span class=\"token string\">\"while true; do echo hello world; sleep 1; done\"</span></code></pre></div>\n<p>检查容器的log，可以：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">docker</span> logs daemon_hw</code></pre></div>\n<p><code class=\"language-text\">logs</code>还有一些如<code class=\"language-text\">-f</code>之类的flag。</p>\n<p>查看容器内部进程可以用：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">docker</span> <span class=\"token function\">top</span> daemon_hw</code></pre></div>\n<p>停止容器可以：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">docker</span> stop daemon_hw</code></pre></div>\n<p>自动重启容器：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">docker</span> run <span class=\"token parameter variable\">--restart</span><span class=\"token operator\">=</span>always <span class=\"token parameter variable\">--name</span> daemon_always <span class=\"token parameter variable\">-d</span> ubuntu /bin/sh <span class=\"token parameter variable\">-c</span>  <span class=\"token string\">\"while true; do echo hello world; sleep 1; done\"</span></code></pre></div>\n<p>这样的话不管出了什么问题，都会重启。attach之后ctrl+c或者<code class=\"language-text\">docker stop</code>就不会restart了。</p>\n<p>或者可以设置<code class=\"language-text\">--restart=on-failure:5</code>，最多重启5次。</p>\n<p>在restarting状态下的container可以直接被删除。</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">docker</span> container <span class=\"token function\">rm</span> daemon_always</code></pre></div>\n<h2>image相关</h2>\n<p>在书的第四章最开头有对image和container的结构的简介。</p>\n<p>本地的所有image和container都在<code class=\"language-text\">/var/lib/docker</code>之下。</p>\n<p>列出所有镜像：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">docker</span> image</code></pre></div>\n<p>从registry获取image</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">docker</span> pull ubuntu:12.04</code></pre></div>\n<p>用<code class=\"language-text\">docker search</code>来检索镜像</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">docker</span> search puppet</code></pre></div>\n<h3>构建image</h3>\n<p>可以先在container里面安装如说<code class=\"language-text\">sudo apt-get -y install apache2</code>。然后退出container，再</p>\n<p><code class=\"language-text\">sudo docker commit [container-id] [publish-name] </code></p>\n<p>不过更常见的是用<code class=\"language-text\">Dockerfile</code></p>\n<p>首先在希望publish的文件夹中创建一个`Dockerfile，下面是一个Dockerfile的例子</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token comment\"># Version: 0.0.1</span>\r\n<span class=\"token instruction\"><span class=\"token keyword\">FROM</span> ubuntu:14.04</span>\r\n<span class=\"token instruction\"><span class=\"token keyword\">MAINTAINER</span> zhuzilin <span class=\"token string\">\"zhuzilinallen@gmail.com\"</span></span>\r\n<span class=\"token instruction\"><span class=\"token keyword\">RUN</span> apt-get update &amp;&amp; apt-get install -y nginx</span>\r\n<span class=\"token instruction\"><span class=\"token keyword\">RUN</span> echo <span class=\"token string\">'Hi, I am in your container'</span> <span class=\"token operator\">\\</span>\r\n    >/user/share/nginx/html/index.html</span>\r\n<span class=\"token instruction\"><span class=\"token keyword\">EXPOSE</span> 80</span></code></pre></div>\n<p>docker会先</p>\n<ul>\n<li>从基础镜像(ubuntu)运行一个容器</li>\n<li>执行一条指令，对容器做出修改</li>\n<li>执行类似<code class=\"language-text\">docker commit</code>的指令，提交一个新的镜像层</li>\n<li>基于新的镜像运行一个新容器</li>\n<li>执行下一条指令</li>\n<li>...</li>\n</ul>\n<p>所以即使build失败了，也会生成某个镜像，可以对这个镜像进行debug来查找错误。</p>\n<p>默认会在<code class=\"language-text\">/bin/sh -c</code>来执行<code class=\"language-text\">RUN</code>的参数，如果平台不支持shell或者不希望用shell运行，可以使用<code class=\"language-text\">exec</code>格式，如</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token instruction\"><span class=\"token keyword\">RUN</span> [<span class=\"token string\">\"apt-get\"</span>, <span class=\"token string\">\"install\"</span>, <span class=\"token string\">\"-y\"</span>, <span class=\"token string\">\"nginx\"</span>]</span></code></pre></div>\n<p><code class=\"language-text\">EXPOSE</code>会指令端口。但是出于安全按原因，docker并不会在运行镜像的时候自动打开这个端口，而是需要在<code class=\"language-text\">docker run</code>中设置。</p>\n<p>之后就可以build这个镜像了</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">docker</span> build <span class=\"token builtin class-name\">.</span></code></pre></div>\n<p>docker会把中间过程中生成的image作为缓存，以便下一次build使用，如果要去掉缓存，可以加上<code class=\"language-text\">--no-cache</code>标记。</p>\n<p>如果别的Dockerfile的顶部指令相似，就会使用缓存。</p>\n<p>之后运行这个image</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-d</span> <span class=\"token parameter variable\">-p</span> <span class=\"token number\">80</span> <span class=\"token parameter variable\">--name</span> nginx <span class=\"token punctuation\">[</span>image-id<span class=\"token punctuation\">]</span> nginx <span class=\"token parameter variable\">-g</span> <span class=\"token string\">\"daemon off;\"</span></code></pre></div>\n<p>这里的<code class=\"language-text\">-p</code>也设置了80，然后可以通过<code class=\"language-text\">sudo docker ps -l</code>或者<code class=\"language-text\">sudo port nginx</code>来查看端口对应。</p>\n<p>或者可以在运行的时候设置对应</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-d</span> <span class=\"token parameter variable\">-p</span> <span class=\"token number\">8080</span>:80 <span class=\"token parameter variable\">--name</span> nginx <span class=\"token punctuation\">[</span>image-id<span class=\"token punctuation\">]</span> nginx <span class=\"token parameter variable\">-g</span> <span class=\"token string\">\"daemon off;\"</span></code></pre></div>\n<p>这样就把容器的80端口绑定在了宿主机的8080端口上。这时访问<code class=\"language-text\">localhost:8080</code>就可以显示出<code class=\"language-text\">Hi, I am in your container</code>了。</p>\n<p>在<code class=\"language-text\">run</code>指令中还有一个非常使用的<code class=\"language-text\">-P</code>指令，用于把所有的容器内公开的指令绑定到某一个随机端口上。或者可以指定端口。</p>\n<p>另一个非常重要的选项是<code class=\"language-text\">--net</code>。当多个容器需要进行网络上的交互的时候，一般需要先</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">docker</span> network create xxx</code></pre></div>\n<p>这样之后在每个运行的container的run指令里面都加上<code class=\"language-text\">--net xxx</code>就可以相互访问了。不过访问的时候需要用<code class=\"language-text\">hostname:port</code>，而容器默认的hostname是容器ID相关的，挺复杂的，所以一般还要用<code class=\"language-text\">-h</code>来设置一下域名。注意这么链接的时候使用的是dockerfile里面的port，而不是<code class=\"language-text\">-p</code>开放的端口。</p>\n<h3>Dockerfile的其余指令</h3>\n<ul>\n<li>\n<p>CMD</p>\n<p>容器被启动时运行的指令。例如：</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token instruction\"><span class=\"token keyword\">CMD</span> [<span class=\"token string\">\"/bin/bash\"</span>, <span class=\"token string\">\"-l\"</span>]</span></code></pre></div>\n</li>\n<li>\n<p>ENTRYPOINT</p>\n<p><code class=\"language-text\">docker run</code>命令行中指定的任何参数都会被当做参数再次传递给ENTRYPOINT指令中指定的命令。如：</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token instruction\"><span class=\"token keyword\">ENTRYPOINT</span> [<span class=\"token string\">\"/usr/sbin/nginx\"</span>]</span></code></pre></div>\n<p>甚至可以像<code class=\"language-text\">CMD</code>一样加入参数</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token instruction\"><span class=\"token keyword\">ENTRYPOINT</span> [<span class=\"token string\">\"/usr/sbin/nginx\"</span>, <span class=\"token string\">\"-g\"</span>, <span class=\"token string\">\"daemn off;\"</span>]</span></code></pre></div>\n<p>注意CMD和ENTRYPOINT的最大区别是，CMD是会被<code class=\"language-text\">docker run</code>里面的参数覆盖的，而ENTRYPOINT只会把参数附在其后面。所以也可以同时有ENTRYPOINT和CMD</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">ENTRYPOINT <span class=\"token punctuation\">[</span><span class=\"token string\">\"/usr/sbin/nginx\"</span><span class=\"token punctuation\">]</span>\r\nCMD <span class=\"token punctuation\">[</span><span class=\"token string\">\"-h\"</span><span class=\"token punctuation\">]</span></code></pre></div>\n</li>\n<li>\n<p>WORKDIR</p>\n<p>用来在从镜像创建新容器的时候，在容器内部设置一个工作牡蛎，<code class=\"language-text\">ENTRYPOINT</code>和<code class=\"language-text\">/</code>或<code class=\"language-text\">CMD</code>指定的程序会在这个目录下执行。如：</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token instruction\"><span class=\"token keyword\">WORKDIR</span> /opt/webapp/db</span>\r\n<span class=\"token instruction\"><span class=\"token keyword\">RUN</span> bundle install</span>\r\n<span class=\"token instruction\"><span class=\"token keyword\">WORKDIR</span> /opt/webapp</span>\r\n<span class=\"token instruction\"><span class=\"token keyword\">ENTRYPOINT</span> [<span class=\"token string\">\"rackup\"</span>]</span></code></pre></div>\n<p>就是先把工作目录设为<code class=\"language-text\">/opt/webapp/db</code>，运行<code class=\"language-text\">bundle install</code>，再把工作目录设为<code class=\"language-text\">/opt/webapp</code>，运行ENTRYPOINT。</p>\n<p>注意在运行的时候可以用<code class=\"language-text\">docker run</code>的<code class=\"language-text\">-w</code>标记来覆盖工作目录。</p>\n</li>\n<li>\n<p>ENV</p>\n<p>设置环境变量，设置后后续任何RUN都可以用。</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token instruction\"><span class=\"token keyword\">ENV</span> RVM_PATH /home/rvm</span></code></pre></div>\n<p>之后运行<code class=\"language-text\">RUN gem install unicorn</code>就会实际运行<code class=\"language-text\">RVM_PATH=/home/rvm gem install unicorn</code>。</p>\n<p>也可以设置多变量：</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token instruction\"><span class=\"token keyword\">ENV</span> RVM_PATH /home/rvm RVM_ARCHFLAG=<span class=\"token string\">\"-arch i386\"</span></span></code></pre></div>\n<p>在别的dockerfile指令中也可以直接使用</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token instruction\"><span class=\"token keyword\">ENV</span> TARGET_DIR /opt/app</span>\r\n<span class=\"token instruction\"><span class=\"token keyword\">WORKDIR</span> <span class=\"token variable\">$TARGET_DIR</span></span></code></pre></div>\n<p>在container中运行<code class=\"language-text\">env</code>可以看到我们设置的环境变量。</p>\n<p>也可以用<code class=\"language-text\">docker run</code>的<code class=\"language-text\">-e</code>传递环境变量。</p>\n</li>\n<li>\n<p>USER</p>\n<p>指定该镜像会以什么样的用户去运行。（不太明白）</p>\n</li>\n<li>\n<p>VOLUME</p>\n<p>像基于镜像创建的容器添加卷。一个卷是可以存在与一个或多个容器内的特定目录。用于多个容器共享资源。</p>\n</li>\n<li>\n<p>ADD</p>\n<p>将构建环境下的文件和目录复制到镜像中。如：</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token instruction\"><span class=\"token keyword\">ADD</span> software.lic /opt/application/software.lic</span></code></pre></div>\n<p>就是把本地的<code class=\"language-text\">software.lic</code>复制到镜像中的<code class=\"language-text\">/opt/application/software.lic</code>。</p>\n<p>ADD也可以加入URL格式的文件。如<code class=\"language-text\">http://wordpress.org/latest.zip</code>。</p>\n<p>注意如果加入<code class=\"language-text\">gzip, bzip2, xz</code>等文件时，会自动解压。</p>\n</li>\n<li>\n<p>COPY</p>\n<p>类似ADD，不过只赋值，不会文件提取与解压。如：</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token instruction\"><span class=\"token keyword\">COPY</span> conf.d/ /etc/apache2/</span></code></pre></div>\n</li>\n<li>\n<p>LABEL</p>\n<p>给镜像添加元数据，如：</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token instruction\"><span class=\"token keyword\">LABEL</span> version=<span class=\"token string\">\"1.0\"</span></span>\r\n<span class=\"token instruction\"><span class=\"token keyword\">LABEL</span> location=<span class=\"token string\">\"New York\"</span> type=<span class=\"token string\">\"Data Center\"</span> role=<span class=\"token string\">\"Web Server\"</span></span></code></pre></div>\n<p>使用<code class=\"language-text\">docker inspect</code>的时候可以看到label对应的json。</p>\n</li>\n<li>\n<p>STOPSIGNAL</p>\n<p>估计用不上...</p>\n</li>\n<li>\n<p>ARG</p>\n<p><code class=\"language-text\">docker build</code>的时候可以传入的参数。可以用<code class=\"language-text\">docker build</code>中的<code class=\"language-text\">--build-arg</code>指定。注意不要穿证书或密钥。</p>\n</li>\n<li>\n<p>ONBUILD</p>\n<p>给镜像加trigger的，等见过再说吧。</p>\n</li>\n</ul>\n<p>删除镜像，可以用<code class=\"language-text\">docker rmi</code>或者<code class=\"language-text\">docker image rm</code>。</p>\n<h3>用例</h3>\n<p>真正使用docker还是要靠动手。我创了一个叫<a href=\"https://github.com/zhuzilin/play-with-docker\">play-with-docker</a>的repo来放自己写的例子。有兴趣的朋友也可以来看看。</p>","frontmatter":{"title":"docker basics","date":"2019-07-10T11:54:00.000Z","tags":["docker","container"]}}},"pageContext":{"slug":"/docker-basics/"}},"staticQueryHashes":["3159585216"],"slicesMap":{}}