{"componentChunkName":"component---src-templates-blog-post-js","path":"/6.828-lab2/","webpackCompilationHash":"17d90122362c59fb634f","result":{"data":{"markdownRemark":{"html":"<h2>Part 1: Physical Page Management</h2>\n<p>写一个physical page allocator。注意分配出来的<code class=\"language-text\">pages</code>就是表示了整个物理内存，但是记录的是每个page对应的虚拟地址。用物理地址来找到对应的page，然后用这个page的虚拟地址来得到其实际存的东西。</p>\n<p>这里的内存初始化就是为了让物理内存有这样的结构：</p>\n<p><img src=\"http://lzz5235.github.io/assets/pic/235.png\" alt=\"virtual address\"></p>\n<h3>Exercise 1</h3>\n<p>需要修改如下几个函数：</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token function\">boot_alloc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">mem_init</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>only up to the call to <span class=\"token function\">check_page_free_list</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">page_init</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">page_alloc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">page_free</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>首先是<code class=\"language-text\">boot_alloc()</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// This simple physical memory allocator is used only while JOS is setting</span>\n<span class=\"token comment\">// up its virtual memory system.  page_alloc() is the real allocator.</span>\n<span class=\"token comment\">//</span>\n<span class=\"token comment\">// If n>0, allocates enough pages of contiguous physical memory to hold 'n'</span>\n<span class=\"token comment\">// bytes.  Doesn't initialize the memory.  Returns a kernel virtual address.</span>\n<span class=\"token comment\">//</span>\n<span class=\"token comment\">// If n==0, returns the address of the next free page without allocating</span>\n<span class=\"token comment\">// anything.</span>\n<span class=\"token comment\">//</span>\n<span class=\"token comment\">// If we're out of memory, boot_alloc should panic.</span>\n<span class=\"token comment\">// This function may ONLY be used during initialization,</span>\n<span class=\"token comment\">// before the page_free_list list has been set up.</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>\n<span class=\"token function\">boot_alloc</span><span class=\"token punctuation\">(</span>uint32_t n<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">static</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>nextfree<span class=\"token punctuation\">;</span>\t<span class=\"token comment\">// virtual address of next byte of free memory</span>\n\t<span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>result<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token comment\">// Initialize nextfree if this is the first time.</span>\n\t<span class=\"token comment\">// 'end' is a magic symbol automatically generated by the linker,</span>\n\t<span class=\"token comment\">// which points to the end of the kernel's bss segment:</span>\n\t<span class=\"token comment\">// the first virtual address that the linker did *not* assign</span>\n\t<span class=\"token comment\">// to any kernel code or global variables.</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>nextfree<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">extern</span> <span class=\"token keyword\">char</span> end<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t\tnextfree <span class=\"token operator\">=</span> <span class=\"token function\">ROUNDUP</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> end<span class=\"token punctuation\">,</span> PGSIZE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\n\t<span class=\"token comment\">// Allocate a chunk large enough to hold 'n' bytes, then update</span>\n\t<span class=\"token comment\">// nextfree.  Make sure nextfree is kept aligned</span>\n\t<span class=\"token comment\">// to a multiple of PGSIZE.</span>\n\t<span class=\"token comment\">//</span>\n\t<span class=\"token comment\">// LAB 2: Your code here.</span>\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> nextfree<span class=\"token punctuation\">;</span>\n  result <span class=\"token operator\">=</span> nextfree<span class=\"token punctuation\">;</span>\n  nextfree <span class=\"token operator\">+=</span> <span class=\"token function\">ROUNDUP</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">,</span> PGSIZE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>从注释里面可以看出，这里是分配物理内存，分配的就是连续的内存，所以直接加就好了。注意这个函数返回的是VA，所以如果需要使用物理内存，就要用<code class=\"language-text\">PADDR()</code>这个宏。</p>\n<p>之后是<code class=\"language-text\">mem_init()</code>，注意这个函数只设置好kernel部分的内存。<code class=\"language-text\">mem_init</code>先分配了kernel的page directory。</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">//////////////////////////////////////////////////////////////////////</span>\n<span class=\"token comment\">// Allocate an array of npages 'struct PageInfo's and store it in 'pages'.</span>\n<span class=\"token comment\">// The kernel uses this array to keep track of physical pages: for</span>\n<span class=\"token comment\">// each physical page, there is a corresponding struct PageInfo in this</span>\n<span class=\"token comment\">// array.  'npages' is the number of physical pages in memory.  Use memset</span>\n<span class=\"token comment\">// to initialize all fields of each struct PageInfo to 0.</span>\n<span class=\"token comment\">// Your code goes here:</span>\n  pages <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">PageInfo</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token function\">boot_alloc</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">PageInfo</span><span class=\"token punctuation\">)</span><span class=\"token operator\">*</span>npages<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">memset</span><span class=\"token punctuation\">(</span>pages<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">PageInfo</span><span class=\"token punctuation\">)</span><span class=\"token operator\">*</span>npages<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>在这之后，我们需要操作的就是<code class=\"language-text\">PageInfo</code>这个<code class=\"language-text\">struct</code>了</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">/*\n * Page descriptor structures, mapped at UPAGES.\n * Read/write to the kernel, read-only to user programs.\n *\n * Each struct PageInfo stores metadata for one physical page.\n * Is it NOT the physical page itself, but there is a one-to-one\n * correspondence between physical pages and struct PageInfo's.\n * You can map a struct PageInfo * to the corresponding physical address\n * with page2pa() in kern/pmap.h.\n */</span>\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">PageInfo</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token comment\">// Next page on the free list.</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">PageInfo</span> <span class=\"token operator\">*</span>pp_link<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token comment\">// pp_ref is the count of pointers (usually in page table entries)</span>\n\t<span class=\"token comment\">// to this page, for pages allocated using page_alloc.</span>\n\t<span class=\"token comment\">// Pages allocated at boot time using pmap.c's</span>\n\t<span class=\"token comment\">// boot_alloc do not have valid reference count fields.</span>\n\n\tuint16_t pp_ref<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这个结构记录了一个page的meta data，其中保存了下一个free page的地址与这个page被ref的次数。而实际page的物理内存，用其和<code class=\"language-text\">pages</code>这个变量的地址的距离来衡量，之后用到的<code class=\"language-text\">page2kva</code>会看到。</p>\n<p>然后我们来修改<code class=\"language-text\">page_init</code></p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">//</span>\n<span class=\"token comment\">// Initialize page structure and memory free list.</span>\n<span class=\"token comment\">// After this is done, NEVER use boot_alloc again.  ONLY use the page</span>\n<span class=\"token comment\">// allocator functions below to allocate and deallocate physical</span>\n<span class=\"token comment\">// memory via the page_free_list.</span>\n<span class=\"token comment\">//</span>\n<span class=\"token keyword\">void</span>\n<span class=\"token function\">page_init</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\t<span class=\"token comment\">// The example code here marks all physical pages as free.</span>\n\t<span class=\"token comment\">// However this is not truly the case.  What memory is free?</span>\n\t<span class=\"token comment\">//  1) Mark physical page 0 as in use.</span>\n\t<span class=\"token comment\">//     This way we preserve the real-mode IDT and BIOS structures</span>\n\t<span class=\"token comment\">//     in case we ever need them.  (Currently we don't, but...)</span>\n\t<span class=\"token comment\">//  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)</span>\n\t<span class=\"token comment\">//     is free.</span>\n\t<span class=\"token comment\">//  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must</span>\n\t<span class=\"token comment\">//     never be allocated.</span>\n\t<span class=\"token comment\">//  4) Then extended memory [EXTPHYSMEM, ...).</span>\n\t<span class=\"token comment\">//     Some of it is in use, some is free. Where is the kernel</span>\n\t<span class=\"token comment\">//     in physical memory?  Which pages are already in use for</span>\n\t<span class=\"token comment\">//     page tables and other data structures?</span>\n\t<span class=\"token comment\">//</span>\n\t<span class=\"token comment\">// Change the code to reflect this.</span>\n\t<span class=\"token comment\">// NB: DO NOT actually touch the physical memory corresponding to</span>\n\t<span class=\"token comment\">// free pages!</span>\n\tsize_t i<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> npages_basemem<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\tpages<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>pp_ref <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\t\tpages<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>pp_link <span class=\"token operator\">=</span> page_free_list<span class=\"token punctuation\">;</span>\n\t\tpage_free_list <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>pages<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token function\">PADDR</span><span class=\"token punctuation\">(</span><span class=\"token function\">boot_alloc</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token operator\">/</span>PGSIZE<span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> npages<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    pages<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>pp_ref <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\tpages<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>pp_link <span class=\"token operator\">=</span> page_free_list<span class=\"token punctuation\">;</span>\n\tpage_free_list <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>pages<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>因为kernel是分配在extended memory里面，加上mem_init的前面分配的page dir以及相关的内存，所以后一部分应该跳过这些地方。然后<code class=\"language-text\">PADDR</code>就是把kernel里面的VA转化为PA。</p>\n<p>然后写<code class=\"language-text\">page_alloc</code>，从<code class=\"language-text\">page_free_list</code>里面提取出来下一个非空的page</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// Allocates a physical page.  If (alloc_flags &amp; ALLOC_ZERO), fills the entire</span>\n<span class=\"token comment\">// returned physical page with '\\0' bytes.  Does NOT increment the reference</span>\n<span class=\"token comment\">// count of the page - the caller must do these if necessary (either explicitly</span>\n<span class=\"token comment\">// or via page_insert).</span>\n<span class=\"token comment\">//</span>\n<span class=\"token comment\">// Be sure to set the pp_link field of the allocated page to NULL so</span>\n<span class=\"token comment\">// page_free can check for double-free bugs.</span>\n<span class=\"token comment\">//</span>\n<span class=\"token comment\">// Returns NULL if out of free memory.</span>\n<span class=\"token comment\">//</span>\n<span class=\"token comment\">// Hint: use page2kva and memset</span>\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">PageInfo</span> <span class=\"token operator\">*</span>\n<span class=\"token function\">page_alloc</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> alloc_flags<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\t<span class=\"token comment\">// Fill this function in</span>\n  <span class=\"token keyword\">struct</span> <span class=\"token class-name\">PageInfo</span> <span class=\"token operator\">*</span>ret <span class=\"token operator\">=</span> page_free_list<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>page_free_list<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n  page_free_list <span class=\"token operator\">=</span> ret<span class=\"token operator\">-></span>pp_link<span class=\"token punctuation\">;</span>\n  ret<span class=\"token operator\">-></span>pp_link <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>alloc_flags <span class=\"token operator\">&amp;</span> ALLOC_ZERO<span class=\"token punctuation\">)</span>\n    <span class=\"token function\">memset</span><span class=\"token punctuation\">(</span><span class=\"token function\">page2kva</span><span class=\"token punctuation\">(</span>ret<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> PGSIZE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">return</span> ret<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>注意这里面的<code class=\"language-text\">page2kva</code>函数是把一个page的PageInfo地址转化为其对应的kernel VA，具体的做法就是看pp是pages后面的第几个<code class=\"language-text\">PageInfo</code>，然后这个序号就是这个page的物理内存的前20位，因为是对齐的，所以后12位都是0，得到这个物理地址之后，加<code class=\"language-text\">KERNBASE</code>就找到了这个page的物虚拟内存。注意这里把取出来的<code class=\"language-text\">ret</code>的后面变为空了，这个举动单纯就是用来在<code class=\"language-text\">page_free</code>里面进行检查的。</p>\n<p>然后最后一个<code class=\"language-text\">page_free</code>。</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// Return a page to the free list.</span>\n<span class=\"token comment\">// (This function should only be called when pp->pp_ref reaches 0.)</span>\n<span class=\"token comment\">//</span>\n<span class=\"token keyword\">void</span>\n<span class=\"token function\">page_free</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">PageInfo</span> <span class=\"token operator\">*</span>pp<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\t<span class=\"token comment\">// Fill this function in</span>\n\t<span class=\"token comment\">// Hint: You may want to panic if pp->pp_ref is nonzero or</span>\n\t<span class=\"token comment\">// pp->pp_link is not NULL.</span>\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>pp<span class=\"token operator\">-></span>pp_ref <span class=\"token operator\">||</span> pp<span class=\"token operator\">-></span>pp_link<span class=\"token punctuation\">)</span>\n    <span class=\"token function\">panic</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"pp free error.\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  pp<span class=\"token operator\">-></span>pp_link <span class=\"token operator\">=</span> page_free_list<span class=\"token punctuation\">;</span>\n  page_free_list <span class=\"token operator\">=</span> pp<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>写完这部分之后，启动时会是这样：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">check_page_free_list() succeeded!\ncheck_page_alloc() succeeded!</code></pre></div>\n<h2>Part 2: Virtual Memory</h2>\n<h3>Exercise 2</h3>\n<p>读书的部分，先跳过去。</p>\n<h3>Virtual, Linear, and Physical Addresses</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">           Selector  +--------------+         +-----------+\n          ----------&gt;|              |         |           |\n                     | Segmentation |         |  Paging   |\nSoftware             |              |--------&gt;|           |----------&gt;  RAM\n            Offset   |  Mechanism   |         | Mechanism |\n          ----------&gt;|              |         |           |\n                     +--------------+         +-----------+\n            Virtual                   Linear                Physical</code></pre></div>\n<p>在x86里面，虚拟内存由segment selector和offset within the segment组成。linear address是先用segment translation解释过的结果，之后再通过page translation得到物理内存。</p>\n<p>一个C语言中的指针实际上是offset，在<code class=\"language-text\">boot/boot.S</code>里面，我们用Global Descriptor Table(GDT)来有效的把segment selector给废了</p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\">gdt:\n  SEG_NULL\t\t\t\t# null seg\n  SEG(STA_X|STA_R, 0x0, 0xffffffff)\t# code seg\n  SEG(STA_W, 0x0, 0xffffffff)\t        # data seg</code></pre></div>\n<p>所以linear address在JOS中就是等于offset。在lab 3中我们可能会设置一点segmentation以设置隐私等级，但是对于内存翻译，在JOS中我们可以忽略segmentation mechanism并只考虑page translation。</p>\n<p>回忆在lab 1的part3，我们使用在<code class=\"language-text\">kern/entrypgdir.c</code>硬编码的一个page table来把物理内存中前4MB的内存进行了映射，从而让kernel能够从<code class=\"language-text\">0xf0100000</code>开始运行，即使其实际上是在<code class=\"language-text\">0x00100000</code>的物理内存加载的。我们现在就会映射整个的256MB的物理内存，从虚拟内存<code class=\"language-text\">0xf0000000</code>开始，并映射到一些位置。</p>\n<h3>Exercise 3</h3>\n<p>一些gdb和qemu的一些指令。</p>\n<p>之前在<code class=\"language-text\">boot.S</code>我们提到过protected mode，就是在这个文件里头做的第一件事。所有的内存引用都会被翻译为虚拟内存，之后用MMU翻译为物理内存。所以说所有C中的指针都是虚拟地址。</p>\n<p>JOS的kernel经常需要直接把地址当成整数来操作，也就是不去探究地址里存了什么。为了方便文档记录，JOS用两个类型来记录地址：<code class=\"language-text\">uintptr_t</code>用来表示虚拟地址，<code class=\"language-text\">physaddr_t</code>表示物理内存，他们实际上就是<code class=\"language-text\">uint32_t</code>，所以从编译器的角度并不会阻止这两个类型之中的相互赋值，而且如果直接dereference回报错，需要类型转换。对于<code class=\"language-text\">uintptr_t</code>可以转化为指针类型进行dereference，而对于物理地址，不能直接dereference。</p>\n<p>简而言之：</p>\n<table>\n<thead>\n<tr>\n<th>C type</th>\n<th>Address type</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">T*</code></td>\n<td>Virtual</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">uintptr_t</code></td>\n<td>Virtual</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">physaddr_t</code></td>\n<td>Physical</td>\n</tr>\n</tbody>\n</table>\n<p>JOS kernel经常需要读写只知道物理地址的内存。比如说，mapping a page table可能需要分配物理内存来存储page directory，并对应的呃呃你存。但是kernel不能bypass virtual address translation，所以不能直接load and store物理内存。JOS把所有的从0开始的物理内存映射到从<code class=\"language-text\">0xf0000000</code>开始的虚拟内存是为了帮助kernel读写其只知道物理地址的内存。也就是直接把物理内存加<code class=\"language-text\">0xf0000000</code>从而转化为对应的虚拟内存。应该用<code class=\"language-text\">KADDR(pa)</code>。</p>\n<p>有的时候还需要从虚拟地址转化为物理地址，也是相似的，需要减，用<code class=\"language-text\">PADDR(va)</code>。</p>\n<h3>Reference counting</h3>\n<p>之后的lab，经常会需要把同一个物理地址同时转化为多个虚拟内存。那么就需要对引用进行计数，这也就是<code class=\"language-text\">PageInfo</code>中的<code class=\"language-text\">pp_ref</code>。当这个值为0的时候就可以释放掉了（就像垃圾回收）。换句话说，这个值应该是UTOP下面所有的page tables提及到总次数（UTOP上的内存一般都是kernel相关的，一般都不会释放了，所以不需要对他们计数）。我们也需要记录指向page directory pages的指针数，同时page directory指向page table pages的引用数。</p>\n<p>注意用<code class=\"language-text\">page_alloc</code>的时候，分配出来的引用计数都是0，调用完一些函数之后需要手动添加引用数。</p>\n<h3>Page Table Management</h3>\n<h3>Exercise 4</h3>\n<p>修改这些函数：</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token function\">pgdir_walk</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">boot_map_region</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">page_lookup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">page_remove</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">page_insert</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>首先是<code class=\"language-text\">pgdir_walk</code>，类似于xv6里面的<code class=\"language-text\">walkpgdir</code>。</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">pte_t <span class=\"token operator\">*</span>\n<span class=\"token function\">pgdir_walk</span><span class=\"token punctuation\">(</span>pde_t <span class=\"token operator\">*</span>pgdir<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>va<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> create<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\t<span class=\"token comment\">// Fill this function in</span>\n  pde_t <span class=\"token operator\">*</span>pde <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>pgdir<span class=\"token punctuation\">[</span><span class=\"token function\">PDX</span><span class=\"token punctuation\">(</span>va<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>pde <span class=\"token operator\">&amp;</span> PTE_P<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>create<span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">return</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">struct</span> <span class=\"token class-name\">PageInfo</span> <span class=\"token operator\">*</span>pgtab <span class=\"token operator\">=</span> <span class=\"token function\">page_alloc</span><span class=\"token punctuation\">(</span>ALLOC_ZERO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>pgtab<span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">return</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n    pgtab<span class=\"token operator\">-></span>pp_ref<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    <span class=\"token operator\">*</span>pde <span class=\"token operator\">=</span> <span class=\"token function\">page2pa</span><span class=\"token punctuation\">(</span>pgtab<span class=\"token punctuation\">)</span> <span class=\"token operator\">|</span> PTE_P <span class=\"token operator\">|</span> PTE_U <span class=\"token operator\">|</span> PTE_W<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>pte_t<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token function\">KADDR</span><span class=\"token punctuation\">(</span><span class=\"token function\">PTE_ADDR</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>pde<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token function\">PTX</span><span class=\"token punctuation\">(</span>va<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>这里面的主要逻辑是先用前10位找到va对应的pde，如果需要创建，那么就创建创建一个page，并且把这个page的地址前12位去掉（这就是<code class=\"language-text\">page2pa</code>干的事），然后把空出来的那12位附上值，给pde对应的值付为这个page对应的page table的地址。最后正常的返回。</p>\n<p>然后是<code class=\"language-text\">boot_map_region</code>，类似于xv6的<code class=\"language-text\">mappages</code>，不过注意这里的size已经是PGSIZE的整数倍了。</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// Map [va, va+size) of virtual address space to physical [pa, pa+size)</span>\n<span class=\"token comment\">// in the page table rooted at pgdir.  Size is a multiple of PGSIZE, and</span>\n<span class=\"token comment\">// va and pa are both page-aligned.</span>\n<span class=\"token comment\">// Use permission bits perm|PTE_P for the entries.</span>\n<span class=\"token comment\">//</span>\n<span class=\"token comment\">// This function is only intended to set up the ``static'' mappings</span>\n<span class=\"token comment\">// above UTOP. As such, it should *not* change the pp_ref field on the</span>\n<span class=\"token comment\">// mapped pages.</span>\n<span class=\"token comment\">//</span>\n<span class=\"token comment\">// Hint: the TA solution uses pgdir_walk</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span>\n<span class=\"token function\">boot_map_region</span><span class=\"token punctuation\">(</span>pde_t <span class=\"token operator\">*</span>pgdir<span class=\"token punctuation\">,</span> uintptr_t va<span class=\"token punctuation\">,</span> size_t size<span class=\"token punctuation\">,</span> physaddr_t pa<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> perm<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\t<span class=\"token comment\">// Fill this function in</span>\n  <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>uint32_t i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;</span>size<span class=\"token punctuation\">;</span> i<span class=\"token operator\">+=</span>PGSIZE<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    pte_t <span class=\"token operator\">*</span>pte <span class=\"token operator\">=</span> <span class=\"token function\">pgdir_walk</span><span class=\"token punctuation\">(</span>pgdir<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>va<span class=\"token punctuation\">,</span> true<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token operator\">*</span>pte <span class=\"token operator\">=</span> pa <span class=\"token operator\">|</span> perm <span class=\"token operator\">|</span> PTE_P<span class=\"token punctuation\">;</span>\n    va <span class=\"token operator\">+=</span> PGSIZE<span class=\"token punctuation\">;</span>\n    pa <span class=\"token operator\">+=</span> PGSIZE<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>注意这里面<code class=\"language-text\">va</code>, <code class=\"language-text\">pa</code>都是相关于PGSIZE对齐了的，也就是只剩下了20位。</p>\n<p>之后是写<code class=\"language-text\">page_insert</code>。</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span>\n<span class=\"token function\">page_insert</span><span class=\"token punctuation\">(</span>pde_t <span class=\"token operator\">*</span>pgdir<span class=\"token punctuation\">,</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">PageInfo</span> <span class=\"token operator\">*</span>pp<span class=\"token punctuation\">,</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>va<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> perm<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\t<span class=\"token comment\">// Fill this function in</span>\n  pte_t <span class=\"token operator\">*</span>pte <span class=\"token operator\">=</span> <span class=\"token function\">pgdir_walk</span><span class=\"token punctuation\">(</span>pgdir<span class=\"token punctuation\">,</span> va<span class=\"token punctuation\">,</span> true<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>pte<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span>E_NO_MEM<span class=\"token punctuation\">;</span>\n  pp<span class=\"token operator\">-></span>pp_ref<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>pte <span class=\"token operator\">&amp;</span> PTE_P<span class=\"token punctuation\">)</span>\n    <span class=\"token function\">page_remove</span><span class=\"token punctuation\">(</span>pgdir<span class=\"token punctuation\">,</span> va<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token operator\">*</span>pte <span class=\"token operator\">=</span> <span class=\"token function\">page2pa</span><span class=\"token punctuation\">(</span>pp<span class=\"token punctuation\">)</span> <span class=\"token operator\">|</span> perm <span class=\"token operator\">|</span> PTE_P<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>就是用了一下前面的接口。</p>\n<p>然后是<code class=\"language-text\">page_lookup</code>。</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">PageInfo</span> <span class=\"token operator\">*</span>\n<span class=\"token function\">page_lookup</span><span class=\"token punctuation\">(</span>pde_t <span class=\"token operator\">*</span>pgdir<span class=\"token punctuation\">,</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>va<span class=\"token punctuation\">,</span> pte_t <span class=\"token operator\">*</span><span class=\"token operator\">*</span>pte_store<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Fill this function in</span>\n  pte_t <span class=\"token operator\">*</span>pte <span class=\"token operator\">=</span> <span class=\"token function\">pgdir_walk</span><span class=\"token punctuation\">(</span>pgdir<span class=\"token punctuation\">,</span> va<span class=\"token punctuation\">,</span> false<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>pte <span class=\"token operator\">||</span> <span class=\"token operator\">!</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>pte <span class=\"token operator\">&amp;</span> PTE_P<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>pte_store<span class=\"token punctuation\">)</span>\n    <span class=\"token operator\">*</span>pte_store <span class=\"token operator\">=</span> pte<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">pa2page</span><span class=\"token punctuation\">(</span><span class=\"token function\">PTE_ADDR</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>pte<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>和<code class=\"language-text\">page_insert</code>很像。</p>\n<p><code class=\"language-text\">page_remove</code></p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">void</span>\n<span class=\"token function\">page_remove</span><span class=\"token punctuation\">(</span>pde_t <span class=\"token operator\">*</span>pgdir<span class=\"token punctuation\">,</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>va<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Fill this function in</span>\n  pte_t <span class=\"token operator\">*</span>pte <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">struct</span> <span class=\"token class-name\">PageInfo</span> <span class=\"token operator\">*</span>pp <span class=\"token operator\">=</span> <span class=\"token function\">pgdir_walk</span><span class=\"token punctuation\">(</span>pgdir<span class=\"token punctuation\">,</span> va<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>pte<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>pp<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n  <span class=\"token operator\">*</span>pte <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">page_decref</span><span class=\"token punctuation\">(</span>pp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">tlb_invalidate</span><span class=\"token punctuation\">(</span>pgdir<span class=\"token punctuation\">,</span> va<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>这里面不太好理解的是最后的这个<code class=\"language-text\">tlb_invalidate</code>，这个函数是调用再<code class=\"language-text\">x86.h</code>中的<code class=\"language-text\">invlpg</code>函数，也就是汇编中的<code class=\"language-text\">invlpg</code>指令，详细的理解可以看<a href=\"http://www.voidcn.com/article/p-fioicjwh-xq.html\">这里</a>，大致就是会刷新Translation Lookaside Buffer(TLB)，其缓存了线性地址到物理地址的映射关系。</p>\n<p>然后运行一下。得到：</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token function\">check_page_free_list</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> succeeded<span class=\"token operator\">!</span>\n<span class=\"token function\">check_page_alloc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> succeeded<span class=\"token operator\">!</span>\n<span class=\"token function\">check_page</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> succeeded<span class=\"token operator\">!</span></code></pre></div>\n<h2>Part 3: Kernel Address Space</h2>\n<p>JOS把32位的线性地址分为两个部分。User environments(进程)，会控制lower part的layout和content，而kernel会对应upper part。这两者的分界线是<code class=\"language-text\">inc/memlayout.h</code>中的<code class=\"language-text\">ULIM</code>。大约给kernel保存了256MB。This explains why we needed to give the kernel such a high link address in lab 1: otherwise there would not be enough room in the kernel's virtual address space to map in a user environment below it at the same time.（这个this is why没明白）。</p>\n<h3>Permissions and Fault Isolation</h3>\n<p>User environment对于<code class=\"language-text\">ULIM</code>之下有访问权限。而对于[<code class=\"language-text\">UTOP</code>, <code class=\"language-text\">ULIM</code>)之间的内存，是kernel 与user environment有相同的权限，可读不可写。这部分是用来把kernel中的一部分信息给user。最下面的部分就是给user的，user可以自己设置权限。</p>\n<h3>Initializing the Kernel Address Space</h3>\n<p>现在需要设置的是<code class=\"language-text\">UTOP</code>之上的内存。</p>\n<h3>Exercise 5</h3>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">\t<span class=\"token comment\">//////////////////////////////////////////////////////////////////////</span>\n\t<span class=\"token comment\">// Now we set up virtual memory</span>\n\n\t<span class=\"token comment\">//////////////////////////////////////////////////////////////////////</span>\n\t<span class=\"token comment\">// Map 'pages' read-only by the user at linear address UPAGES</span>\n\t<span class=\"token comment\">// Permissions:</span>\n\t<span class=\"token comment\">//    - the new image at UPAGES -- kernel R, user R</span>\n\t<span class=\"token comment\">//      (ie. perm = PTE_U | PTE_P)</span>\n\t<span class=\"token comment\">//    - pages itself -- kernel RW, user NONE</span>\n\t<span class=\"token comment\">// Your code goes here:</span>\n  <span class=\"token function\">boot_map_region</span><span class=\"token punctuation\">(</span>kern_pgdir<span class=\"token punctuation\">,</span> UPAGES<span class=\"token punctuation\">,</span> PTSIZE<span class=\"token punctuation\">,</span> <span class=\"token function\">PADDR</span><span class=\"token punctuation\">(</span>pages<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> PTE_U <span class=\"token operator\">|</span> PTE_P<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token comment\">//////////////////////////////////////////////////////////////////////</span>\n\t<span class=\"token comment\">// Use the physical memory that 'bootstack' refers to as the kernel</span>\n\t<span class=\"token comment\">// stack.  The kernel stack grows down from virtual address KSTACKTOP.</span>\n\t<span class=\"token comment\">// We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)</span>\n\t<span class=\"token comment\">// to be the kernel stack, but break this into two pieces:</span>\n\t<span class=\"token comment\">//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory</span>\n\t<span class=\"token comment\">//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if</span>\n\t<span class=\"token comment\">//       the kernel overflows its stack, it will fault rather than</span>\n\t<span class=\"token comment\">//       overwrite memory.  Known as a \"guard page\".</span>\n\t<span class=\"token comment\">//     Permissions: kernel RW, user NONE</span>\n\t<span class=\"token comment\">// Your code goes here:</span>\n  <span class=\"token function\">boot_map_region</span><span class=\"token punctuation\">(</span>kern_pgdir<span class=\"token punctuation\">,</span> KSTACKTOP<span class=\"token operator\">-</span>KSTKSIZE<span class=\"token punctuation\">,</span> KSTKSIZE<span class=\"token punctuation\">,</span> <span class=\"token function\">PADDR</span><span class=\"token punctuation\">(</span>bootstack<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> PTE_W <span class=\"token operator\">|</span> PTE_P<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token comment\">//////////////////////////////////////////////////////////////////////</span>\n\t<span class=\"token comment\">// Map all of physical memory at KERNBASE.</span>\n\t<span class=\"token comment\">// Ie.  the VA range [KERNBASE, 2^32) should map to</span>\n\t<span class=\"token comment\">//      the PA range [0, 2^32 - KERNBASE)</span>\n\t<span class=\"token comment\">// We might not have 2^32 - KERNBASE bytes of physical memory, but</span>\n\t<span class=\"token comment\">// we just set up the mapping anyway.</span>\n\t<span class=\"token comment\">// Permissions: kernel RW, user NONE</span>\n\t<span class=\"token comment\">// Your code goes here:</span>\n  <span class=\"token function\">boot_map_region</span><span class=\"token punctuation\">(</span>kern_pgdir<span class=\"token punctuation\">,</span> KERNBASE<span class=\"token punctuation\">,</span> <span class=\"token number\">0x10000000</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> PTE_W <span class=\"token operator\">|</span> PTE_P<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>根据注释加入映射。</p>\n<p>之后再运行就有：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">check_page_free_list<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> succeeded<span class=\"token operator\">!</span>\ncheck_page_alloc<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> succeeded<span class=\"token operator\">!</span>\ncheck_page<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> succeeded<span class=\"token operator\">!</span>\ncheck_kern_pgdir<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> succeeded<span class=\"token operator\">!</span>\ncheck_page_free_list<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> succeeded<span class=\"token operator\">!</span>\ncheck_page_installed_pgdir<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> succeeded<span class=\"token operator\">!</span></code></pre></div>\n<p>下面有几个问题。</p>\n<h2>Address Space Layout Alternatives</h2>\n<p>本次用的这种映射的layout不是唯一解。比如也可以是kernel在low linear address，而user在upper。不过x86一般不这么做，原因是为了和8086有backward-compatibility。</p>\n<p>还可以设计kernel使其不用为自己不保存任何固定的内存，而是让用户能更有效的使用4G的内存。这里有很多Challenge，之后有时间再说吧。</p>\n<p>写完了之后跑一些测试：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">running JOS: <span class=\"token punctuation\">(</span>0.5s<span class=\"token punctuation\">)</span>\n  Physical page allocator: OK\n  Page management: OK\n  Kernel page directory: OK\n  Page management 2: OK\nScore: 70/70</code></pre></div>","frontmatter":{"title":"6.828 lab2 Memory Management","date":"2019-02-24T17:50:00.000Z","tags":["OS","6.828"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/6.828-lab2/"}}}