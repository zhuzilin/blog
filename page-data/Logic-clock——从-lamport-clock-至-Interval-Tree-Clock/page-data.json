{"componentChunkName":"component---src-templates-blog-post-js","path":"/Logic-clock——从-lamport-clock-至-Interval-Tree-Clock/","webpackCompilationHash":"d3c4e6ec70b03f15d22e","result":{"data":{"markdownRemark":{"html":"<p>继续来读 Lamport 老先生的经典论文。这次是大名鼎鼎的《Time, Clocks, and the Ordering of Events in a Distributed System》，这篇文章提出了分布式系统的逻辑时钟。</p>\n<h2>lamport clock</h2>\n<p>论文名：Time, Clocks, and the Ordering of Events in a Distributed System</p>\n<p>首先定义一个事件之间的偏序：</p>\n<ol>\n<li>a 和 b 在同一个进程，a 先发生，所以 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi><mo>−</mo><mo>&gt;</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">a -&gt; b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">a</span><span class=\"mord\">−</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span></li>\n<li>a 是一个 message 的发送事件，b 是接受事件，所以 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi><mo>−</mo><mo>&gt;</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">a -&gt; b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">a</span><span class=\"mord\">−</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span></li>\n<li>如果 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi><mo>−</mo><mo>&gt;</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">a -&gt; b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">a</span><span class=\"mord\">−</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi><mo>−</mo><mo>&gt;</mo><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">b -&gt; c</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.77777em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">b</span><span class=\"mord\">−</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">c</span></span></span></span>，那么 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi><mo>−</mo><mo>&gt;</mo><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">a -&gt; c</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">a</span><span class=\"mord\">−</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">c</span></span></span></span>。</li>\n</ol>\n<p>如果 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi><mi mathvariant=\"normal\">/</mi><mo>−</mo><mo>&gt;</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">a /-&gt; b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">a</span><span class=\"mord\">/</span><span class=\"mord\">−</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span> 且 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi><mi mathvariant=\"normal\">/</mi><mo>−</mo><mo>&gt;</mo><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">b /-&gt; a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">b</span><span class=\"mord\">/</span><span class=\"mord\">−</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span>，就称 a，b concurrent。</p>\n<p>引入一个全系统的时钟 C，有：</p>\n<ul>\n<li>Clock Condition：For\\ any\\ event\\ a,b:\\ if\\ a->b\\ then\\ C(a)&#x3C;C(b)</li>\n</ul>\n<p>注意我们不能保证逆命题也成立，就是说如果 C(a)&#x3C;C(b)，不一定有 a -> b。</p>\n<p>为了保证时钟满足这个条件，我们会让时钟有这样两个性质：</p>\n<ul>\n<li>IR1：每个进程会在发生下一个进程的时候增加时钟的值；</li>\n<li>\n<p>IR2：</p>\n<p>a. 如果 a 是信息 m 的发送事件，那么 m 中会保存一个时间戳 Tm，满足 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>T</mi><mi>m</mi></msub><mo>=</mo><msub><mi>C</mi><mi>i</mi></msub><mo stretchy=\"false\">(</mo><mi>a</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">T_m=C_i(a)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">a</span><span class=\"mclose\">)</span></span></span></span></p>\n<p>b. 当接收到信息 m 的时候，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>P</mi><mi>j</mi></msub></mrow><annotation encoding=\"application/x-tex\">P_j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.969438em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span> 会把 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>C</mi><mi>j</mi></msub></mrow><annotation encoding=\"application/x-tex\">C_j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.969438em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span> 设置为比 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>T</mi><mi>m</mi></msub></mrow><annotation encoding=\"application/x-tex\">T_m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 大的数。</p>\n</li>\n</ul>\n<p>到目前为止，我们仅仅有一个事件之间的偏序，会存在一些事件的 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>C</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>C</mi><mo stretchy=\"false\">(</mo><mi>b</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">C(a) = C(b)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">a</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">b</span><span class=\"mclose\">)</span></span></span></span>，为了补全这部分，制造一个时间的全序，我们引入一个进程的序 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub><mo>&lt;</mo><msub><mi>P</mi><mi>j</mi></msub></mrow><annotation encoding=\"application/x-tex\">P_i &lt; P_j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.969438em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span>，所以当 C 相等时，通过比较进程来决出大小。</p>\n<p>有了这个全序之后，我们可以解决很多问题。例如，考虑变种的 mutual exclusion 问题——多个进程都需要使用同一个资源（resource），但是每个时刻只能有一个进程获取该资源——我们可以给出一个满足以下 3 个条件的算法。</p>\n<ol>\n<li>在把资源分配个一个新的进程之前，需要掌握资源的进程释放资源；</li>\n<li>不同的获取资源的请求应该以他们开始的先后顺序得以满足；</li>\n<li>如果每个进程最终都会释放资源，那么最终，所有的获取请求都会被满足。</li>\n</ol>\n<p>我们假设资源最开始被交给了某一个进程。注意，2 并没有规定该怎么排两个 concurrent 请求。</p>\n<p>注意这个问题不能用一个 central scheduler 解决。假设 P0 是 scheduler，P1 先发一个 request 给 P0，再发送一个信息给 P2，假设 P2 在接收到 P1 发送给他的信息之前，也发送了一个 request 给 P0，那么 P1 -> P0 和 P2 -> P0 这两个时间是 concurrent 的（这里设置一个 P1 -> P2 就是为了表明这个 concurrent），所以有可能 P0 会先收到 P2 的请求，从而先满足 P2，这就和上面的 2 相矛盾了。（个人理解，这里并不是说后面的方法一定能保证 P1 的请求先执行，而是说有可能 P1 先执行，也有可能 P2 先执行，所以任何先后顺序都没法满足。）</p>\n<p>为了解决这个问题，文中实现了一个满足 IR1 和 IR2 的时钟。并用时钟来表示时间的全序，从而将所有的请求和释放事件排序。根据这个排序，找到一个解法就变得很简单了。</p>\n<p>这里我们假设对于任意 2 个进程 Pi 和 Pj，他们之间所有相互发送的信息最后都会被收到的，并且先发送的信息会被先收到，这样就避免了设计 message number 和 message acknowledge protocols 了（可以理解为如果不满足这个假设，可以在算法上加一层 TCP 这样的协议，就满足这样的假设了）。每个进程有一个 request queue。request queue 中最初有 T0:P0。P0 is the process initially granted the resource and T0 is less than the initial value of any clock.</p>\n<ol>\n<li>为了获取资源，Pi 把 Tm:Pi 消息发给所有其他的进程，并把这条消息放在自己的 request queue 上。这里 Tm 是消息的时间戳（发送时间）；</li>\n<li>当进程 Pj 接收到 Tm;Pi 的时候，它会把消息放在自己的 request queue 上，并回复一个 timestamped acknowledge message 给 Pi；</li>\n<li>在释放资源的时候，Pi 会删除 request resource 中的任何 Tm:Pi request message，并给其他所有进程发一个 timestamped releases resouce message；</li>\n<li>当 Pj 收到 Pi 的 release resource message 的时候，它会删除自己 request queue 中的 Tm:Pi；</li>\n<li>\n<p>在下面 2 个条件得到满足的时候，Pi 会得到资源</p>\n<ol>\n<li>在队列中有 Tm:Pi request resouce，其 order 大于所有其他 request</li>\n<li>Pi 从其他所有的 process 处都收到了一个时间晚于 Tm 的信息</li>\n</ol>\n</li>\n</ol>\n<p>我们还是先粗略地看一下，这里最关键的肯定是 5.2，由于我们假设信息是顺序收到的，那么如果一个进程收到了其他所有消息之后，仍然发现自己的 Tm;Pi 是最小的，那么肯定就说明他是最先 request 的。这个先到先得的效果就有了。那么为什么这个算法保证有且只有一个进程获得资源呢？首先，因为在释放资源之前，所有的 Pj 都还会有 Pi 发过来的 Tm:Pi，这个肯定是最小的，就让其他的进程没法获得资源；其次，如果一直都没有获得资源的，那么某一个 request 的节点至少会收到其他节点的 acknowledge message，从而能获取节点，说明不会死锁。然后这个先到先得也防止了 starvation。不过有个问题，对于这个算法来说，如果出现单节点 failure，就会卡主了... Lamport 老爷子在另一篇论文中给出了能够支持容错的算法，论文名为：The implementation of reliable distributed multiprocess systems，有时间可以看看~</p>\n<p>到这里，这个逻辑时钟有什么问题呢？有一个问题是，它的顺序仅仅能通过系统内部的偏序决定，所以可能会出现这样的问题，小明先在系统上发了个请求 A，然后在另一台机器上发了请求 B，结果 B 先被处理了。为了解决这个问题，我们需要重新引入物理时钟。</p>\n<h2>Vector Clock</h2>\n<p>论文名：Timestamps in Message-Passing Systems That Preserve the Partial Ordering</p>\n<p>作者：Colin J. Fidge</p>\n<p>Lamport clock 的问题在于并没有一个确定的顺序</p>\n<p>vector clocks is easy</p>\n<p>vector clocks is easy</p>\n<p><a href=\"https://haslab.wordpress.com/2011/07/08/version-vectors-are-not-vector-clocks/\">https://haslab.wordpress.com/2011/07/08/version-vectors-are-not-vector-clocks/</a></p>\n<p><a href=\"https://riak.com/posts/technical/vector-clocks-revisited/index.html?p=9545.html\">https://riak.com/posts/technical/vector-clocks-revisited/index.html?p=9545.html</a></p>\n<p><a href=\"https://riak.com/posts/technical/vector-clocks-revisited-part-2-dotted-version-vectors/index.html?p=9929.html\">https://riak.com/posts/technical/vector-clocks-revisited-part-2-dotted-version-vectors/index.html?p=9929.html</a></p>","frontmatter":{"title":"","date":null,"tags":null}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/Logic-clock——从-lamport-clock-至-Interval-Tree-Clock/"}}}