{"componentChunkName":"component---src-templates-blog-post-js","path":"/6.828-lab1/","webpackCompilationHash":"557623b291ecba0df33f","result":{"data":{"markdownRemark":{"html":"<p>布置好环境之后就可以开始一点一点写作业了。</p>\n<h2>Part 1: PC Bootstrap</h2>\n<h3>Getting Started with x86 assembly</h3>\n<p>了解汇编代码。</p>\n<h3>Exercise 1</h3>\n<p>阅读<a href=\"http://www.delorie.com/djgpp/doc/brennan/brennan_att_inline_djgpp.html\">Brennan's Guide to Inline Assembly</a>的The Syntax部分，该书是使用的AT&#x26;T syntax和本课使用的GNU assembler一致。</p>\n<p>需要注意的是，AT&#x26;T是左边移到右边，Intel是右边移到左边</p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\">movl %eax, %ebx # AT&amp;T\nmov ebx, eax # Intel</code></pre></div>\n<p>注意上面两句的意思都是load ebx with the value in eax。</p>\n<p>另外注意一下两个的区别：</p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\">movl $0x4, %eax # tmp = 0x4, 把eax直接赋值为0x4\nmovl $-147, (%eax) # *p  = -147，把eax值作为地址，这个地址对应的位置的值赋值为-147</code></pre></div>\n<p>有关jmp，有如下几种：</p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\">jmp 7d51  # relative jump, 只把IP赋值，在同一个segment里面\nljmp $0x10,$0x100000  # 给CS:IP赋值，不在同一个segment里面，是absolute的\njump *0x10018 # absolute, jump, 跳到绝对地址</code></pre></div>\n<p>注意在real mode的时候接受的才是16位，protected mode就会直接接受32位了，也就没有什么relative, absolute了。</p>\n<h3>Simulating the x86</h3>\n<p>编译JOS并测试qemu。这部分在配置环境的时候就已经进行了。</p>\n<p>注意，虽然现在使用的是qemu虚拟机，但是仍然和直接跑在硬盘上是一样的。</p>\n<blockquote>\n<p>Although simple, it's important to note that this kernel monitor is running \"directly\" on the \"raw (virtual) hardware\" of the simulated PC. This means that you should be able to copy the contents of<code class=\"language-text\">obj/kern/kernel.img</code> onto the first few sectors of a <em>real</em> hard disk, insert that hard disk into a real PC, turn it on, and see exactly the same thing on the PC's real screen as you did above in the QEMU window. (We don't recommend you do this on a real machine with useful information on its hard disk, though, because copying <code class=\"language-text\">kernel.img</code> onto the beginning of its hard disk will trash the master boot record and the beginning of the first partition, effectively causing everything previously on the hard disk to be lost!)</p>\n</blockquote>\n<h3>The PC's Physical Address Space</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">+------------------+  &lt;- 0xFFFFFFFF (4GB)\n|      32-bit      |\n|  memory mapped   |\n|     devices      |\n|                  |\n/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\\n\n/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\\n|                  |\n|      Unused      |\n|                  |\n+------------------+  &lt;- depends on amount of RAM\n|                  |\n|                  |\n| Extended Memory  |\n|                  |\n|                  |\n+------------------+  &lt;- 0x00100000 (1MB)\n|     BIOS ROM     |\n+------------------+  &lt;- 0x000F0000 (960KB)\n|  16-bit devices, |\n|  expansion ROMs  |\n+------------------+  &lt;- 0x000C0000 (768KB)\n|   VGA Display    |\n+------------------+  &lt;- 0x000A0000 (640KB)\n|                  |\n|    Low Memory    |\n|                  |\n+------------------+  &lt;- 0x00000000</code></pre></div>\n<p>上图是一个32位系统的内存布局。最下面的1M是最原始16位Intel 8088 processor所使用的。当时的random access memory(RAM)仅仅有640KB。</p>\n<p>从<code class=\"language-text\">0x000A0000</code>到<code class=\"language-text\">0x000FFFFF</code>的384KB是留给硬件使用的。</p>\n<p>从<code class=\"language-text\">0x000F0000</code>到<code class=\"language-text\">0x000FFFFF</code>的64KB非常重要，是Basic Input/Output System(BIOS)。</p>\n<blockquote>\n<p>The BIOS is responsible for performing basic system initialization such as activating the video card and checking the amount of memory installed</p>\n</blockquote>\n<p>为了backward compatibility，在32位机器仍然保留了最原始1MB的布局。</p>\n<blockquote>\n<p>Recent x86 processors can support <em>more</em> than 4GB of physical RAM, so RAM can extend further above 0xFFFFFFFF. In this case the BIOS must arrange to leave a <em>second</em> hole in the system's RAM at the top of the 32-bit addressable region, to leave room for these 32-bit devices to be mapped. </p>\n<p>Because of design limitations JOS will use only the first 256MB of a PC's physical memory anyway, so for now we will pretend that all PCs have \"only\" a 32-bit physical address space. </p>\n</blockquote>\n<h3>The ROM BIOS</h3>\n<p>在启动OS的时候，最先会load BIOS。</p>\n<p>使用qemu结合gdb开始调试JOS的kernel。可以看出运行的第一行是从存在BIOS部分内存的指令开始的。指令用CS:IP，这里cs是code segment pointer，ip是instruction pointer，他们一起成为了一个20bit的地址指针，其计算方式是</p>\n<p><em>physical address = 16 * segment + offset</em>.</p>\n<h3>Exercise 2</h3>\n<p>用si进行多步运行。其结果为</p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\"># 跳到 [f000:e05b]\n[f000:fff0]    0xffff0: ljmp   $0xf000,$0xe05b\n+ symbol-file obj/kern/kernel\n(gdb) si # 比较0与%cs:0x6ac8\n[f000:e05b]    0xfe05b: cmpl   $0x0,%cs:0x6ac8\n(gdb) si # 如果不相等，EIP(ip)赋值为0xfd2e1，即跳到0xfd2e1\n[f000:e062]    0xfe062: jne    0xfd2e1\n(gdb) si # 说明上面是相等的，清空%dx，\n\t\t # dx是data register，用于输入输出\n[f000:e066]    0xfe066: xor    %dx,%dx\n(gdb) si # 将ss也清零，\n\t\t# ss是stack segment, 包括数据和procedure的返回地址\n[f000:e068]    0xfe068: mov    %dx,%ss\n(gdb) si # 将esp赋为$0x7000，\n\t\t # esp是stack pointer，包含了stack的offset value\n\t\t # ss:sp refers to be current position of data or address \n\t\t # within the program starck\n[f000:e06a]    0xfe06a: mov    $0x7000,%esp\n(gdb) si # 把edx赋为$0xf34c2，edx是dx的32-bit版本\n[f000:e070]    0xfe070: mov    $0xf34c2,%edx\n(gdb) si # 跳到0xfd15c\n[f000:e076]    0xfe076: jmp    0xfd15c\n(gdb) si # 把eax付给ecx，\n\t\t # eax, primary accumulator，是用于most arithmetic instructions\n\t\t # ecx, count register，存储循环信息\n[f000:d15c]    0xfd15c: mov    %eax,%ecx\n(gdb) si # clear Interrupt Flag\n\t\t # IF, determines whether the external interrupts \n\t\t # like keyboard entry, etc., are to be ignored or processed \n[f000:d15f]    0xfd15f: cli\n(gdb) si # clear Direction Flag\n\t\t # determines left or right direction \n\t\t # for moving or comparing string data.\n[f000:d160]    0xfd160: cld\n(gdb) si # eax 赋为$0x8f\n[f000:d161]    0xfd161: mov    $0x8f,%eax\n(gdb) si # 从al输出到$0x70 port, al是ax的lower 8-bit\n[f000:d167]    0xfd167: out    %al,$0x70\n(gdb) si # 从$0x71 port输入到al, al是ax的lower 8-bit\n[f000:d169]    0xfd169: in     $0x71,%al\n...</code></pre></div>\n<p>对于register的名字对应的功能，可以看<a href=\"https://www.tutorialspoint.com/assembly_programming/assembly_registers.htm\">这里</a>。看了这么多行也没明白BIOS是要做什么。。。</p>\n<blockquote>\n<p>When the BIOS runs, it sets up an interrupt descriptor table and initializes various devices such as the VGA display. This is where the \"<code class=\"language-text\">Starting SeaBIOS</code>\" message you see in the QEMU window comes from.</p>\n</blockquote>\n<h2>Part 2: The Boot Loader</h2>\n<p>软盘(floppy)和硬盘(hard disk)均被分成了512B的区域，被称为sectors，sector是disk的最小单元，一次独写操作必须要使用一个或多个sector。如果disk bootable，那么其第一个sector被称为boot sector，因为boot coder code存于其中。当BIOS发现了一个bootable disk，就会读512B到内存中，其地址为0x7c00到0x7dff，之后用一个<code class=\"language-text\">jmp</code>指令将<code class=\"language-text\">CS:IP</code>设为<code class=\"language-text\">0000:7c00</code>，从而开始boot loading。不同于BIOS load address (<code class=\"language-text\">0xffff0</code>)，这个地址是相对可变的，不过现在已经标准化了。</p>\n<p>Boot一个CD-ROM有一些别的变化，详情可以阅读 <a href=\"https://pdos.csail.mit.edu/6.828/2018/readings/boot-cdrom.pdf\">\"El Torito\" Bootable CD-ROM Format Specification</a>。不过本课中，还是会把CD-ROM当成是一般的disk。</p>\n<p>Boot loader的代码主要存于，<code class=\"language-text\">boot/boot.s</code>, <code class=\"language-text\">boot/main.c</code>，注意看其中的注释。实际运行中是先运行boot.s</p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\"># boot/boot.s\n#include &lt;inc/mmu.h&gt;\n\n# Start the CPU: switch to 32-bit protected mode, jump into C.\n# The BIOS loads this code from the first sector of the hard disk into\n# memory at physical address 0x7c00 and starts executing in real mode\n# with %cs=0 %ip=7c00.\n\n.set PROT_MODE_CSEG, 0x8         # kernel code segment selector\n.set PROT_MODE_DSEG, 0x10        # kernel data segment selector\n.set CR0_PE_ON,      0x1         # protected mode enable flag\n\n.globl start\nstart:\n  .code16                     # Assemble for 16-bit mode\n  cli                         # Disable interrupts\n  cld                         # String operations increment\n\n  # Set up the important data segment registers (DS, ES, SS).\n  xorw    %ax,%ax             # Segment number zero\n  movw    %ax,%ds             # -&gt; Data Segment\n  movw    %ax,%es             # -&gt; Extra Segment\n  movw    %ax,%ss             # -&gt; Stack Segment\n\n  # Enable A20:\n  #   For backwards compatibility with the earliest PCs, physical\n  #   address line 20 is tied low, so that addresses higher than\n  #   1MB wrap around to zero by default.  This code undoes this.\nseta20.1:\n  inb     $0x64,%al               # Wait for not busy\n  testb   $0x2,%al  # perform a bitwise AND and put in a flag\n  jnz     seta20.1  # jump if not zero\n\n  movb    $0xd1,%al               # 0xd1 -&gt; port 0x64\n  outb    %al,$0x64\n\nseta20.2:\n  inb     $0x64,%al               # Wait for not busy\n  testb   $0x2,%al\n  jnz     seta20.2\n\n  movb    $0xdf,%al               # 0xdf -&gt; port 0x60\n  outb    %al,$0x60\n\n  # Switch from real to protected mode, using a bootstrap GDT\n  # and segment translation that makes virtual addresses \n  # identical to their physical addresses, so that the \n  # effective memory map does not change during the switch.\n  lgdt    gdtdesc\n  movl    %cr0, %eax\n  orl     $CR0_PE_ON, %eax\n  movl    %eax, %cr0\n  \n  # Jump to next instruction, but in 32-bit code segment.\n  # Switches processor into 32-bit mode.\n  ljmp    $PROT_MODE_CSEG, $protcseg\n\n  .code32                     # Assemble for 32-bit mode\nprotcseg:\n  # Set up the protected-mode data segment registers\n  movw    $PROT_MODE_DSEG, %ax    # Our data segment selector\n  movw    %ax, %ds                # -&gt; DS: Data Segment\n  movw    %ax, %es                # -&gt; ES: Extra Segment\n  movw    %ax, %fs                # -&gt; FS\n  movw    %ax, %gs                # -&gt; GS\n  movw    %ax, %ss                # -&gt; SS: Stack Segment\n  \n  # Set up the stack pointer and call into C.\n  movl    $start, %esp\n  call bootmain\n\n  # If bootmain returns (it shouldn&#39;t), loop.\nspin:\n  jmp spin\n\n# Bootstrap GDT\n.p2align 2                                # force 4 byte alignment\ngdt:\n  SEG_NULL\t\t\t\t# null seg\n  SEG(STA_X|STA_R, 0x0, 0xffffffff)\t# code seg\n  SEG(STA_W, 0x0, 0xffffffff)\t        # data seg\n\ngdtdesc:\n  .word   0x17                            # sizeof(gdt) - 1\n  .long   gdt                             # address gdt</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// boot/main.c</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;inc/x86.h></span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;inc/elf.h></span></span>\n\n<span class=\"token comment\">/**********************************************************************\n * This a dirt simple boot loader, whose sole job is to boot\n * an ELF kernel image from the first IDE hard disk.\n *\n * DISK LAYOUT\n *  * This program(boot.S and main.c) is the bootloader.  It should\n *    be stored in the first sector of the disk.\n *\n *  * The 2nd sector onward holds the kernel image.\n *\n *  * The kernel image must be in ELF format.\n *\n * BOOT UP STEPS\n *  * when the CPU boots it loads the BIOS into memory and executes it\n *\n *  * the BIOS intializes devices, sets of the interrupt routines, and\n *    reads the first sector of the boot device(e.g., hard-drive)\n *    into memory and jumps to it.\n *\n *  * Assuming this boot loader is stored in the first sector of the\n *    hard-drive, this code takes over...\n *\n *  * control starts in boot.S -- which sets up protected mode,\n *    and a stack so C code then run, then calls bootmain()\n *\n *  * bootmain() in this file takes over, reads in the kernel and jumps to it.\n **********************************************************************/</span>\n\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> SECTSIZE\t512</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> ELFHDR\t\t((struct Elf *) 0x10000) </span><span class=\"token comment\">// scratch space</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">readsect</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token operator\">*</span><span class=\"token punctuation\">,</span> uint32_t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">readseg</span><span class=\"token punctuation\">(</span>uint32_t<span class=\"token punctuation\">,</span> uint32_t<span class=\"token punctuation\">,</span> uint32_t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span>\n<span class=\"token function\">bootmain</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">Proghdr</span> <span class=\"token operator\">*</span>ph<span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>eph<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token comment\">// read 1st page off disk</span>\n\t<span class=\"token function\">readseg</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>uint32_t<span class=\"token punctuation\">)</span> ELFHDR<span class=\"token punctuation\">,</span> SECTSIZE<span class=\"token operator\">*</span><span class=\"token number\">8</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token comment\">// is this a valid ELF?</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ELFHDR<span class=\"token operator\">-></span>e_magic <span class=\"token operator\">!=</span> ELF_MAGIC<span class=\"token punctuation\">)</span>\n\t\t<span class=\"token keyword\">goto</span> bad<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token comment\">// load each program segment (ignores ph flags)</span>\n\tph <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">Proghdr</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>uint8_t <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> ELFHDR <span class=\"token operator\">+</span> ELFHDR<span class=\"token operator\">-></span>e_phoff<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\teph <span class=\"token operator\">=</span> ph <span class=\"token operator\">+</span> ELFHDR<span class=\"token operator\">-></span>e_phnum<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span> ph <span class=\"token operator\">&lt;</span> eph<span class=\"token punctuation\">;</span> ph<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n\t\t<span class=\"token comment\">// p_pa is the load address of this segment (as well</span>\n\t\t<span class=\"token comment\">// as the physical address)</span>\n\t\t<span class=\"token function\">readseg</span><span class=\"token punctuation\">(</span>ph<span class=\"token operator\">-></span>p_pa<span class=\"token punctuation\">,</span> ph<span class=\"token operator\">-></span>p_memsz<span class=\"token punctuation\">,</span> ph<span class=\"token operator\">-></span>p_offset<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token comment\">// call the entry point from the ELF header</span>\n\t<span class=\"token comment\">// note: does not return!</span>\n\t<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>ELFHDR<span class=\"token operator\">-></span>e_entry<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nbad<span class=\"token operator\">:</span>\n\t<span class=\"token function\">outw</span><span class=\"token punctuation\">(</span><span class=\"token number\">0x8A00</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0x8A00</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">outw</span><span class=\"token punctuation\">(</span><span class=\"token number\">0x8A00</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0x8E00</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n\t\t<span class=\"token comment\">/* do nothing */</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.</span>\n<span class=\"token comment\">// Might copy more than asked</span>\n<span class=\"token keyword\">void</span>\n<span class=\"token function\">readseg</span><span class=\"token punctuation\">(</span>uint32_t pa<span class=\"token punctuation\">,</span> uint32_t count<span class=\"token punctuation\">,</span> uint32_t offset<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\tuint32_t end_pa<span class=\"token punctuation\">;</span>\n\n\tend_pa <span class=\"token operator\">=</span> pa <span class=\"token operator\">+</span> count<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token comment\">// round down to sector boundary</span>\n\tpa <span class=\"token operator\">&amp;=</span> <span class=\"token operator\">~</span><span class=\"token punctuation\">(</span>SECTSIZE <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token comment\">// translate from bytes to sectors, and kernel starts at sector 1</span>\n\toffset <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>offset <span class=\"token operator\">/</span> SECTSIZE<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token comment\">// If this is too slow, we could read lots of sectors at a time.</span>\n\t<span class=\"token comment\">// We'd write more to memory than asked, but it doesn't matter --</span>\n\t<span class=\"token comment\">// we load in increasing order.</span>\n\t<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>pa <span class=\"token operator\">&lt;</span> end_pa<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token comment\">// Since we haven't enabled paging yet and we're using</span>\n\t\t<span class=\"token comment\">// an identity segment mapping (see boot.S), we can</span>\n\t\t<span class=\"token comment\">// use physical addresses directly.  This won't be the</span>\n\t\t<span class=\"token comment\">// case once JOS enables the MMU.</span>\n\t\t<span class=\"token function\">readsect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>uint8_t<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> pa<span class=\"token punctuation\">,</span> offset<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\tpa <span class=\"token operator\">+=</span> SECTSIZE<span class=\"token punctuation\">;</span>\n\t\toffset<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span>\n<span class=\"token function\">waitdisk</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\t<span class=\"token comment\">// wait for disk reaady</span>\n\t<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token function\">inb</span><span class=\"token punctuation\">(</span><span class=\"token number\">0x1F7</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;</span> <span class=\"token number\">0xC0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token number\">0x40</span><span class=\"token punctuation\">)</span>\n\t\t<span class=\"token comment\">/* do nothing */</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span>\n<span class=\"token function\">readsect</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>dst<span class=\"token punctuation\">,</span> uint32_t offset<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\t<span class=\"token comment\">// wait for disk to be ready</span>\n\t<span class=\"token function\">waitdisk</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token function\">outb</span><span class=\"token punctuation\">(</span><span class=\"token number\">0x1F2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t\t<span class=\"token comment\">// count = 1</span>\n\t<span class=\"token function\">outb</span><span class=\"token punctuation\">(</span><span class=\"token number\">0x1F3</span><span class=\"token punctuation\">,</span> offset<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">outb</span><span class=\"token punctuation\">(</span><span class=\"token number\">0x1F4</span><span class=\"token punctuation\">,</span> offset <span class=\"token operator\">>></span> <span class=\"token number\">8</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">outb</span><span class=\"token punctuation\">(</span><span class=\"token number\">0x1F5</span><span class=\"token punctuation\">,</span> offset <span class=\"token operator\">>></span> <span class=\"token number\">16</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">outb</span><span class=\"token punctuation\">(</span><span class=\"token number\">0x1F6</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>offset <span class=\"token operator\">>></span> <span class=\"token number\">24</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">|</span> <span class=\"token number\">0xE0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">outb</span><span class=\"token punctuation\">(</span><span class=\"token number\">0x1F7</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0x20</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\">// cmd 0x20 - read sectors</span>\n\n\t<span class=\"token comment\">// wait for disk to be ready</span>\n\t<span class=\"token function\">waitdisk</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token comment\">// read a sector</span>\n\t<span class=\"token function\">insl</span><span class=\"token punctuation\">(</span><span class=\"token number\">0x1F0</span><span class=\"token punctuation\">,</span> dst<span class=\"token punctuation\">,</span> SECTSIZE<span class=\"token operator\">/</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>上面的注释比较好的解释了这两段代码的意思。boot loader主要进行两件事，</p>\n<ol>\n<li>把processor从<a href=\"https://en.wikipedia.org/wiki/Real_mode\">real mode</a>变为<a href=\"https://wiki.osdev.org/Protected_Mode\">32-bit protected mode</a>，主要是offset从16位被扩充为32位，从而使offset能都达到4GB，同时segments被分为4K-sized unit称为pages，这意味着only parts of segment may be in memory at any one time。简单来说，就是从segmented address (segment: offset)转化为物理地址的方式不同了。</li>\n<li>boot loader reads the kernel from the hard disk by directly accessing the IDE disk device registers via the x86's special I/O instructions.和如何写驱动有关，本课不进行深入探讨。</li>\n</ol>\n<p>上面的两个文件组成的boot loader的disassembly在<code class=\"language-text\">obj/boot/boot.asm</code>。</p>\n<h3>Exercise 3</h3>\n<ul>\n<li>GDB commands</li>\n</ul>\n<p><code class=\"language-text\">Ctrl-c</code>: Halt the machine and break in to GDB at the current instruction. If QEMU has multiple virtual CPUs, this halts all of them.</p>\n<p><code class=\"language-text\">c</code> (or <code class=\"language-text\">continue</code>): Continue execution until the next breakpoint or <code class=\"language-text\">Ctrl-c</code>.</p>\n<p><code class=\"language-text\">si</code> (or <code class=\"language-text\">stepi</code>): Execute one machine instruction.</p>\n<p><code class=\"language-text\">b function</code> or <code class=\"language-text\">b file:line</code> (or <code class=\"language-text\">breakpoint</code>): Set a breakpoint at the given function or line.</p>\n<p><code class=\"language-text\">b *addr</code> (or <code class=\"language-text\">breakpoint</code>): Set a breakpoint at the EIP <em>addr</em>.</p>\n<p><code class=\"language-text\">set print pretty</code>: Enable pretty-printing of arrays and structs.</p>\n<p><code class=\"language-text\">info registers</code>: Print the general purpose registers, <code class=\"language-text\">eip</code>, <code class=\"language-text\">eflags</code>, and the segment selectors. For a much more thorough dump of the machine register state, see QEMU's own <code class=\"language-text\">info registers</code> command.</p>\n<p><code class=\"language-text\">x/Nx addr</code>: Display a hex dump of <em>N</em> words starting at virtual address <em>addr</em>. If <em>N</em> is omitted, it defaults to 1. <em>addr</em> can be any expression. (注意 word 的大小并不统一. In GNU assembly, a word is two bytes)</p>\n<p><code class=\"language-text\">x/Ni addr</code>: Display the <em>N</em> assembly instructions starting at <em>addr</em>. Using <code class=\"language-text\">$eip</code> as <em>addr</em> will display the instructions at the current instruction pointer.</p>\n<p><code class=\"language-text\">symbol-file file</code>: (Lab 3+) Switch to symbol file <em>file</em>. When GDB attaches to QEMU, it has no notion of the process boundaries within the virtual machine, so we have to tell it which symbols to use. By default, we configure GDB to use the kernel symbol file, <code class=\"language-text\">obj/kern/kernel</code>. If the machine is running user code, say <code class=\"language-text\">hello.c</code>, you can switch to the hello symbol file using <code class=\"language-text\">symbol-file obj/user/hello</code>.</p>\n<p>QEMU represents each virtual CPU as a thread in GDB, so you can use all of GDB's thread-related commands to view or manipulate QEMU's virtual CPUs.</p>\n<p><code class=\"language-text\">thread n</code>: GDB focuses on one thread (i.e., CPU) at a time. This command switches that focus to thread <em>n</em>, numbered from zero.</p>\n<p><code class=\"language-text\">info threads</code>: List all threads (i.e., CPUs), including their state (active or halted) and what function they're in.</p>\n<p>If we set the breakpoint at 0x7c00, 也就是boot loader的入口，逐步执行就能看到运行<code class=\"language-text\">boot.s</code>文件了。</p>\n<p>对问题的解答：</p>\n<ul>\n<li>从哪里开始执行32-bit code? 哪里是16- to 32-bit mode的转换switch?</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\">(gdb) si\n[   0:7c2d] =&gt; 0x7c2d:  ljmp   $0x8,$0x7c32\n0x00007c2d in ?? ()\n(gdb) si\nThe target architecture is assumed to be i386\n=&gt; 0x7c32:      mov    $0x10,%ax\n0x00007c32 in ?? ()</code></pre></div>\n<p>对应于<code class=\"language-text\">boot.s</code>中的</p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\">ljmp    $PROT_MODE_CSEG, $protcseg</code></pre></div>\n<p>用一个长跳，重新给CS和IP赋值，转化为32位。（从这里的CS和IP的变量名可以看出来这里就是为了变成protect mode用的）</p>\n<ul>\n<li>boot loader的最后一个指令是什么？ 以及被夹在的kernel的第一个指令是什么？</li>\n</ul>\n<p>从<code class=\"language-text\">boot.asm</code>可以看出，<code class=\"language-text\">main.c</code>里面调用<code class=\"language-text\">((void (*)(void)) (ELFHDR-&gt;e_entry))();</code>在<code class=\"language-text\">0x7d6b</code>，可以直接跳过去</p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\">(gdb) c\nContinuing.\nThe target architecture is assumed to be i386\n=&gt; 0x7d6b:      call   *0x10018\n\nBreakpoint 2, 0x00007d6b in ?? ()\n(gdb) si\n=&gt; 0x10000c:    movw   $0x1234,0x472\n0x0010000c in ?? ()</code></pre></div>\n<p>最后一条是<code class=\"language-text\">call *0x10018</code>，注意这里带<code class=\"language-text\">*</code>的指absolute call，会直接跳到这个地址，和不带<code class=\"language-text\">*</code>的给IP或者IP和CS(long jump)不同。所以kernel的第一条指令是<code class=\"language-text\">movw   $0x1234,0x472</code>。</p>\n<ul>\n<li><em>Where</em> is the first instruction of the kernel?</li>\n</ul>\n<p>从上面显示是<code class=\"language-text\">0x10000c</code>，这个应该是IP的地址，所以应该和上面的<code class=\"language-text\">call *0x10018</code>不矛盾？</p>\n<ul>\n<li>How does the boot loader decide how many sectors it must read in order to fetch the entire kernel from disk? Where does it find this information?</li>\n</ul>\n<p>从<code class=\"language-text\">main.c</code>中的第一个segment，也就是<code class=\"language-text\">ELFHDR</code>中有变量<code class=\"language-text\">e_phnum</code>，其为前4096byte。（和ELF有关，下文会讲）。</p>\n<h3>Loading the Kernel</h3>\n<h3>Exercise 4</h3>\n<p>首先来回顾一下C的pointer。<code class=\"language-text\">pointers.c</code>的代码如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdlib.h></span></span>\n\n<span class=\"token keyword\">void</span>\n<span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> a<span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>b <span class=\"token operator\">=</span> <span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span><span class=\"token number\">16</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>c<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span>\n\t<span class=\"token comment\">// 输出a, b, c的地址</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"1: a = %p, b = %p, c = %p\\n\"</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    c <span class=\"token operator\">=</span> a<span class=\"token punctuation\">;</span> <span class=\"token comment\">// c和a[0]一个地址</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n\ta<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">100</span> <span class=\"token operator\">+</span> i<span class=\"token punctuation\">;</span>\n    c<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">200</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// c和a[0]都改为200</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"2: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\\n\"</span><span class=\"token punctuation\">,</span>\n\t   a<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    c<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">300</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// a[1]=300</span>\n    <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span>c <span class=\"token operator\">+</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token number\">301</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// a[2]=301</span>\n    <span class=\"token number\">3</span><span class=\"token punctuation\">[</span>c<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">302</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 这个第一次见，a[3]=302</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"3: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\\n\"</span><span class=\"token punctuation\">,</span>\n\t   a<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    c <span class=\"token operator\">=</span> c <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// c指向a[1]</span>\n    <span class=\"token operator\">*</span>c <span class=\"token operator\">=</span> <span class=\"token number\">400</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// a[1]=400</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"4: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\\n\"</span><span class=\"token punctuation\">,</span>\n\t   a<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    c <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> c <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// c指向a[1]向后1byte</span>\n    <span class=\"token operator\">*</span>c <span class=\"token operator\">=</span> <span class=\"token number\">500</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// c会污染a[1], a[2]</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"5: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\\n\"</span><span class=\"token punctuation\">,</span>\n\t   a<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    b <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> a <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// b指向a[1], a[0]向后4byte</span>\n    c <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> a <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// c指向a[0]向后1byte的地方</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"6: a = %p, b = %p, c = %p\\n\"</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">int</span>\n<span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> ac<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token operator\">*</span>av<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>唯一需要注意的是指针间的类型转换，可以参见<a href=\"https://stackoverflow.com/a/17260931/5163915\">这里</a>。<code class=\"language-text\">pointers.c</code>的输出如下，可以对照一下。</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ ./pointers\n1: a <span class=\"token operator\">=</span> 0x7fff93fab1e0, b <span class=\"token operator\">=</span> 0x55f7fc10c260, c <span class=\"token operator\">=</span> 0xf0b5ff\n2: a<span class=\"token punctuation\">[</span>0<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> 200, a<span class=\"token punctuation\">[</span>1<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> 101, a<span class=\"token punctuation\">[</span>2<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> 102, a<span class=\"token punctuation\">[</span>3<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> 103\n3: a<span class=\"token punctuation\">[</span>0<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> 200, a<span class=\"token punctuation\">[</span>1<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> 300, a<span class=\"token punctuation\">[</span>2<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> 301, a<span class=\"token punctuation\">[</span>3<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> 302\n4: a<span class=\"token punctuation\">[</span>0<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> 200, a<span class=\"token punctuation\">[</span>1<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> 400, a<span class=\"token punctuation\">[</span>2<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> 301, a<span class=\"token punctuation\">[</span>3<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> 302\n5: a<span class=\"token punctuation\">[</span>0<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> 200, a<span class=\"token punctuation\">[</span>1<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> 128144, a<span class=\"token punctuation\">[</span>2<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> 256, a<span class=\"token punctuation\">[</span>3<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> 302\n6: a <span class=\"token operator\">=</span> 0x7fff93fab1e0, b <span class=\"token operator\">=</span> 0x7fff93fab1e4, c <span class=\"token operator\">=</span> 0x7fff93fab1e1</code></pre></div>\n<p>为了理解<code class=\"language-text\">boot/main.c</code>，我们需要知道ELF是什么。ELF，全称Executable and Linkable Format，就是二进制编码的汇编指令。对于本课来说，需要知道ELF就是header with loading information加several program sections，每一个section都是需要被加载进内存的指定位置的code chunk。</p>\n<p>ELF header为固定长度，之后跟着一个可变长的program header。program header记录了program sections的信息。<code class=\"language-text\">intc/elf.h</code>表示了ELF header的C definition:</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token macro property\">#<span class=\"token directive keyword\">ifndef</span> JOS_INC_ELF_H</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> JOS_INC_ELF_H</span>\n\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> ELF_MAGIC 0x464C457FU\t</span><span class=\"token comment\">/* \"\\x7FELF\" in little endian */</span>\n\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">Elf</span> <span class=\"token punctuation\">{</span>\n\tuint32_t e_magic<span class=\"token punctuation\">;</span>\t<span class=\"token comment\">// must equal ELF_MAGIC</span>\n\tuint8_t e_elf<span class=\"token punctuation\">[</span><span class=\"token number\">12</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\tuint16_t e_type<span class=\"token punctuation\">;</span>\n\tuint16_t e_machine<span class=\"token punctuation\">;</span>\n\tuint32_t e_version<span class=\"token punctuation\">;</span>\n\tuint32_t e_entry<span class=\"token punctuation\">;</span>\n\tuint32_t e_phoff<span class=\"token punctuation\">;</span>\n\tuint32_t e_shoff<span class=\"token punctuation\">;</span>\n\tuint32_t e_flags<span class=\"token punctuation\">;</span>\n\tuint16_t e_ehsize<span class=\"token punctuation\">;</span>\n\tuint16_t e_phentsize<span class=\"token punctuation\">;</span>\n\tuint16_t e_phnum<span class=\"token punctuation\">;</span>\n\tuint16_t e_shentsize<span class=\"token punctuation\">;</span>\n\tuint16_t e_shnum<span class=\"token punctuation\">;</span>\n\tuint16_t e_shstrndx<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">Proghdr</span> <span class=\"token punctuation\">{</span>\n\tuint32_t p_type<span class=\"token punctuation\">;</span>\n\tuint32_t p_offset<span class=\"token punctuation\">;</span>\n\tuint32_t p_va<span class=\"token punctuation\">;</span>\n\tuint32_t p_pa<span class=\"token punctuation\">;</span>\n\tuint32_t p_filesz<span class=\"token punctuation\">;</span>\n\tuint32_t p_memsz<span class=\"token punctuation\">;</span>\n\tuint32_t p_flags<span class=\"token punctuation\">;</span>\n\tuint32_t p_align<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">Secthdr</span> <span class=\"token punctuation\">{</span>\n\tuint32_t sh_name<span class=\"token punctuation\">;</span>\n\tuint32_t sh_type<span class=\"token punctuation\">;</span>\n\tuint32_t sh_flags<span class=\"token punctuation\">;</span>\n\tuint32_t sh_addr<span class=\"token punctuation\">;</span>\n\tuint32_t sh_offset<span class=\"token punctuation\">;</span>\n\tuint32_t sh_size<span class=\"token punctuation\">;</span>\n\tuint32_t sh_link<span class=\"token punctuation\">;</span>\n\tuint32_t sh_info<span class=\"token punctuation\">;</span>\n\tuint32_t sh_addralign<span class=\"token punctuation\">;</span>\n\tuint32_t sh_entsize<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Values for Proghdr::p_type</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> ELF_PROG_LOAD\t\t1</span>\n\n<span class=\"token comment\">// Flag bits for Proghdr::p_flags</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> ELF_PROG_FLAG_EXEC\t1</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> ELF_PROG_FLAG_WRITE\t2</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> ELF_PROG_FLAG_READ\t4</span>\n\n<span class=\"token comment\">// Values for Secthdr::sh_type</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> ELF_SHT_NULL\t\t0</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> ELF_SHT_PROGBITS\t1</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> ELF_SHT_SYMTAB\t\t2</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> ELF_SHT_STRTAB\t\t3</span>\n\n<span class=\"token comment\">// Values for Secthdr::sh_name</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> ELF_SHN_UNDEF\t\t0</span>\n\n<span class=\"token macro property\">#<span class=\"token directive keyword\">endif</span> </span><span class=\"token comment\">/* !JOS_INC_ELF_H */</span></code></pre></div>\n<p>对于program section，我们关心如下内容：</p>\n<ul>\n<li><code class=\"language-text\">.text</code>: The program's executable instructions.</li>\n<li><code class=\"language-text\">.rodata</code>: 只读数据, 如C编译器生成的ASCII string constants. (尽管一般我们都not bother设置硬件为只读.)</li>\n<li><code class=\"language-text\">.data</code>: 保存程序的初始数据, 如被初始化了的全局变量 <code class=\"language-text\">int x = 5;</code></li>\n</ul>\n<p>当Linker计算程序的memory layout的时候，他会在<code class=\"language-text\">.data</code>后的<code class=\"language-text\">.bss</code>部分给未初始化的全局变量留下空间。由于C对未初始化的全局变量的值有定义，所以也不需要在<code class=\"language-text\">.bss</code>里存数据，Linker只会指向<code class=\"language-text\">.bss</code>里的空间，把数据设置为0必须由loader或program自己来做。</p>\n<p>检查kernel的ELF header：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ objdump -h obj/kern/kernel\n\nobj/kern/kernel:     <span class=\"token function\">file</span> <span class=\"token function\">format</span> elf32-i386\n\nSections:\nIdx Name          Size      VMA       LMA       File off  Algn\n  0 .text         000019e9  f0100000  00100000  00001000  2**4\n                  CONTENTS, ALLOC, LOAD, READONLY, CODE\n  1 .rodata       000006c0  f0101a00  00101a00  00002a00  2**5\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n  2 .stab         00003b95  f01020c0  001020c0  000030c0  2**2\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n  3 .stabstr      00001948  f0105c55  00105c55  00006c55  2**0\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n  4 .data         00009300  f0108000  00108000  00009000  2**12\n                  CONTENTS, ALLOC, LOAD, DATA\n  5 .got          00000008  f0111300  00111300  00012300  2**2\n                  CONTENTS, ALLOC, LOAD, DATA\n  6 .got.plt      0000000c  f0111308  00111308  00012308  2**2\n                  CONTENTS, ALLOC, LOAD, DATA\n  7 .data.rel.local 00001000  f0112000  00112000  00013000  2**12\n                  CONTENTS, ALLOC, LOAD, DATA\n  8 .data.rel.ro.local 00000044  f0113000  00113000  00014000  2**2\n                  CONTENTS, ALLOC, LOAD, DATA\n  9 .bss          00000648  f0113060  00113060  00014060  2**5\n                  CONTENTS, ALLOC, LOAD, DATA\n 10 .comment      0000002a  00000000  00000000  000146a8  2**0\n                  CONTENTS, READONLY</code></pre></div>\n<p>注意.text中的VMA (link address), LMA(load address)。</p>\n<p>LMA(load address)是该section该被load进内存的哪里。VMA(link address)则是这个section应该从哪里开始执行。大多时候，这两个东西是相同的，如</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ objdump -h obj/boot/boot.out\n\nobj/boot/boot.out:     <span class=\"token function\">file</span> <span class=\"token function\">format</span> elf32-i386\n\nSections:\nIdx Name          Size      VMA       LMA       File off  Algn\n  0 .text         00000186  00007c00  00007c00  00000074  2**2\n                  CONTENTS, ALLOC, LOAD, CODE\n  1 .eh_frame     000000a8  00007d88  00007d88  000001fc  2**2\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n  2 .stab         0000087c  00000000  00000000  000002a4  2**2\n                  CONTENTS, READONLY, DEBUGGING\n  3 .stabstr      00000925  00000000  00000000  00000b20  2**0\n                  CONTENTS, READONLY, DEBUGGING\n  4 .comment      0000002a  00000000  00000000  00001445  2**0\n                  CONTENTS, READONLY</code></pre></div>\n<p>boot loader用ELF program header来决定如何加载某个section。kernel的ELF program header可以通过如下防止查看：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ objdump -x obj/kern/kernel\n\nobj/kern/kernel:     <span class=\"token function\">file</span> <span class=\"token function\">format</span> elf32-i386\nobj/kern/kernel\narchitecture: i386, flags 0x00000112:\nEXEC_P, HAS_SYMS, D_PAGED\nstart address 0x0010000c\n\nProgram Header:\n    LOAD off    0x00001000 vaddr 0xf0100000 paddr 0x00100000 align 2**12\n         filesz 0x0000759d memsz 0x0000759d flags r-x\n    LOAD off    0x00009000 vaddr 0xf0108000 paddr 0x00108000 align 2**12\n         filesz 0x0000b6a8 memsz 0x0000b6a8 flags rw-\n   STACK off    0x00000000 vaddr 0x00000000 paddr 0x00000000 align 2**4\n         filesz 0x00000000 memsz 0x00000000 flags rwx\n\nSections:\nIdx Name          Size      VMA       LMA       File off  Algn\n  0 .text         000019e9  f0100000  00100000  00001000  2**4\n                  CONTENTS, ALLOC, LOAD, READONLY, CODE\n  1 .rodata       000006c0  f0101a00  00101a00  00002a00  2**5\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n  2 .stab         00003b95  f01020c0  001020c0  000030c0  2**2\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n  3 .stabstr      00001948  f0105c55  00105c55  00006c55  2**0\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n  4 .data         00009300  f0108000  00108000  00009000  2**12\n                  CONTENTS, ALLOC, LOAD, DATA\n  5 .got          00000008  f0111300  00111300  00012300  2**2\n                  CONTENTS, ALLOC, LOAD, DATA\n  6 .got.plt      0000000c  f0111308  00111308  00012308  2**2\n                  CONTENTS, ALLOC, LOAD, DATA\n  7 .data.rel.local 00001000  f0112000  00112000  00013000  2**12\n                  CONTENTS, ALLOC, LOAD, DATA\n  8 .data.rel.ro.local 00000044  f0113000  00113000  00014000  2**2\n                  CONTENTS, ALLOC, LOAD, DATA\n  9 .bss          00000648  f0113060  00113060  00014060  2**5\n                  CONTENTS, ALLOC, LOAD, DATA\n 10 .comment      0000002a  00000000  00000000  000146a8  2**0\n                  CONTENTS, READONLY\nSYMBOL TABLE:\nf0100000 l    d  .text  00000000 .text\nf0101a00 l    d  .rodata        00000000 .rodata\nf01020c0 l    d  .stab  00000000 .stab\nf0105c55 l    d  .stabstr       00000000 .stabstr\nf0108000 l    d  .data  00000000 .data\nf0111300 l    d  .got   00000000 .got\nf0111308 l    d  .got.plt       00000000 .got.plt\nf0112000 l    d  .data.rel.local        00000000 .data.rel.local\nf0113000 l    d  .data.rel.ro.local     00000000 .data.rel.ro.local\nf0113060 l    d  .bss   00000000 .bss\n00000000 l    d  .comment       00000000 .comment\n00000000 l    <span class=\"token function\">df</span> *ABS*  00000000 obj/kern/entry.o\nf010002f l       .text  00000000 relocated\nf010003e l       .text  00000000 spin\n00000000 l    <span class=\"token function\">df</span> *ABS*  00000000 entrypgdir.c\n00000000 l    <span class=\"token function\">df</span> *ABS*  00000000 init.c\n00000000 l    <span class=\"token function\">df</span> *ABS*  00000000 console.c\nf01001c0 l     F .text  0000001f serial_proc_data\nf01001df l     F .text  0000004b cons_intr\nf0113080 l     O .bss   00000208 cons\nf010022a l     F .text  00000132 kbd_proc_data\nf0113060 l     O .bss   00000004 shift.1338\nf0101bc0 l     O .rodata        00000100 shiftcode\n<span class=\"token punctuation\">..</span>.</code></pre></div>\n<p>注意上面的Program Headers部分，需要被加载进内存的是那些标记着LOAD的（后面的off我猜测应该是offset）。其他的一些信息有the virtual address (\"vaddr\"), the physical address (\"paddr\"), and the size of the loaded area (\"memsz\" and \"filesz\").</p>\n<p>回到<code class=\"language-text\">boot/main.c</code>，<code class=\"language-text\">ph-&gt;p_pa</code>保存了the segment's destination physical address（对于这个具体的例子，就是真实的物理地址）。</p>\n<p>BIOS从<code class=\"language-text\">0x7c00</code>加载loader，这也就是loader的load address(LMA)，这也是boot sector的执行地址，所以也是link address(VMA)。我们通过在<code class=\"language-text\">boot/Magefrag</code>里面设置<code class=\"language-text\">-Ttext 0x7c00</code>来让linker可以在生成的代码中给出正确的内存地址。</p>\n<h3>Exercise 5</h3>\n<p>如果改变<code class=\"language-text\">boot/Makefrag</code>里面的地址，如改成<code class=\"language-text\">0x7c04</code>，重新make，会直接报错：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ make qemu-nox\n***\n*** Use Ctrl-a x to exit qemu\n***\nqemu-system-i386 -nographic -drive file=obj/kern/kernel.img,index=0,media=disk,format=raw -serial mon:stdio -gdb tcp::26000 -D qemu.log\nEAX=00000011 EBX=00000000 ECX=00000000 EDX=00000080\nESI=00000000 EDI=00000000 EBP=00000000 ESP=00006f20\nEIP=00007c2d EFL=00000006 [-----P-] CPL=0 II=0 A20=1 SMM=0 HLT=0\nES =0000 00000000 0000ffff 00009300 DPL=0 DS16 [-WA]\nCS =0000 00000000 0000ffff 00009b00 DPL=0 CS16 [-RA]\nSS =0000 00000000 0000ffff 00009300 DPL=0 DS16 [-WA]\nDS =0000 00000000 0000ffff 00009300 DPL=0 DS16 [-WA]\nFS =0000 00000000 0000ffff 00009300 DPL=0 DS16 [-WA]\nGS =0000 00000000 0000ffff 00009300 DPL=0 DS16 [-WA]\nLDT=0000 00000000 0000ffff 00008200 DPL=0 LDT\nTR =0000 00000000 0000ffff 00008b00 DPL=0 TSS32-busy\nGDT=     00f7ba55 00000000\nIDT=     00000000 000003ff\nCR0=00000011 CR2=00000000 CR3=00000000 CR4=00000000\nDR0=00000000 DR1=00000000 DR2=00000000 DR3=00000000\nDR6=ffff0ff0 DR7=00000400\nEFER=0000000000000000\nTriple fault.  Halting for inspection via QEMU monitor.</code></pre></div>\n<p>改成<code class=\"language-text\">0xf7c04</code>会报不同的错：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">make</span> qemu-nox\n+ ld boot/boot\nobj/boot/boot.o:boot/boot.S:48:<span class=\"token punctuation\">(</span>.text+0x21<span class=\"token punctuation\">)</span>: relocation truncated to fit: R_386_16 against <span class=\"token variable\"><span class=\"token variable\">`</span>.text'\nobj/boot/boot.o:boot/boot.S:55:<span class=\"token punctuation\">(</span>.text+0x2e<span class=\"token punctuation\">)</span>: relocation truncated to fit: R_386_16 against <span class=\"token variable\">`</span></span>.text<span class=\"token string\">'\nboot/Makefrag:27: recipe for target '</span>obj/boot/boot' failed\nmake: *** <span class=\"token punctuation\">[</span>obj/boot/boot<span class=\"token punctuation\">]</span> Error 1</code></pre></div>\n<p>这里可能是因为直接指向BIOS去了？</p>\n<p>我们回头来看kernel。和boot loader不同，kernel的LMA和VMA不同，所以kernel是希望从low address开始加载，但是希望在high address执行。我们会在下一部分来研究这个问题。</p>\n<p>除了section information，还有一个<code class=\"language-text\">e_entry</code>很重要，其表示了the link address of the <em>entry point</em> in the program: the memory address in the program's text section at which the program should begin executing. You can see the entry point（这里没明白，是这个section的还是下个section的）</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ objdump -f obj/kern/kernel\n\nobj/kern/kernel:     <span class=\"token function\">file</span> <span class=\"token function\">format</span> elf32-i386\narchitecture: i386, flags 0x00000112:\nEXEC_P, HAS_SYMS, D_PAGED\nstart address 0x0010000c</code></pre></div>\n<p>这里的start address就是<code class=\"language-text\">e_entry</code>。</p>\n<h3>Exercise 6</h3>\n<p>在BIOS刚刚进入boot loader时：</p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\">Breakpoint 1, 0x00007c00 in ?? ()\n(gdb) x/8x 0x00100000\n0x100000:       0x00000000      0x00000000      0x00000000      0x00000000\n0x100010:       0x00000000      0x00000000      0x00000000      0x00000000</code></pre></div>\n<p>刚进kernel时：</p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\">0x0010000c in ?? ()\n(gdb) x/8x 0x00100000\n0x100000:       0x1badb002      0x00000000      0xe4524ffe      0x7205c766\n0x100010:       0x34000004      0x2000b812      0x220f0011      0xc0200fd8</code></pre></div>\n<p>不同在于进入kernel之前已经把kernel的内容load进内存了。</p>\n<h2>Part 3: The Kernel</h2>\n<h3>Using virtual memory to work around position dependence</h3>\n<p>前文提到过，bootloader的LMA和VMA是一样的，但是kernel的link address和load address非常不一样，其显示在<code class=\"language-text\">kern/kernel.ld</code>的最上面。</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\nSECTIONS\n<span class=\"token punctuation\">{</span>\n\t<span class=\"token comment\">/* Link the kernel at this address: \".\" means the current address */</span>\n\t<span class=\"token punctuation\">.</span> <span class=\"token operator\">=</span> <span class=\"token number\">0xF0100000</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token comment\">/* AT(...) gives the load address of this section, which tells\n\t   the boot loader where to load the kernel in physical memory */</span>\n\t<span class=\"token punctuation\">.</span>text <span class=\"token operator\">:</span> <span class=\"token function\">AT</span><span class=\"token punctuation\">(</span><span class=\"token number\">0x100000</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span>text <span class=\"token punctuation\">.</span>stub <span class=\"token punctuation\">.</span>text<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span> <span class=\"token punctuation\">.</span>gnu<span class=\"token punctuation\">.</span>linkonce<span class=\"token punctuation\">.</span>t<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></code></pre></div>\n<p>OS kernel经常会在非常高的虚拟内存部分运行比如<code class=\"language-text\">0xf0100000</code>，以把较低的部分留给用户程序。很多机器并没有到<code class=\"language-text\">0xf0100000</code>这么高的物理内存，所以我们会使用处理器的内存管理硬件来把虚拟内存映射到物理内存，而这个映射的物理内存是<code class=\"language-text\">0x00100000</code>（这也就是LMA，或者说是bootloader把kernel加载在的物理内存的起始地址）。所以即使link address（VMA）的虚拟内存足够高，但是仍然会被加载在1MB的地方，BIOS的正上面。</p>\n<p>事实上，下一个lab我们会把整个256MB的内存，从物理地址<code class=\"language-text\">0x00000000</code>到<code class=\"language-text\">0x0fffffff</code>映射到<code class=\"language-text\">0xf0000000</code>到<code class=\"language-text\">0xffffffff</code>。现在来说，我们仅仅映射了最初的4MB，而这个映射是在<code class=\"language-text\">kern/entrypgdir.c</code>硬编码的。当<code class=\"language-text\">kern/entry.S</code>设置<code class=\"language-text\">CR0_PG</code> flag的时候，memory inference就是物理地址（严格的讲，是线性地址，但是<code class=\"language-text\">boot/boot.S</code>设置了一个iddentity mapping，且我们将不会做出修改）。当<code class=\"language-text\">CR0_PG</code>被设置了之后，memory reference就将是虚拟内存了。<code class=\"language-text\">entry_pgdir</code> 把虚拟内存从 0xf0000000 到 0xf0400000 翻译成物理内存的 0x00000000 到 0x00400000, 同时把 0x00000000 到 0x00400000 也翻译成 0x00000000 到 0x00400000。因为我们还没有设置interrupt handling，任何不是这两个区间中的虚拟内存都会触发hardware exception。</p>\n<h3>Exercise 7</h3>\n<p>在还没有运行<code class=\"language-text\">movl %eax, %cr0</code>之前：</p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\">(gdb) x/1x 0x00100000\n0x100000:       0x1badb002\n(gdb) x/1x 0xf0100000\n0xf0100000 &lt;_start+4026531828&gt;: 0x00000000</code></pre></div>\n<p>运行之后：</p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\">(gdb) x/1x 0x00100000\n0x100000:       0x1badb002\n(gdb) x/1x 0xf0100000\n0xf0100000 &lt;_start+4026531828&gt;: 0x1badb002</code></pre></div>\n<p>这就表明了运行过之后，CPU进行了内存的重映射。</p>\n<h3>Formatted Printing to the Console</h3>\n<p>阅读<code class=\"language-text\">kern/printf.c</code>, <code class=\"language-text\">lib/printfmt.c</code>和<code class=\"language-text\">kern/console.c</code>。</p>\n<h3>Exercise 8</h3>\n<p>加入格式输出8进制数字。主要需要阅读的代码是<code class=\"language-text\">lib/printfmt.c</code>中的<code class=\"language-text\">vprintfmt</code>。只需要模仿上面的10进制就好了。</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// 从printf.c中，我们可以看出:</span>\n<span class=\"token comment\">// putch就是putchar，putdat是记录输出了多少符号，fmt是格式，ap就是格式对应的参数</span>\n<span class=\"token keyword\">void</span>\n<span class=\"token function\">vprintfmt</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>putch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">void</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>putdat<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>fmt<span class=\"token punctuation\">,</span> va_list ap<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">register</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>p<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 用register关键词提示compiler可以把其放入register</span>\n\t<span class=\"token keyword\">register</span> <span class=\"token keyword\">int</span> ch<span class=\"token punctuation\">,</span> err<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span> num<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> base<span class=\"token punctuation\">,</span> lflag<span class=\"token punctuation\">,</span> width<span class=\"token punctuation\">,</span> precision<span class=\"token punctuation\">,</span> altflag<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">char</span> padc<span class=\"token punctuation\">;</span> <span class=\"token comment\">// pad char</span>\n\n\t<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>ch <span class=\"token operator\">=</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> fmt<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token string\">'%'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// 如果和%没关系，直接输出</span>\n\t\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ch <span class=\"token operator\">==</span> <span class=\"token string\">'\\0'</span><span class=\"token punctuation\">)</span>\n\t\t\t\t<span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token function\">putch</span><span class=\"token punctuation\">(</span>ch<span class=\"token punctuation\">,</span> putdat<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n\n\t\t<span class=\"token comment\">// Process a %-escape sequence 注意每次都会重新初始化</span>\n\t\tpadc <span class=\"token operator\">=</span> <span class=\"token string\">' '</span><span class=\"token punctuation\">;</span>\n\t\twidth <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\t\tprecision <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\t\tlflag <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\t\taltflag <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\treswitch<span class=\"token operator\">:</span>\n\t\t<span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>ch <span class=\"token operator\">=</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> fmt<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n\t\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t\t\n\t\t<span class=\"token comment\">// unsigned decimal</span>\n\t\t<span class=\"token keyword\">case</span> <span class=\"token string\">'u'</span><span class=\"token operator\">:</span>\n\t\t\tnum <span class=\"token operator\">=</span> <span class=\"token function\">getuint</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>ap<span class=\"token punctuation\">,</span> lflag<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\tbase <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token keyword\">goto</span> number<span class=\"token punctuation\">;</span>\n\n\t\t<span class=\"token comment\">// (unsigned) octal</span>\n\t\t<span class=\"token keyword\">case</span> <span class=\"token string\">'o'</span><span class=\"token operator\">:</span>\n\t\t\t<span class=\"token comment\">// Replace this with your code.</span>\n\t\t\tnum <span class=\"token operator\">=</span> <span class=\"token function\">getuint</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>ap<span class=\"token punctuation\">,</span> lflag<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\tbase <span class=\"token operator\">=</span> <span class=\"token number\">8</span><span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token keyword\">goto</span> number<span class=\"token punctuation\">;</span>\n\n\t\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\n\t\t<span class=\"token comment\">// unrecognized escape sequence - just print it literally</span>\n\t\t<span class=\"token keyword\">default</span><span class=\"token operator\">:</span>\n\t\t\t<span class=\"token function\">putch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'%'</span><span class=\"token punctuation\">,</span> putdat<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>fmt<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span> fmt<span class=\"token punctuation\">[</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> <span class=\"token string\">'%'</span><span class=\"token punctuation\">;</span> fmt<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\">// 退回去...</span>\n\t\t\t\t<span class=\"token comment\">/* do nothing */</span><span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ol>\n<li>Explain the interface between <code class=\"language-text\">printf.c</code> and <code class=\"language-text\">console.c</code>. Specifically, what function does<code class=\"language-text\">console.c</code> export? How is this function used by <code class=\"language-text\">printf.c</code>?</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// printf.c</span>\n\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;inc/types.h></span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;inc/stdio.h></span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;inc/stdarg.h></span></span>\n\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span>\n<span class=\"token function\">putch</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> ch<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>cnt<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token function\">cputchar</span><span class=\"token punctuation\">(</span>ch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token operator\">*</span>cnt<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">int</span>\n<span class=\"token function\">vcprintf</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>fmt<span class=\"token punctuation\">,</span> va_list ap<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">int</span> cnt <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token function\">vprintfmt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>putch<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>cnt<span class=\"token punctuation\">,</span> fmt<span class=\"token punctuation\">,</span> ap<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">return</span> cnt<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">int</span>\n<span class=\"token function\">cprintf</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>fmt<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  <span class=\"token comment\">// 这里利用了variable length argument实现了可变参数</span>\n\tva_list ap<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> cnt<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token function\">va_start</span><span class=\"token punctuation\">(</span>ap<span class=\"token punctuation\">,</span> fmt<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tcnt <span class=\"token operator\">=</span> <span class=\"token function\">vcprintf</span><span class=\"token punctuation\">(</span>fmt<span class=\"token punctuation\">,</span> ap<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">va_end</span><span class=\"token punctuation\">(</span>ap<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">return</span> cnt<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">printf.c</code>调用了<code class=\"language-text\">cputchar</code></p>\n<ol start=\"2\">\n<li>解释<code class=\"language-text\">console.c</code>中的如下代码</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// console.h</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> CRT_ROWS\t25</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> CRT_COLS\t80</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> CRT_SIZE\t(CRT_ROWS * CRT_COLS)</span>\n\n<span class=\"token comment\">// console.c</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>crt_pos <span class=\"token operator\">>=</span> CRT_SIZE<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  <span class=\"token comment\">// 如果当前输出位置大于了一整篇的大小，那么就把最上面一行去掉</span>\n\t<span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">memmove</span><span class=\"token punctuation\">(</span>crt_buf<span class=\"token punctuation\">,</span> crt_buf <span class=\"token operator\">+</span> CRT_COLS<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>CRT_SIZE <span class=\"token operator\">-</span> CRT_COLS<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>uint16_t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> CRT_SIZE <span class=\"token operator\">-</span> CRT_COLS<span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> CRT_SIZE<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n\t\tcrt_buf<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0x0700</span> <span class=\"token operator\">|</span> <span class=\"token string\">' '</span><span class=\"token punctuation\">;</span>\n\tcrt_pos <span class=\"token operator\">-=</span> CRT_COLS<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ol start=\"3\">\n<li>Trace the execution of the following code step-by-step:</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> x <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> y <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> z <span class=\"token operator\">=</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">cprintf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"x %d, y %x, z %d\\n\"</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">,</span> z<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这部分不知道该怎么调用。。。</p>\n<ol start=\"4\">\n<li>\n<p>运行如下代码，并解释输出</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0x00646c72</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">cprintf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"H%x Wo%s\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">57616</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n</li>\n</ol>\n<p>同样是不知道该怎么运行。。。但是可以直接推算内容，<code class=\"language-text\">%x</code>是hexodecimal，57616对应为：<code class=\"language-text\">0xe110</code>，然后后面的string，会按照存储顺序，注意是little endian，也就是0x72, 0x6c, 0x64输出，也就是r, l, d。所以输出就是<code class=\"language-text\">He110 World</code>。注意这里用<code class=\"language-text\">&amp;i</code>是因为<code class=\"language-text\">%s</code>需要输入是指针。</p>\n<ol start=\"5\">\n<li>\n<p>解释如下代码输出：</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token function\">cprintf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"x=%d y=%d\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>会输出一个随机数，因为访问到了<code class=\"language-text\">var_list</code>里面没有使用的空间。</p>\n</li>\n<li>如果GCC convention改成了按照declaration order把参数推进栈，那么应该如何更改参数事之可以接受变长参数?</li>\n</ol>\n<p>变长参数是来自GCC的<code class=\"language-text\">stdarg.h</code>, 因为JOS中的<code class=\"language-text\">stdarg</code>看不懂...，所以这里用了Minix里的古老的<a href=\"http://www.doc.ic.ac.uk/~svb/oslab/Minix/usr/include/stdarg.h\">代码</a>，对这份代码再进行简化，就只有如下几行</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>va_list<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/* Amount of space required in an argument list for an arg of type TYPE.\n * TYPE may alternatively be an expression whose type is used.\n */</span>\n<span class=\"token comment\">// 这里进行了上取整，得到整数倍int size, 应该是因为gcc会进行align吧</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> __va_rounded_size(TYPE)  \\  </span>\n  <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">sizeof</span> <span class=\"token punctuation\">(</span>TYPE<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">sizeof</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token keyword\">sizeof</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">sizeof</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> va_start(AP, LASTARG) \\  </span><span class=\"token comment\">// LASTARG的地址加上LASTARG的大小就是var_list的地址</span>\n <span class=\"token punctuation\">(</span>AP <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;</span><span class=\"token punctuation\">(</span>LASTARG<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> __va_rounded_size <span class=\"token punctuation\">(</span>LASTARG<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">void</span> va_end <span class=\"token punctuation\">(</span>va_list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>          <span class=\"token comment\">/* Defined in gnulib */</span>\n\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> va_arg(AP, TYPE) \\  </span><span class=\"token comment\">// 每次往后取一个</span>\n <span class=\"token punctuation\">(</span>AP <span class=\"token operator\">+=</span> __va_rounded_size <span class=\"token punctuation\">(</span>TYPE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> \\\n  <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>TYPE <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>AP <span class=\"token operator\">-</span> __va_rounded_size <span class=\"token punctuation\">(</span>TYPE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>所以如果改成反方向的话，应该就要从最后一个参数往前加就好了，只需要更改<code class=\"language-text\">va_start</code>与<code class=\"language-text\">va_arg</code>里面的加号变减号，减号变加号就好。</p>\n<h3>Challenge</h3>\n<p>带颜色的print。我没什么兴趣，应该是要修改<code class=\"language-text\">printfmt</code>里面的<code class=\"language-text\">%c</code>。</p>\n<h3>The Stack</h3>\n<p>这部分会详尽讨论C语言的栈。</p>\n<h3>Exercise 9</h3>\n<p>kernel的栈是在哪里初始化的？以及栈的地址是什么？kernel是如何给栈保留空间的？</p>\n<p>kernel的初始化用的是如下的命令：</p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\"># Set the stack pointer\nmovl\t$(bootstacktop),%esp</code></pre></div>\n<p>其把<code class=\"language-text\">%esp</code>初始化为：</p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\">esp            0xf0110000       0xf0110000 &lt;entry_pgtable&gt;</code></pre></div>\n<p>而如何保留空间的在于<code class=\"language-text\">kern/entry.S</code>里的：</p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\">.data\n###################################################################\n# boot stack\n###################################################################\n\t.p2align\tPGSHIFT\t\t# force page alignment\n\t.globl\t\tbootstack\nbootstack:\n\t.space\t\tKSTKSIZE\n\t.globl\t\tbootstacktop   \nbootstacktop:</code></pre></div>\n<p>这里<code class=\"language-text\">.data</code>是会被自动初始化的数据，栈的大小就是<code class=\"language-text\">KSTKSIZE</code>了。stack指针指向<code class=\"language-text\">bootstacktop</code>也就是<code class=\"language-text\">.space</code>后面，或者说是地址更高的地方。</p>\n<h3>Exercise 10</h3>\n<p>在<code class=\"language-text\">test_backtrace</code>函数处加断点，每次被调用的时候都发生了什么？<code class=\"language-text\">test_backtrace</code>一次会push多少内容到栈中？他们都是什么？</p>\n<p>这个函数的代码位于<code class=\"language-text\">kern/init.c</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">void</span>\n<span class=\"token function\">test_backtrace</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token function\">cprintf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"entering test_backtrace %d\\n\"</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>x <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n\t\t<span class=\"token function\">test_backtrace</span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">else</span>\n\t\t<span class=\"token function\">mon_backtrace</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">cprintf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"leaving test_backtrace %d\\n\"</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span>\n<span class=\"token function\">i386_init</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token comment\">// Test the stack backtrace function (lab 1 only)</span>\n\t<span class=\"token function\">test_backtrace</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>所以不加断点也可以知道，每次输出了一个字符串。</p>\n<h3>Exercise 11</h3>\n<p>写一个<code class=\"language-text\">mon_traceback</code>函数，</p>\n<p>注意在C里面，<a href=\"https://stackoverflow.com/a/11598394/5163915\">指针+1实际上是+4</a>。</p>\n<p>主要利用的就是<code class=\"language-text\">%ebp</code>的上一个就是<code class=\"language-text\">%eip</code>，再往上就是参数，所以代码的结构是：</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span>\n<span class=\"token function\">mon_backtrace</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> argc<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token operator\">*</span>argv<span class=\"token punctuation\">,</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">Trapframe</span> <span class=\"token operator\">*</span>tf<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token function\">cprintf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Stack backtrace:\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    uint32_t ebp <span class=\"token operator\">=</span> <span class=\"token function\">read_ebp</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    uint32_t eip<span class=\"token punctuation\">;</span>\n    uint32_t <span class=\"token operator\">*</span>args<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">struct</span> <span class=\"token class-name\">Eipdebuginfo</span> info<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>ebp<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">cprintf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"  ebp %08x\"</span><span class=\"token punctuation\">,</span> ebp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        eip <span class=\"token operator\">=</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>uint32_t <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>ebp <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">cprintf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"  eip %08x\"</span><span class=\"token punctuation\">,</span> eip<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        args <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>uint32_t <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>ebp <span class=\"token operator\">+</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">cprintf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"  args\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;</span><span class=\"token number\">5</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">cprintf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\" %08x\"</span><span class=\"token punctuation\">,</span> args<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token function\">cprintf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        ebp <span class=\"token operator\">=</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>uint32_t <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>ebp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> flag <span class=\"token operator\">=</span> <span class=\"token function\">debuginfo_eip</span><span class=\"token punctuation\">(</span>eip<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>info<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>flag<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">cprintf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Error getting eip info!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">cprintf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"      %s:%d: \"</span><span class=\"token punctuation\">,</span> info<span class=\"token punctuation\">.</span>eip_file<span class=\"token punctuation\">,</span> info<span class=\"token punctuation\">.</span>eip_line<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">cprintf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%.*s\"</span><span class=\"token punctuation\">,</span> info<span class=\"token punctuation\">.</span>eip_fn_namelen<span class=\"token punctuation\">,</span> info<span class=\"token punctuation\">.</span>eip_fn_name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">cprintf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"+%d\\n\"</span><span class=\"token punctuation\">,</span> eip <span class=\"token operator\">-</span> info<span class=\"token punctuation\">.</span>eip_fn_addr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>后面关于<code class=\"language-text\">info</code>的部分利用了<code class=\"language-text\">kern/kdebug.c</code>中的<code class=\"language-text\">debuginfo_eip</code>函数，来提取文件名等内容，在这之中，需要加一下如何搜索到<code class=\"language-text\">ep_line</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">\t<span class=\"token comment\">// Search within [lline, rline] for the line number stab.</span>\n\t<span class=\"token comment\">// If found, set info->eip_line to the right line number.</span>\n\t<span class=\"token comment\">// If not found, return -1.</span>\n\t<span class=\"token comment\">//</span>\n\t<span class=\"token comment\">// Hint:</span>\n\t<span class=\"token comment\">//\tThere's a particular stabs type used for line numbers.</span>\n\t<span class=\"token comment\">//\tLook at the STABS documentation and &lt;inc/stab.h> to find</span>\n\t<span class=\"token comment\">//\twhich one.</span>\n\t<span class=\"token comment\">// Your code here.</span>\n    <span class=\"token function\">stab_binsearch</span><span class=\"token punctuation\">(</span>stabs<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>lline<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>rline<span class=\"token punctuation\">,</span> N_SLINE<span class=\"token punctuation\">,</span> addr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>lline <span class=\"token operator\">&lt;=</span> rline<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\tinfo<span class=\"token operator\">-></span>eip_line <span class=\"token operator\">=</span> stabs<span class=\"token punctuation\">[</span>lline<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>n_desc<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n\t\tinfo<span class=\"token operator\">-></span>eip_line <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span></code></pre></div>\n<p>注意，<code class=\"language-text\">N_SLINE</code>和选用<code class=\"language-text\">n_desc</code>都是参考的<code class=\"language-text\">inc/stab.h</code>。</p>\n<p>运行结果如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">make</span> qemu-nox\n<span class=\"token punctuation\">..</span>.\nStack backtrace:\n  ebp f010ff18  eip f0100078  args 00000000 00000000 00000000 f010004a f0111308\n      kern/init.c:18: test_backtrace+56\n  ebp f010ff38  eip f01000a1  args 00000000 00000001 f010ff78 f010004a f0111308\n      kern/init.c:16: test_backtrace+97\n  ebp f010ff58  eip f01000a1  args 00000001 00000002 f010ff98 f010004a f0111308\n      kern/init.c:16: test_backtrace+97\n  ebp f010ff78  eip f01000a1  args 00000002 00000003 f010ffb8 f010004a f0111308\n      kern/init.c:16: test_backtrace+97\n  ebp f010ff98  eip f01000a1  args 00000003 00000004 00000000 f010004a f0111308\n      kern/init.c:16: test_backtrace+97\n  ebp f010ffb8  eip f01000a1  args 00000004 00000005 00000000 f010004a f0111308\n      kern/init.c:16: test_backtrace+97\n  ebp f010ffd8  eip f01000f4  args 00000005 00001aac 00000640 00000000 00000000\n      kern/init.c:39: i386_init+78\n  ebp f010fff8  eip f010003e  args 00000003 00001003 00002003 00003003 00004003\n      kern/entry.S:83: <span class=\"token operator\">&lt;</span>unknown<span class=\"token operator\">></span>+0\n<span class=\"token punctuation\">..</span>.</code></pre></div>\n<h3>Exercise 12</h3>\n<p>把指令加入<code class=\"language-text\">monitor.c</code>使之能够作为命令运行：</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// monitor.c</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">Command</span> commands<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token punctuation\">{</span> <span class=\"token string\">\"help\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Display this list of commands\"</span><span class=\"token punctuation\">,</span> mon_help <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n\t<span class=\"token punctuation\">{</span> <span class=\"token string\">\"kerninfo\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Display information about the kernel\"</span><span class=\"token punctuation\">,</span> mon_kerninfo <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">{</span> <span class=\"token string\">\"backtrace\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Display function stack\"</span><span class=\"token punctuation\">,</span> mon_backtrace <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>之后的运行结果就是：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">K<span class=\"token operator\">></span> backtrace\nStack backtrace:\n  ebp f010ff58  eip f0100b17  args 00000001 f010ff80 00000000 f0100b7b f0100b2a\n      kern/monitor.c:148: monitor+332\n  ebp f010ffd8  eip f0100101  args 00000000 00001aac 00000640 00000000 00000000\n      kern/init.c:43: i386_init+91\n  ebp f010fff8  eip f010003e  args 00000003 00001003 00002003 00003003 00004003\n      kern/entry.S:83: <span class=\"token operator\">&lt;</span>unknown<span class=\"token operator\">></span>+0</code></pre></div>\n<p>这样就全部完成了lab1了，判一下成绩：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">running JOS: <span class=\"token punctuation\">(</span>1.3s<span class=\"token punctuation\">)</span>\n  printf: OK\n  backtrace count: OK\n  backtrace arguments: OK\n  backtrace symbols: OK\n  backtrace lines: OK\nScore: 50/50</code></pre></div>","frontmatter":{"title":"6.828 lab1 Booting a PC","date":"2019-02-12T13:51:00.000Z","tags":["OS","6.828"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/6.828-lab1/"}}}