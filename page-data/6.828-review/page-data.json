{"componentChunkName":"component---src-templates-blog-post-js","path":"/6.828-review/","webpackCompilationHash":"b675513abbbda0859f3e","result":{"data":{"markdownRemark":{"html":"<h2>Boot Loader</h2>\n<p>首先当机器启动的时候，会自动加载BIOS。BIOS会检查有无bootable disk，如果有的话，会加载其boot loader（实际上就是加载boot loader）的ELF，也就是boot loader对应的二进制文件。其位于第一个IDE disk的第一个sector，之后的sector就是kernel了。</p>\n<p>然后boot loader会首先把处理器从16位的real mode转化为32位的protected mode，然后读一个page进来，也就是读进来kernel的ELF header，通过其ELF header把kernel一个sector一个sector地读进来，然后跳转到kernel ELF header里面记录的入口，从而进入kernel。</p>\n<p>值得注意的是kernel和boot loader的ELF的不同。也就是kernel的LMA和VMA是不同的，也就是加载到内存的位置和开始运行的位置是不同的。这是因为kernel额VMA是虚拟地址，其实际映射是<code class=\"language-text\">0x00000000</code>到<code class=\"language-text\">0x0fffffff</code>映射到<code class=\"language-text\">0xf0000000</code>到<code class=\"language-text\">0xffffffff</code>。所以即使VMA是高地址的<code class=\"language-text\">0xf0100000</code>实际上运行的时候对应的物理地址还是<code class=\"language-text\">0x00100000</code>，也就是LMA对应的地址。</p>\n<h2>Isolation mechanism</h2>\n<p>kernel通过硬件机制辅助来进行process isolation。硬件上的user/kernel mode flag，在x86上叫CPL，是<code class=\"language-text\">%cs</code>的后两位，CPL=0就是kernel mode，=3就是user mode。通过给几个permissible kernel entry points来跳到kernel里面去，这样就可以防止在转换的时候用户可以破坏Kernel。</p>\n<p>对内存的隔离是利用address space，其目的是可以让每个进程有内存来访问自己的code，variables，heap，stack 并不访问其他的内存。</p>\n<h2>System Call</h2>\n<p>system call的具体流程如下：</p>\n<p>在xv6中，一个像shell这样的用户应用，会include <code class=\"language-text\">user.h</code>，这李忠定义了用户端能够使用的所有system call的函数。而这些函数的定义都在<code class=\"language-text\">usys.S</code>中，具体如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">#define SYSCALL(name) \\\n  .globl name; \\\n  name: \\\n    movl $SYS_ ## name, %eax; \\\n    int $T_SYSCALL; \\\n    ret</code></pre></div>\n<p>所以实际上，在shell中使用write函数，就是会在汇编中调用<code class=\"language-text\">int $T_SYSCALL</code>。</p>\n<p><code class=\"language-text\">int</code>会做的事情有：</p>\n<ul>\n<li>切换为kernel stack（调整esp）</li>\n<li>保存用户的register于kernel stack</li>\n<li>设置CPL=0</li>\n<li>让eip指向kernel-supplied vector。</li>\n</ul>\n<p>也就是会进入<code class=\"language-text\">vector.S</code>，找到对应<code class=\"language-text\">$T_SYSCALL</code>的部分，也就是：</p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\">.globl vector64\nvector64:\n  pushl $0\n  pushl $64\n  jmp alltraps</code></pre></div>\n<p>然后进入<code class=\"language-text\">trapasm.S</code>中的<code class=\"language-text\">alltraps</code>。<code class=\"language-text\">alltraps</code>先保存<code class=\"language-text\">int</code>没有保存的寄存器，再调用<code class=\"language-text\">trap</code>函数，其中保存的trapframe指针就是当前的<code class=\"language-text\">%esp</code>。</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">void</span>\n<span class=\"token function\">trap</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">trapframe</span> <span class=\"token operator\">*</span>tf<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>tf<span class=\"token operator\">-></span>trapno <span class=\"token operator\">==</span> T_SYSCALL<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token function\">myproc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-></span>killed<span class=\"token punctuation\">)</span>\n      <span class=\"token function\">exit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">myproc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-></span>tf <span class=\"token operator\">=</span> tf<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">syscall</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token function\">myproc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-></span>killed<span class=\"token punctuation\">)</span>\n      <span class=\"token function\">exit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></code></pre></div>\n<p>进入trap之后，发现如果是syscall，就调用<code class=\"language-text\">syscall()</code>，里面有个<code class=\"language-text\">switch</code>会选择对应编号的syscall。注意和<code class=\"language-text\">int</code>相对应，在返回的途中有一个<code class=\"language-text\">iret</code>，相当于是做<code class=\"language-text\">int</code>的逆操作，也就是恢复寄存器之类的。</p>\n<h2>Virtual Memory</h2>\n<p>CPU会用一个叫MMU的东西来进行地址的转换。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  CPU -&gt; MMU -&gt; RAM\n      VA     PA</code></pre></div>\n<p>软件只能通过VA进行load/store，而不能通过PA。</p>\n<p>kernel告诉MMU该如何进行这个mapping</p>\n<ul>\n<li>本质上，MMU里有一个表，key是VA, value是PA，这个表也就被称为page table</li>\n</ul>\n<p>MMU还可以限制用户能够使用哪些虚拟地址。</p>\n<p>一个page table里面有2^20个entry，被称为2^20个page table entry (PTE)。PTE的前20位就是实际上PA的前20位，其实也是PA对应的page的编号，这20位被称为physical page number (PPN)。后面的12位都是flag，记录了像PTE<em>P，PTE</em>U, PTE_W这样的entry状态。</p>\n<p>page table被存在RAM中，MMU会读取或存储PTE。</p>\n<p>但是2^20太大了，所以x86选择使用两层的结构。中间加入的一层称为page directory (PD)。PD也是一个array，其中每一个元素称为PDE。PDE的前20位也是PPN，这个PPN对应的page会存储一个小的page table，这个page table会指向1024个PTE。</p>\n<p>所以PD有1024个PDE，每个PDE指向一个page table，每个page table里面有1024个PTE，所以一共2^20个PTE。</p>\n<p>在寄存器<code class=\"language-text\">%cr3</code>中存储了PD的地址，MMU就是通过读<code class=\"language-text\">%cr3</code>来开始转化。这个转化为</p>\n<ol>\n<li>通过<code class=\"language-text\">%cr</code>找到PD的PA，从而加载PD</li>\n<li>用VA的前10位找到PDE，用PDE的PPN找到PT</li>\n<li>用VA的中间10位找到PTE</li>\n<li>用PTE的前20位加上VA的最后12位找到VA对应的PA。</li>\n</ol>","frontmatter":{"title":"6.828 总结","date":"2019-03-26T14:59:00.000Z","tags":["OS","6.828"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/6.828-review/"}}}