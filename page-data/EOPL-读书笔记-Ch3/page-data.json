{"componentChunkName":"component---src-templates-blog-post-js","path":"/EOPL-读书笔记-Ch3/","result":{"data":{"markdownRemark":{"html":"<p>继续看 EOPL。</p>\n<h2>Ch3 Expression</h2>\n<p>本章主要学习变量的 binding 和 scoping。</p>\n<h3>3.1 Specification and Implementation Strategy</h3>\n<p>我们的 specification 会以如下的方式呈现：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(value-of exp ρ) = val</code></pre></div>\n<p>我们的目标则是实现如下的工作流（图 3.1 a）：</p>\n<p><img src=\"https://i.loli.net/2021/05/06/OMXLxjolZHBSIVf.png\" alt=\"Figure 3.1\"></p>\n<p>parsing 的部分主要有 2 个阶段，scanning 和 parsing，scanning 就是把字符串转化为 token 的过程；parsing 则是将 token 序列组织为具体的程序结构。一般会用 parser generator 来构建前端。</p>\n<h3>3.2 LET: A Simple Language</h3>\n<h4>3.2.1 Specifying the Syntax</h4>\n<p>LET 的语法如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"lisp\"><pre class=\"language-lisp\"><code class=\"language-lisp\">Program :<span class=\"token lisp-property property\">:=</span> Expression\n            a-program <span class=\"token punctuation\">(</span><span class=\"token car\">exp1</span><span class=\"token punctuation\">)</span>\nExpression :<span class=\"token lisp-property property\">:=</span> Number\n               const-exp <span class=\"token punctuation\">(</span><span class=\"token car\">num</span><span class=\"token punctuation\">)</span>\nExpression :<span class=\"token lisp-property property\">:=</span> -<span class=\"token punctuation\">(</span><span class=\"token car\">Expression</span> , Expression<span class=\"token punctuation\">)</span>\n               diff-exp <span class=\"token punctuation\">(</span><span class=\"token car\">exp1</span> exp2<span class=\"token punctuation\">)</span>\nExpression :<span class=\"token lisp-property property\">:=</span> zero? <span class=\"token punctuation\">(</span><span class=\"token car\">Expression</span><span class=\"token punctuation\">)</span>\n               zero?-exp <span class=\"token punctuation\">(</span><span class=\"token car\">exp1</span><span class=\"token punctuation\">)</span>\nExpression :<span class=\"token lisp-property property\">:=</span> if Expression then Expression else Expression\n               if-exp <span class=\"token punctuation\">(</span><span class=\"token car\">exp1</span> exp2 exp3<span class=\"token punctuation\">)</span>\nExpression :<span class=\"token lisp-property property\">:=</span> Identifier\n               var-exp <span class=\"token punctuation\">(</span><span class=\"token car\">var</span><span class=\"token punctuation\">)</span>\nExpression :<span class=\"token lisp-property property\">:=</span> let Identifier = Expression in Expression\n               let-exp <span class=\"token punctuation\">(</span><span class=\"token car\">var</span> exp1 body<span class=\"token punctuation\">)</span></code></pre></div>\n<h4>3.2.2 Specification of Values</h4>\n<p>每个语言都有 2 个集合：express value 和 denoted value，前者是表达式可能的值，后者是 values bound to variables。</p>\n<p>对于本章的语言，express value 和 denoted value 一直相同，他们都是：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">ExpVal = Int + Bool\nDenVal = Int + Bool</code></pre></div>\n<p>Ch4 中会展现两者不太一样的语言。</p>\n<p>为了利用上述定义，我们还加入了如下的 interface：</p>\n<div class=\"gatsby-highlight\" data-language=\"lisp\"><pre class=\"language-lisp\"><code class=\"language-lisp\"><span class=\"token comment\">; constructor</span>\nnum-val : Int → ExpVal\nbool-val : Bool → ExpVal\n<span class=\"token comment\">; extractor</span>\nexpval->num : ExpVal → Int\nexpval->bool : ExpVal → Bool</code></pre></div>\n<p>这里我们认为 <code class=\"language-text\">expval->num</code> 和 <code class=\"language-text\">expval->bool</code> 可能是 undefined。</p>\n<h4>3.2.3 Environments</h4>\n<p>我们计划使用 2.2 中定义的 environment。enviroment 是一个函数，它的定义域是一个有限的变量集合，值域是 denoted value。我们还会使用如下的简写：</p>\n<ul>\n<li><code class=\"language-text\">ρ</code> 表示环境</li>\n<li><code class=\"language-text\">[]</code> 表示空环境</li>\n<li><code class=\"language-text\">[var=val]ρ</code> 表示 <code class=\"language-text\">(extend-env var val ρ)</code></li>\n<li><code class=\"language-text\">[var1=val1, var2=val2]ρ</code> 相当于 <code class=\"language-text\">[var1=val1]([var2=val2]ρ)</code></li>\n<li><code class=\"language-text\">[var1=val1, var2=val2, ...]</code> 表示环境中 <code class=\"language-text\">var1</code> 的值为 <code class=\"language-text\">val1</code>，<code class=\"language-text\">var2</code> 为 <code class=\"language-text\">val2</code> 以此类推</li>\n</ul>\n<h4>3.2.4 Specifying the Behavior of Expressions</h4>\n<p>从上面的语法来看，LET 语言有 6 个 expression 和 1 个 observer：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># constructors:</span>\nconst-exp <span class=\"token builtin class-name\">:</span> Int → Exp\nzero?-exp <span class=\"token builtin class-name\">:</span> Exp → Exp\nif-exp    <span class=\"token builtin class-name\">:</span> Exp × Exp × Exp → Exp\ndiff-exp  <span class=\"token builtin class-name\">:</span> Exp × Exp → Exp\nvar-exp   <span class=\"token builtin class-name\">:</span> Var → Exp\nlet-exp   <span class=\"token builtin class-name\">:</span> Var × Exp × Exp → Exp\n<span class=\"token comment\"># observer:</span>\nvalue-of  <span class=\"token builtin class-name\">:</span> Exp × Env → ExpVal</code></pre></div>\n<p>在实现语言之前，我们需要写下 specification for the behavior of these procedures：</p>\n<div class=\"gatsby-highlight\" data-language=\"lisp\"><pre class=\"language-lisp\"><code class=\"language-lisp\"><span class=\"token comment\">; value of constant is constant</span>\n<span class=\"token punctuation\">(</span><span class=\"token car\">value-of</span> <span class=\"token punctuation\">(</span><span class=\"token car\">const-exp</span> n<span class=\"token punctuation\">)</span> ρ<span class=\"token punctuation\">)</span> = <span class=\"token punctuation\">(</span><span class=\"token car\">num-val</span> n<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">; value of variable is determined by looking up the</span>\n<span class=\"token comment\">; variable in the environment</span>\n<span class=\"token punctuation\">(</span><span class=\"token car\">value-of</span> <span class=\"token punctuation\">(</span><span class=\"token car\">var-exp</span> var<span class=\"token punctuation\">)</span> ρ<span class=\"token punctuation\">)</span> = <span class=\"token punctuation\">(</span><span class=\"token car\">apply-env</span> ρ var<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">; value of a difference expression in some environment</span>\n<span class=\"token comment\">; is the difference between the value of the first</span>\n<span class=\"token comment\">; operand in that environment and the value of the</span>\n<span class=\"token comment\">; second operand in that environment.</span>\n<span class=\"token punctuation\">(</span><span class=\"token car\">value-of</span> <span class=\"token punctuation\">(</span><span class=\"token car\">diff-exp</span> exp1 exp2<span class=\"token punctuation\">)</span> ρ<span class=\"token punctuation\">)</span>\n= <span class=\"token punctuation\">(</span><span class=\"token car\">num-val</span>\n    <span class=\"token punctuation\">(</span><span class=\"token car\">-</span>\n      <span class=\"token punctuation\">(</span><span class=\"token car\">expval->num</span> <span class=\"token punctuation\">(</span><span class=\"token car\">value-of</span> exp1 ρ<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">(</span><span class=\"token car\">expval->num</span> <span class=\"token punctuation\">(</span><span class=\"token car\">value-of</span> exp2 ρ<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<h4>3.2.5 Specifying the Behavior of Programs</h4>\n<p>我们假设环境初始值为 <code class=\"language-text\">[i=1, v=5, x=10]</code>，所以 program 的值为：</p>\n<div class=\"gatsby-highlight\" data-language=\"lisp\"><pre class=\"language-lisp\"><code class=\"language-lisp\"><span class=\"token punctuation\">(</span><span class=\"token car\">value-of-program</span> exp<span class=\"token punctuation\">)</span>\n= <span class=\"token punctuation\">(</span><span class=\"token car\">value-of</span> exp <span class=\"token punctuation\">[</span>i=1<span class=\"token splice symbol variable\">,v=5</span><span class=\"token splice symbol variable\">,x=10</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></code></pre></div>\n<h4>3.2.6 Specifying Conditionals</h4>\n<p>下一步就是要引入 boolean。LET 语言的 boolean constructor 是 <code class=\"language-text\">zero?</code>，它的 specification 为：</p>\n<p><img src=\"https://i.loli.net/2021/05/06/9F2zQXy1LIA8Oqe.png\" alt=\"image.png\"></p>\n<p>而 <code class=\"language-text\">if</code> 的 specification 为：</p>\n<p><img src=\"https://i.loli.net/2021/05/06/IbxXeOl7qE8BdTh.png\" alt=\"image.png\"></p>\n<p>对于 if，equational specification 为：</p>\n<div class=\"gatsby-highlight\" data-language=\"lisp\"><pre class=\"language-lisp\"><code class=\"language-lisp\"><span class=\"token punctuation\">(</span><span class=\"token car\">value-of</span> <span class=\"token punctuation\">(</span><span class=\"token car\">if-exp</span> exp1 exp2 exp3<span class=\"token punctuation\">)</span> ρ<span class=\"token punctuation\">)</span>\n= <span class=\"token punctuation\">(</span><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token car\">expval->bool</span> <span class=\"token punctuation\">(</span><span class=\"token car\">value-of</span> exp1 ρ<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">(</span><span class=\"token car\">value-of</span> exp2 ρ<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">(</span><span class=\"token car\">value-of</span> exp3 ρ<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<h4>3.2.7 Specifying <code class=\"language-text\">let</code></h4>\n<p><code class=\"language-text\">let</code> 的变量类似于 <code class=\"language-text\">lambda</code> 的参数，是 bound 在 body 中的。</p>\n<p><img src=\"https://i.loli.net/2021/05/06/l6PLOUeycgdMBk3.png\"></p>\n<p>对应的等式为：</p>\n<div class=\"gatsby-highlight\" data-language=\"lisp\"><pre class=\"language-lisp\"><code class=\"language-lisp\"><span class=\"token punctuation\">(</span><span class=\"token car\">value-of</span> <span class=\"token punctuation\">(</span><span class=\"token car\">let-exp</span> var exp1 body<span class=\"token punctuation\">)</span> ρ<span class=\"token punctuation\">)</span>\n= <span class=\"token punctuation\">(</span><span class=\"token car\">value-of</span> body <span class=\"token punctuation\">[</span>var=<span class=\"token punctuation\">(</span><span class=\"token car\">value-of</span> exp1 ρ<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>ρ<span class=\"token punctuation\">)</span></code></pre></div>\n<h4>3.2.8 Implementing the Specification of LET</h4>\n<p>至此，我们已经有了全部语法的 specification，接下来就是去实现它了。具体实现书中已经写了，就不抄下来了。</p>\n<h3>3.3 PROC: A Language with Procedure</h3>\n<p>PROC 语言里面加上了定义函数。所以 express value 和 denote value 就变成了：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">ExpVal = Int + Bool + Proc\nDenVal = Int + Bool + Proc</code></pre></div>\n<p>还需要新加入创建以及调用函数的语法：</p>\n<div class=\"gatsby-highlight\" data-language=\"lisp\"><pre class=\"language-lisp\"><code class=\"language-lisp\">Expression :<span class=\"token lisp-property property\">:=</span> proc <span class=\"token punctuation\">(</span><span class=\"token car\">Identifier</span><span class=\"token punctuation\">)</span> Expression\n\t\t\t\t\t\t\t proc-exp <span class=\"token punctuation\">(</span><span class=\"token car\">var</span> body<span class=\"token punctuation\">)</span>\nExpression :<span class=\"token lisp-property property\">:=</span> <span class=\"token punctuation\">(</span><span class=\"token car\">Expression</span> Expression<span class=\"token punctuation\">)</span>\n\t\t\t\t\t\t\t call-exp <span class=\"token punctuation\">(</span><span class=\"token car\">rator</span> rand<span class=\"token punctuation\">)</span></code></pre></div>\n<p>由于加入了新的类型，所以我们需要新的 constructor <code class=\"language-text\">procedure</code>，用来创建函数和 extractor <code class=\"language-text\">expval->proc</code>，以及 observer <code class=\"language-text\">apply-procedure</code>，用来求值。并且我们会有以下的两个 specification:</p>\n<div class=\"gatsby-highlight\" data-language=\"lisp\"><pre class=\"language-lisp\"><code class=\"language-lisp\"><span class=\"token punctuation\">(</span><span class=\"token car\">value-of</span> <span class=\"token punctuation\">(</span><span class=\"token car\">proc-exp</span> var body<span class=\"token punctuation\">)</span> ρ<span class=\"token punctuation\">)</span>\n= <span class=\"token punctuation\">(</span><span class=\"token car\">proc-val</span> <span class=\"token punctuation\">(</span><span class=\"token car\">procedure</span> var body ρ<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token punctuation\">(</span><span class=\"token car\">value-of</span> <span class=\"token punctuation\">(</span><span class=\"token car\">call-exp</span> rator rand<span class=\"token punctuation\">)</span> ρ<span class=\"token punctuation\">)</span>\n= <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token car\">proc</span> <span class=\"token punctuation\">(</span><span class=\"token car\">expval->proc</span> <span class=\"token punctuation\">(</span><span class=\"token car\">value-of</span> rator ρ<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">(</span><span class=\"token car\">arg</span> <span class=\"token punctuation\">(</span><span class=\"token car\">value-of</span> rand ρ<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">(</span><span class=\"token car\">apply-procedure</span> proc arg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>最后，我们需要考虑 <code class=\"language-text\">apply-procedure</code> 是干啥用的：</p>\n<div class=\"gatsby-highlight\" data-language=\"lisp\"><pre class=\"language-lisp\"><code class=\"language-lisp\"><span class=\"token punctuation\">(</span><span class=\"token car\">apply-procedure</span> <span class=\"token punctuation\">(</span><span class=\"token car\">procedure</span> var body ρ<span class=\"token punctuation\">)</span> val<span class=\"token punctuation\">)</span>\n= <span class=\"token punctuation\">(</span><span class=\"token car\">value-of</span> body <span class=\"token punctuation\">[</span>var=val<span class=\"token punctuation\">]</span>ρ<span class=\"token punctuation\">)</span></code></pre></div>\n<h4>3.3.1 An Example</h4>\n<h4>3.3.2 Representing Procedure</h4>\n<p>如何实现 Procedure，可以直接看书。大致使用 closure 实现的。</p>\n<h3>3.4 LETREC: A Language with Recursive Procedures</h3>\n<p>LETREC 让我们可以定义可以递归的函数。由于目前我们的函数只有一个参数，所以我们把 <code class=\"language-text\">letrec</code> 能定义的函数限定在单参数。有了这个语法，我们就可以实现这样的函数：</p>\n<div class=\"gatsby-highlight\" data-language=\"lisp\"><pre class=\"language-lisp\"><code class=\"language-lisp\">letrec double<span class=\"token punctuation\">(</span><span class=\"token car\">x</span><span class=\"token punctuation\">)</span>\n       = if zero?<span class=\"token punctuation\">(</span><span class=\"token car\">x</span><span class=\"token punctuation\">)</span> then <span class=\"token number\">0</span> else -<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token car\">double</span> -<span class=\"token punctuation\">(</span><span class=\"token car\">x</span>,1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>, <span class=\"token number\">-2</span><span class=\"token punctuation\">)</span>\nin <span class=\"token punctuation\">(</span><span class=\"token car\">double</span> <span class=\"token number\">6</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>为了这个功能，我们要添加这样的语法：</p>\n<div class=\"gatsby-highlight\" data-language=\"lisp\"><pre class=\"language-lisp\"><code class=\"language-lisp\">Expression :<span class=\"token lisp-property property\">:=</span> letrec Identifier <span class=\"token punctuation\">(</span><span class=\"token car\">Identifier</span><span class=\"token punctuation\">)</span> = Expression in Expression\n               letrec-exp <span class=\"token punctuation\">(</span><span class=\"token car\">p-name</span> b-var p-body letrec-body<span class=\"token punctuation\">)</span></code></pre></div>\n<p>注意和 <code class=\"language-text\">let</code> 的区别在于 <code class=\"language-text\">let</code> 的等式左侧没有参数。</p>\n<p>而 <code class=\"language-text\">letrec</code> 的等式则也会通过递归的方式更新环境：</p>\n<div class=\"gatsby-highlight\" data-language=\"lisp\"><pre class=\"language-lisp\"><code class=\"language-lisp\"><span class=\"token punctuation\">(</span><span class=\"token car\">value-of</span>\n  <span class=\"token punctuation\">(</span><span class=\"token car\">letrec-exp</span> proc-name bound-var proc-body letrec-body<span class=\"token punctuation\">)</span>\n  ρ<span class=\"token punctuation\">)</span>\n= <span class=\"token punctuation\">(</span><span class=\"token car\">value-of</span>\n    letrec-body\n    <span class=\"token punctuation\">(</span><span class=\"token car\">extend-env-rec</span> proc-name bound-var proc-body ρ<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>上面这个等式相当于是把 <code class=\"language-text\">letrec</code> 做了啥这个问题转化为了 <code class=\"language-text\">extend-env-rec</code> 做了啥。因为 <code class=\"language-text\">apply-env</code> 是环境的唯一 observer，所以实际上我们只用考虑 <code class=\"language-text\">(apply-env ρ1 var)</code>（其中 <code class=\"language-text\">ρ1</code> 是 <code class=\"language-text\">extend-env-rec</code> 得到的环境）会返回什么就好了。</p>\n<p>自然，我们要分类讨论：</p>\n<ul>\n<li>\n<p>当 <code class=\"language-text\">var</code> 和 <code class=\"language-text\">proc-name</code> 相同，我们就可以直接取这个定义的函数。不过注意，在 <code class=\"language-text\">proc-body</code> 中仍然可能有 <code class=\"language-text\">proc-name</code> 出现，所以函数的 env 还得是 <code class=\"language-text\">ρ1</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"lisp\"><pre class=\"language-lisp\"><code class=\"language-lisp\"><span class=\"token punctuation\">(</span><span class=\"token car\">apply-env</span> ρ1 proc-name<span class=\"token punctuation\">)</span>\n= <span class=\"token punctuation\">(</span><span class=\"token car\">proc-val</span> <span class=\"token punctuation\">(</span><span class=\"token car\">procedure</span> bound-var proc-body ρ1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n</li>\n<li>\n<p>当 <code class=\"language-text\">var</code> 不是 <code class=\"language-text\">proc-name</code> 的时候，我们就可以忽略它：</p>\n<div class=\"gatsby-highlight\" data-language=\"lisp\"><pre class=\"language-lisp\"><code class=\"language-lisp\"><span class=\"token punctuation\">(</span><span class=\"token car\">apply-env</span> ρ1 var<span class=\"token punctuation\">)</span> = <span class=\"token punctuation\">(</span><span class=\"token car\">apply-env</span> ρ var<span class=\"token punctuation\">)</span></code></pre></div>\n</li>\n</ul>\n<p>至此，我们就给出了 <code class=\"language-text\">extend-env-rec</code> 的 specification，根据他们，我们就可以实现 LETREC 了。</p>\n<h3>3.5 Scoping and Binding of Variables</h3>\n<p>在大多数编程语言中，变量以两种形式出现：reference 和 declaration。我们称：variable reference is <em>bound by</em> the declaration with which it is associated, and that it is <em>bound to</em> its value.</p>\n<p>declaration 往往有 limited scope，从而让同一个变量名能够在不同地方担当不同的角色。决定每个 reference 指向哪个 declaration 的规则被称为 scoping rules。一个 declaration 保持 valid 的程序部分被称为该 declaration 的 scope。</p>\n<p>我们称 inner declaration shadow 了 outer ones。</p>\n<p>变量和值之间的联系关系称为 binding。对于我们实现的语言以及 scheme（Racket），每个 binding 的延续时间是不定长的，因为返回的值可能有闭包。我们称这种不定长为 semi-infinite extent。gc 只能在运行时判断一个 binding 是否不再 reachable，这种运行时才能决定的特性，我们称之为 dynamic property。</p>\n<h3>3.6 Eliminating Variable Names</h3>\n<p>每个 scope 被称为一个 contour，对于一个变量来说，相互交叉（重叠）的 contour 数量被称为其 lexical (or static) depth，该值一般以 0 为起始。例如：</p>\n<div class=\"gatsby-highlight\" data-language=\"lisp\"><pre class=\"language-lisp\"><code class=\"language-lisp\"><span class=\"token punctuation\">(</span><span class=\"token lambda\"><span class=\"token keyword\">lambda</span> <span class=\"token punctuation\">(</span><span class=\"token arguments\"><span class=\"token argument variable\">x</span></span><span class=\"token punctuation\">)</span></span>\n  <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token lambda\"><span class=\"token keyword\">lambda</span> <span class=\"token punctuation\">(</span><span class=\"token arguments\"><span class=\"token argument variable\">a</span></span><span class=\"token punctuation\">)</span></span>\n    <span class=\"token punctuation\">(</span><span class=\"token car\">x</span> a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>上式最后一行的 x 的 depth 为 0，第三行的 x 的 depth 为 1。利用这个值，我们就可以抛弃掉变量名，将上式表示为：</p>\n<div class=\"gatsby-highlight\" data-language=\"lisp\"><pre class=\"language-lisp\"><code class=\"language-lisp\"><span class=\"token punctuation\">(</span><span class=\"token car\">nameless-lambda</span>\n  <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token car\">nameless-lambda</span>\n    <span class=\"token punctuation\">(</span>#1 #0<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  #0<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>这里 <code class=\"language-text\">nameliss-lambda</code> 声明了一个匿名变量，而变量由其 lexical depth 表示。这些值也 uniquely identifies the declaration to which is refers。这些数被称为 lexical address 或 de Bruijn indices。编译器会周期性计算每个 reference 的 lexical address，从而丢掉变量名。</p>\n<p>这种表示方法可以 predict 特定的变量会在环境的哪个地方。例如：</p>\n<div class=\"gatsby-highlight\" data-language=\"lisp\"><pre class=\"language-lisp\"><code class=\"language-lisp\">let x = exp1\n  in let y = exp2\n  \tin -<span class=\"token punctuation\">(</span><span class=\"token car\">x</span><span class=\"token splice symbol variable\">,y</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>对这个 expression 求值，化简到最后会变成：</p>\n<div class=\"gatsby-highlight\" data-language=\"lisp\"><pre class=\"language-lisp\"><code class=\"language-lisp\"><span class=\"token punctuation\">(</span><span class=\"token car\">value-of</span>\n  &lt;&lt;let x = exp1\n    in let y = exp2\n      in -<span class=\"token punctuation\">(</span><span class=\"token car\">x</span><span class=\"token splice symbol variable\">,y</span><span class=\"token punctuation\">)</span>>>\n  ρ<span class=\"token punctuation\">)</span>\n=\n<span class=\"token punctuation\">(</span><span class=\"token car\">value-of</span>\n  &lt;&lt;-<span class=\"token punctuation\">(</span><span class=\"token car\">x</span><span class=\"token splice symbol variable\">,y</span><span class=\"token punctuation\">)</span>>>\n  <span class=\"token punctuation\">[</span>y=val2<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>x=val1<span class=\"token punctuation\">]</span>ρ<span class=\"token punctuation\">)</span></code></pre></div>\n<p>在最后的环境中， y 的位置为 0，x 的位置为 1，和他们的 lexical depth 相对应。</p>\n<h3>3.7 Implementing Lexical Addressing</h3>\n<p>我们来考虑如何实现上一节提到的 lexical address analysis。</p>\n<h4>3.7.1 The Translator</h4>\n<p>作为一个 translator，我们首先要明确 source language 和 target language。target language 自然是包含 <code class=\"language-text\">nameless-var-exp</code> 和 <code class=\"language-text\">nameless-let-exp</code> 这样的东西，并去掉了 source language 中有的 <code class=\"language-text\">var-exp</code> 和 <code class=\"language-text\">let-exp</code>。所以我们要加入下面的这几条语法：</p>\n<div class=\"gatsby-highlight\" data-language=\"lisp\"><pre class=\"language-lisp\"><code class=\"language-lisp\">Expression :<span class=\"token lisp-property property\">:=</span> %lexref number\n               nameless-var-exp <span class=\"token punctuation\">(</span><span class=\"token car\">num</span><span class=\"token punctuation\">)</span>\nExpression :<span class=\"token lisp-property property\">:=</span> %let Expression in Expression\n               nameless-let-exp <span class=\"token punctuation\">(</span><span class=\"token car\">exp1</span> body<span class=\"token punctuation\">)</span>\nExpression :<span class=\"token lisp-property property\">:=</span> %lexproc Expression\n               nameless-proc-exp <span class=\"token punctuation\">(</span><span class=\"token car\">body</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>对于我们要实现的 <code class=\"language-text\">translation-of</code> 函数，他需要当前的 scope 信息，也就是 context，所以需要有 2 个参数，expression 和一个 static environment。static environment 中会用变量的列表表示当前的 scope 信息，这个变量列表中的第一个元素会对应最内侧 scope 定义的变量。static environment 的实现如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"lisp\"><pre class=\"language-lisp\"><code class=\"language-lisp\"><span class=\"token comment\">; Senv = Listof(Sym)</span>\n<span class=\"token comment\">; Lexaddr = N</span>\n\n<span class=\"token comment\">; empty-senv : () → Senv</span>\n<span class=\"token punctuation\">(</span><span class=\"token car\">define</span> empty-senv\n  <span class=\"token punctuation\">(</span><span class=\"token lambda\"><span class=\"token keyword\">lambda</span> <span class=\"token punctuation\">(</span><span class=\"token arguments\"></span><span class=\"token punctuation\">)</span></span>\n    ’<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">;extend-senv : Var × Senv → Senv</span>\n<span class=\"token punctuation\">(</span><span class=\"token car\">define</span> extend-senv\n  <span class=\"token punctuation\">(</span><span class=\"token lambda\"><span class=\"token keyword\">lambda</span> <span class=\"token punctuation\">(</span><span class=\"token arguments\"><span class=\"token argument variable\">var</span> <span class=\"token argument variable\">senv</span></span><span class=\"token punctuation\">)</span></span>\n    <span class=\"token punctuation\">(</span><span class=\"token keyword\">cons</span> var senv<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">; apply-senv : Senv × Var → Lexaddr</span>\n<span class=\"token punctuation\">(</span><span class=\"token car\">define</span> apply-senv\n  <span class=\"token punctuation\">(</span><span class=\"token lambda\"><span class=\"token keyword\">lambda</span> <span class=\"token punctuation\">(</span><span class=\"token arguments\"><span class=\"token argument variable\">senv</span> <span class=\"token argument variable\">var</span></span><span class=\"token punctuation\">)</span></span>\n  <span class=\"token punctuation\">(</span><span class=\"token keyword\">cond</span>\n    <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token car\">null</span>? senv<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">(</span><span class=\"token car\">report-unbound-var</span> var<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token car\">eqv</span>? var <span class=\"token punctuation\">(</span><span class=\"token car\">car</span> senv<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">(</span><span class=\"token car\">else</span>\n      <span class=\"token punctuation\">(</span><span class=\"token car\">+</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">(</span><span class=\"token car\">apply-senv</span> <span class=\"token punctuation\">(</span><span class=\"token car\">cdr</span> senv<span class=\"token punctuation\">)</span> var<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>在实现过程中，实际上就是遍历并拷贝 AST，并做 3 处修改：</p>\n<ul>\n<li>遇到 <code class=\"language-text\">var-exp</code> 就换成 <code class=\"language-text\">nameless-var-exp</code>，并用 <code class=\"language-text\">apply-senv</code> 得到正确的 lexical address；</li>\n<li>遇到 <code class=\"language-text\">let-exp</code> 就换成 <code class=\"language-text\">nameless-let-exp</code>，然后把表达式用原来的 senv 更新，并把 body 用 <code class=\"language-text\">(extend-senv var senv)</code> 更新。</li>\n<li>遇到 <code class=\"language-text\">proc-exp</code> 就换成 <code class=\"language-text\">nameless-proc-exp</code>，然后把 body 用新 senv （ <code class=\"language-text\">(extend-senv var senv)</code> ）更新。</li>\n</ul>\n<h4>3.7.2 The Nameless Interpreter</h4>\n<p>我们需要的是一个 nameless environment。由于我们可以直接根据 index 去取值了，我们就可以用 list 来表示 enviroment，并用 <code class=\"language-text\">list_ref</code> 来进行取值：</p>\n<div class=\"gatsby-highlight\" data-language=\"lisp\"><pre class=\"language-lisp\"><code class=\"language-lisp\"><span class=\"token comment\">; nameless-environment? : SchemeVal → Bool</span>\n<span class=\"token punctuation\">(</span><span class=\"token car\">define</span> nameless-environment?\n  <span class=\"token punctuation\">(</span><span class=\"token lambda\"><span class=\"token keyword\">lambda</span> <span class=\"token punctuation\">(</span><span class=\"token arguments\"><span class=\"token argument variable\">x</span></span><span class=\"token punctuation\">)</span></span>\n    <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token car\">list-of</span> expval?<span class=\"token punctuation\">)</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">; empty-nameless-env : () → Nameless-env</span>\n<span class=\"token punctuation\">(</span><span class=\"token car\">define</span> empty-nameless-env\n  <span class=\"token punctuation\">(</span><span class=\"token lambda\"><span class=\"token keyword\">lambda</span> <span class=\"token punctuation\">(</span><span class=\"token arguments\"></span><span class=\"token punctuation\">)</span></span>\n    ’<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">; extend-nameless-env : ExpVal × Nameless-env → Nameless-env</span>\n<span class=\"token punctuation\">(</span><span class=\"token car\">define</span> extend-nameless-env\n  <span class=\"token punctuation\">(</span><span class=\"token lambda\"><span class=\"token keyword\">lambda</span> <span class=\"token punctuation\">(</span><span class=\"token arguments\"><span class=\"token argument variable\">val</span> <span class=\"token argument variable\">nameless-env</span></span><span class=\"token punctuation\">)</span></span>\n    <span class=\"token punctuation\">(</span><span class=\"token keyword\">cons</span> val nameless-env<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">; apply-nameless-env : Nameless-env × Lexaddr → ExpVal</span>\n<span class=\"token punctuation\">(</span><span class=\"token car\">define</span> apply-nameless-env\n  <span class=\"token punctuation\">(</span><span class=\"token lambda\"><span class=\"token keyword\">lambda</span> <span class=\"token punctuation\">(</span><span class=\"token arguments\"><span class=\"token argument variable\">nameless-env</span> <span class=\"token argument variable\">n</span></span><span class=\"token punctuation\">)</span></span>\n    <span class=\"token punctuation\">(</span><span class=\"token car\">list-ref</span> nameless-env n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>有了这个新的 environment，简单调整一下其他函数，就可以实现 nameless interpreter 了。</p>\n<h2>感悟</h2>\n<p>第二遍看 eopl 的 Ch3 和第一遍的感受上有明显的区别：第一遍的时候因为非常不熟悉 Racket，所以把重点放在了具体的实现上，实际上属于只见树木不见森林；第二遍的感觉就是，通过明确的逻辑推导，会很自然地写出语法的 specification，后面的实现就会变得非常 trivial。</p>","frontmatter":{"title":"EOPL 读书笔记 Ch3","date":"2021-05-05T23:41:00.000Z","tags":["PL"]}}},"pageContext":{"slug":"/EOPL-读书笔记-Ch3/"}},"staticQueryHashes":["3159585216"]}