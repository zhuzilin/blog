{"componentChunkName":"component---src-templates-blog-post-js","path":"/6.828-hw-boot-xv6/","result":{"data":{"markdownRemark":{"html":"<h2>Boot xv6</h2>\n<p>没什么需要做的，都在配置的那片里面介绍过了。</p>\n<h2>Finding and breaking at an address</h2>\n<p>首先按照要求，运行：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ nm kernel <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> _start\n8010a48c D _binary_entryother_start\n8010a460 D _binary_initcode_start\n0010000c T _start</code></pre></div>\n<p>查manul可以知道，nm的作用是GNU nm lists the symbols from object files objfile. 所以上面的指令就是找到symbol表中含有<code class=\"language-text\">_start</code>的地方。对<code class=\"language-text\">_start</code>处设置断点，并运行到这个位置。注意加了断点之后的状态是还没运行这一行的状态！</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> br * 0x0010000c\nBreakpoint <span class=\"token number\">1</span> at 0x10000c\n<span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> c\nContinuing.\nThe target architecture is assumed to be i386\n<span class=\"token operator\">=</span><span class=\"token operator\">></span> 0x10000c:\tmov    %cr4,%eax</code></pre></div>\n<ul>\n<li>exercise: 栈上都有什么？</li>\n</ul>\n<p>如下是寄存器存有的信息：</p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\">(gdb) info reg\neax            0x0      0\necx            0x0      0\nedx            0x1f0    496\nebx            0x10074  65652\nesp            0x7bdc   0x7bdc\nebp            0x7bf8   0x7bf8\nesi            0x10074  65652\nedi            0x0      0\neip            0x10000c 0x10000c\neflags         0x46     [ PF ZF ]\ncs             0x8      8\nss             0x10     16\nds             0x10     16\nes             0x10     16\nfs             0x0      0\ngs             0x0      0</code></pre></div>\n<p>寄存器的信息为：</p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\">(gdb) x/24x $esp\n0x7bdc: 0x00007d8d      0x00000000      0x00000000      0x00000000\n0x7bec: 0x00000000      0x00000000      0x00000000      0x00000000\n0x7bfc: 0x00007c4d      0x8ec031fa      0x8ec08ed8      0xa864e4d0\n0x7c0c: 0xb0fa7502      0xe464e6d1      0x7502a864      0xe6dfb0fa\n0x7c1c: 0x16010f60      0x200f7c78      0xc88366c0      0xc0220f01\n0x7c2c: 0x087c31ea      0x10b86600      0x8ed88e00      0x66d08ec0</code></pre></div>\n<p>我们的任务是判断哪些部分是真正的栈，且分别是什么意思。</p>\n<p>我们从<code class=\"language-text\">0x7c00</code>开始重新运行程序，在最开始的时候，寄存器的信息是：</p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\">(gdb) info reg\neax            0xaa55   43605\necx            0x0      0\nedx            0x80     128\nebx            0x0      0\nesp            0x6f20   0x6f20\nebp            0x0      0x0\nesi            0x0      0\nedi            0x0      0\neip            0x7c00   0x7c00\neflags         0x202    [ IF ]\ncs             0x0      0\nss             0x0      0\nds             0x0      0\nes             0x0      0\nfs             0x0      0\ngs             0x0      0</code></pre></div>\n<p>也就是说，最开始的时候esp指向0x6f20。</p>\n<p>第一次运行<code class=\"language-text\">%esp</code>相关的代码，在<code class=\"language-text\">bootasm.S</code>的<code class=\"language-text\">call bootmain</code>之上，把<code class=\"language-text\">$start</code>(具体值是0x7c00)付给%esp</p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\">movl    $start, %esp\ncall\tbootmain</code></pre></div>\n<p>也就是在运行<code class=\"language-text\">bootmain</code>之前，<code class=\"language-text\">%esp</code>的值为<code class=\"language-text\">0x7c00</code>，<code class=\"language-text\">0x7c00</code>之后的地址都是无用的，所以实际上上面有用的栈是：</p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\">0x7bdc: 0x00007d8d      0x00000000      0x00000000      0x00000000\n0x7bec: 0x00000000      0x00000000      0x00000000      0x00000000\n0x7bfc: 0x00007c4d      </code></pre></div>\n<p><code class=\"language-text\">call</code>指令把<code class=\"language-text\">%eip</code> push进来了。</p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\">0x7bfc: 0x00007c4d # bootmain的返回地址</code></pre></div>\n<p>之后进入<code class=\"language-text\">bootmain</code>，首先运行function prologue，也就是把main外面环境的的%ebp (frame address)存在%esp中，所以</p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\">0x7bf8: 0x00000000 # ebp，因为外面没有frame了，是0</code></pre></div>\n<p>以及bootmain的<code class=\"language-text\">%ebp</code>为<code class=\"language-text\">0x7bf8, </code>info reg`可以证明这点</p>\n<p>之后连续进行3个<code class=\"language-text\">push</code></p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\">(gdb) si\n=&gt; 0x7d3e:      push   %edi\n0x00007d3e in ?? ()\n(gdb) si\n=&gt; 0x7d3f:      push   %esi\n0x00007d3f in ?? ()\n(gdb) si\n=&gt; 0x7d40:      push   %ebx\n0x00007d40 in ?? ()\n(gdb) w/4x $esp\nAmbiguous command &quot;w/4x $esp&quot;: .\n(gdb) x/4x $esp\n0x7bf0: 0x00000000      0x00000000      0x00000000      0x00007c4d</code></pre></div>\n<p>所以：</p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\">0x7bf4: 0x00000000 # edi\n0x7bf0: 0x00000000 # esi\n0x7bec: 0x00000000 # ebx</code></pre></div>\n<p>之后</p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\">(gdb) si\n=&gt; 0x7d41:      sub    $0xc,%esp\n0x00007d41 in ?? ()</code></pre></div>\n<p>这之后<code class=\"language-text\">%esp</code>仅仅缩小了12</p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\">0x7be8: 0x00000000 # 空的\n0x7be4: 0x00000000 # 空的\n0x7be0: 0x00000000 # 空的</code></pre></div>\n<p>之后为<code class=\"language-text\">readseg</code>做准备，先把3个参数依倒叙传入，进行了三个push</p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\">(gdb) si\n=&gt; 0x7d44:      push   $0x0\n0x00007d44 in ?? ()\n(gdb) si\n=&gt; 0x7d46:      push   $0x1000\n0x00007d46 in ?? ()\n(gdb) si\n=&gt; 0x7d4b:      push   $0x10000</code></pre></div>\n<p>这时，</p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\"># readseg的3个参数\n0x7bdc: 0x00000000 # offset\n0x7bd8: 0x00001000 # count\n0x7bd4: 0x00010000 # pa</code></pre></div>\n<p>然后<code class=\"language-text\">call readseg</code></p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\">(gdb) si\n=&gt; 0x7d50:      call   0x7cf8</code></pre></div>\n<p>依然是会把<code class=\"language-text\">%eip</code>推进去</p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\">0x7bd0: 0x00007d55 # readseg的return address</code></pre></div>\n<p>然后运行<code class=\"language-text\">readseg</code>的function prologue：</p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\">(gdb) si\n=&gt; 0x7cf8:      push   %ebp\n0x00007cf8 in ?? ()\n(gdb) si\n=&gt; 0x7cf9:      mov    %esp,%ebp\n0x00007cf9 in ?? ()</code></pre></div>\n<p>就会有</p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\">0x7bcc: 0x00007bf8 # bootmain的frame address</code></pre></div>\n<p>同事<code class=\"language-text\">%ebp</code>变为<code class=\"language-text\">0x7bcc</code>。</p>\n<p>之后依然是3个push，</p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\">(gdb) si\n=&gt; 0x7cfb:      push   %edi\n0x00007cfb in ?? ()\n(gdb) si\n=&gt; 0x7cfc:      push   %esi\n0x00007cfc in ?? ()\n(gdb) si\n=&gt; 0x7cfd:      push   %ebx\n0x00007cfd in ?? ()</code></pre></div>\n<p>仍然是推进去3个0，</p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\">0x7bc8: 0x00000000 # edi\n0x7bc4: 0x00000000 # esi\n0x7bc0: 0x00000000 # ebx</code></pre></div>\n<p>后面就非常类似了，这里叙述的栈的内容已经超过需要的了，之所以会超过是因为之后<code class=\"language-text\">readseg</code>函数返回会退出来很多。</p>","frontmatter":{"title":"6.828 Homework boot xv6","date":"2019-02-14T15:49:00.000Z","tags":["OS","6.828"]}}},"pageContext":{"slug":"/6.828-hw-boot-xv6/"}},"staticQueryHashes":["3159585216"],"slicesMap":{}}