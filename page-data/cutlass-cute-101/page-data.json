{"componentChunkName":"component---src-templates-blog-post-js","path":"/cutlass-cute-101/","webpackCompilationHash":"86a3b66fca16ecb8917b","result":{"data":{"markdownRemark":{"html":"<p>来简单过一下 tutorial 里的 <code class=\"language-text\">sgemm_nt_1.cu</code>，看的 commit 是 <code class=\"language-text\">ff02da266</code></p>\n<p>外面正常分配 3 个显存。</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">  d_C = h_C;\n  gemm(m, n, k,\n       alpha,\n       d_A.data().get(), m,\n       d_B.data().get(), n,\n       beta,\n       d_C.data().get(), m);</code></pre></div>\n<p>对应函数定义：</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">template &lt;typename TA, typename TB, typename TC,\n          typename Alpha, typename Beta&gt;\nvoid\ngemm(int m, int n, int k,\n     Alpha alpha,\n     TA const* A, int ldA,\n     TB const* B, int ldB,\n     Beta beta,\n     TC      * C, int ldC,\n     cudaStream_t stream = 0)</code></pre></div>\n<p>这里 <code class=\"language-text\">ldA</code>、<code class=\"language-text\">ldB</code>、<code class=\"language-text\">ldC</code> 都是指 leading dimension，是用来设置 layout 的。其中：</p>\n<p>主要要弄清 stride, block layout 和 thread layout 都是干啥的。</p>\n<p>block layout 是指一个 block 要处理多少元素，所以用它的值来分配 shared memory：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  __shared__ TA smemA[cosize_v&lt;ABlockLayout&gt;];\n  __shared__ TB smemB[cosize_v&lt;BBlockLayout&gt;];</code></pre></div>\n<p>这里不太确定非 static 的 layout 是否能用 <code class=\"language-text\">cosize_v</code>。</p>\n<p>layout = shape + stride，tensor = ptr + layout，所以有如下 2 种方式声明 tensor：</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">auto sA = make_tensor(make_smem_ptr(smemA), blockA);\nauto mA = make_tensor(make_gmem_ptr(A), make_shape(M,K), dA);</code></pre></div>\n<p><code class=\"language-text\">make_coord</code> 就是一个占位符：</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">template &lt;class... Ts&gt;\nCUTE_HOST_DEVICE constexpr\ncute::tuple&lt;Ts...&gt; make_coord(Ts const&amp;... t) {\n  return {t...};\n}</code></pre></div>\n<p>这里因为 <code class=\"language-text\">(BLK_M,BLK_N,BLK_K) = (128, 128, 8)</code>，然后 <code class=\"language-text\">A = 5120 x 4096</code></p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">// Get the appropriate blocks for this thread block --\n// potential for thread block locality\nauto blk_shape = make_shape(size&lt;0&gt;(sA), size&lt;0&gt;(sB), size&lt;1&gt;(sB));// (BLK_M,BLK_N,BLK_K)\nauto blk_coord = make_coord(blockIdx.x, blockIdx.y, _);            // (m,n,k)\n\nauto gA = local_tile(mA, blk_shape, blk_coord, Step&lt;_1, X,_1&gt;{});  // (BLK_M,BLK_K,k)\nauto gB = local_tile(mB, blk_shape, blk_coord, Step&lt; X,_1,_1&gt;{});  // (BLK_N,BLK_K,k)\nauto gC = local_tile(mC, blk_shape, blk_coord, Step&lt;_1,_1, X&gt;{});  // (BLK_M,BLK_N)</code></pre></div>\n<p>注意这里 <code class=\"language-text\">X</code> 就是 <code class=\"language-text\">Underscore</code>，<code class=\"language-text\">Step</code> 是 <code class=\"language-text\">cute::tuple</code>。</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">local_tile</span><span class=\"token punctuation\">(</span>tensor<span class=\"token punctuation\">,</span> tile<span class=\"token punctuation\">,</span> coord<span class=\"token punctuation\">,</span> proj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n  <span class=\"token keyword\">return</span> local_tile<span class=\"token punctuation\">(</span>tensor<span class=\"token punctuation\">,</span> dice<span class=\"token punctuation\">(</span>proj<span class=\"token punctuation\">,</span> tile<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> dice<span class=\"token punctuation\">(</span>proj<span class=\"token punctuation\">,</span> coord<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>这里 <code class=\"language-text\">dice</code> 对应的 python 是：</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">dice</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">if</span> isintance<span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> <span class=\"token builtin\">tuple</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">assert</span> <span class=\"token builtin\">isinstance</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span> <span class=\"token keyword\">and</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token builtin\">sum</span><span class=\"token punctuation\">(</span>dice<span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span> <span class=\"token keyword\">for</span> x<span class=\"token punctuation\">,</span> y <span class=\"token keyword\">in</span> <span class=\"token builtin\">zip</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">elif</span> <span class=\"token builtin\">isinstance</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> Underscore<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">,</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>所以上面 3 行转为：</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">gA = local_tile(mA, (BLK_M, BLK_K), (blockIdx.x, _));  // (BLK_M,BLK_K,k)\ngB = local_tile(mB, (BLK_N, BLK_K), (blockIdx.y, _));  // (BLK_N,BLK_K,k)\ngC = local_tile(mC, (BLK_M, BLK_N), (blockIdx.x, blockIdx.y));  // (BLK_M,BLK_N)</code></pre></div>\n<p>这里的意思是，先把 <code class=\"language-text\">mA</code> 按照  <code class=\"language-text\">(BLK_M, BLK_K)</code> 分成一个一个 tile，相当于从 <code class=\"language-text\">(m, k)</code> 变形为 <code class=\"language-text\">(blk_m, blk_k, m/blk_m, k/blk_k)</code>，然后坐标上再取取 <code class=\"language-text\">(_, _, blockIdx.x, _)</code>，也就取出来了当前 block 所需的那部分 <code class=\"language-text\">mA</code>。对应 print 出来的形状为 <code class=\"language-text\">(128,8,512)</code>，而 stride 为 <code class=\"language-text\">(1,5120,40960)</code> 则是因为过程中没有拷贝，原来的是 <code class=\"language-text\">(1, 5120)</code>，现在多了 <code class=\"language-text\">blk_k</code> 那一层，就变成了 <code class=\"language-text\">(1,5120,8*5120)</code>。</p>\n<p>类似地，<code class=\"language-text\">gB</code> 的形状为 <code class=\"language-text\">(blk_n, blk_k, k/blk_k)</code>，<code class=\"language-text\">gC</code> 的形状为 <code class=\"language-text\">(blk_m, blk_n)</code>。</p>\n<p>下一步是获取 <code class=\"language-text\">local_partition</code>，</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">  // TUTORIAL: Example of simple partitioning of A|B tiles over tA|tB\n  //   Default is a raked partition, but can be changed with Step&lt;X,Y&gt; parameter\n\n  auto tAgA = local_partition(gA, tA, threadIdx.x);                  // (THR_M,THR_K,k)\n  auto tAsA = local_partition(sA, tA, threadIdx.x);                  // (THR_M,THR_K)\n\n  auto tBgB = local_partition(gB, tB, threadIdx.x);                  // (THR_N,THR_K,k)\n  auto tBsB = local_partition(sB, tB, threadIdx.x);                  // (THR_N,THR_K)</code></pre></div>\n<p>这里首先是有个隐含的转换，会把 <code class=\"language-text\">threadIdx.x</code> 转到 <code class=\"language-text\">tA</code> 的范围里。</p>\n<p>然后 <code class=\"language-text\">load_partition</code> 和 <code class=\"language-text\">load_tile</code> 的区别是，后者是划分 tile，然后在后面取 coord，前者是先按 layout 分成 partition，然后在 partition 里面做 index。</p>\n<p>也就是 <code class=\"language-text\">gA</code> 从 <code class=\"language-text\">(blk_m,blk_k,k/blk_k)</code> 进一步划分成  <code class=\"language-text\">(thr_m,thr_k,blk_m/thr_m,blk_k/thr_k,k/blk_k)</code>，然后前面 2 维取 <code class=\"language-text\">threadIdx.x</code>，得到 <code class=\"language-text\">tAgA</code> 为 <code class=\"language-text\">(blk_m/thr_m,blk_k/thr_k,k/blk_k)</code>，也就是 <code class=\"language-text\">(8,1,512)</code>，类似地 <code class=\"language-text\">tAsA</code> 为 <code class=\"language-text\">(8,1)</code>。通过这种方式，得到了当前 thread 需要的 A, B 的 memory。</p>\n<p>用同样的方法，我们可以得到，<code class=\"language-text\">tCsA</code> 是从 <code class=\"language-text\">(128,8)</code>（<code class=\"language-text\">sA</code>），转成 <code class=\"language-text\">(16, 16, 8)</code>，然后变成了 <code class=\"language-text\">(16, 8)</code>，然后 <code class=\"language-text\">tCsB</code> 也是变成了 <code class=\"language-text\">(16, 8)</code>。<code class=\"language-text\">tCgC</code> 则是从 <code class=\"language-text\">(blk_m, blk_n)</code> 转成  <code class=\"language-text\">(16,16,128/16,128/16)</code> 然后前 2 维一取，就剩下了 <code class=\"language-text\">(8, 8)</code>。</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">// Allocate the accumulators -- same size as the projected data\nauto tCrC = make_fragment_like(tCgC);</code></pre></div>\n<p>这里底层会分配一段显存，不过注意，他要求 layout 是 static 的。底层其实就是分配了一个 array，类似 <code class=\"language-text\">T a[N]</code>。</p>\n<p>最后这个循环，每次先把 shared memory 填满。然后调用的 <code class=\"language-text\">gemm</code>。</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">  auto k_max = size&lt;2&gt;(tAgA);\n\n  for (int k = 0; k &lt; k_max; ++k)\n  {\n    // Copy gmem to smem\n    copy(tAgA(_,_,k), tAsA);\n    copy(tBgB(_,_,k), tBsB);\n\n    // In case copy uses cp.async, make sure that the cp.async\n    // instructions are ordered with respect to other cp.async\n    // instructions (fence), then wait on all the outstanding copy\n    // operations (wait&lt;0&gt;()).  __syncthreads() alone does not do\n    // this.\n    //\n    // NOTE: cp_async_wait&lt;0&gt;() currently issues cp.async.wait_all.\n    // This is equivalent to cp.async.commit_group followed by\n    // cp.async_wait_group 0.  This should make the first\n    // cp_async_fence() (which also issues cp.async.commit_group)\n    // redundant.  The tutorial works as-is, so we&#39;ll leave the\n    // redundant fence in for now and study its removal later.\n     ();\n    cp_async_wait&lt;0&gt;();\n\n    __syncthreads();\n\n    // Compute gemm on smem\n    gemm(tCsA, tCsB, tCrC);\n\n    __syncthreads();\n  }</code></pre></div>","frontmatter":{"title":"cutlass cute 101","date":null,"tags":null}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/cutlass-cute-101/"}}}