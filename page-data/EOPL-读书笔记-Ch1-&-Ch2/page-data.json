{"componentChunkName":"component---src-templates-blog-post-js","path":"/EOPL-读书笔记-Ch1-&-Ch2/","webpackCompilationHash":"4caac2cf7443445fbc35","result":{"data":{"markdownRemark":{"html":"<p>最近开始研究 TVM 的 Relay，发现该补的还是要补.... 因为之前偷懒跳过了 EOPL 的 ch6，所以不理解 CPS，也就理解不了 Relay 的 interpreter 在干啥。所以这两天打算重读一下 eopl，顺便记一下笔记。这次的目标暂定为读到第六章吧，最好也能把之前没做的习题也补上~</p>\n<h2>Racket 使用教程</h2>\n<p>在 repl 里运行 Racket 的方法：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token operator\">></span> <span class=\"token punctuation\">(</span>exit<span class=\"token punctuation\">)</span></code></pre></div>\n<p>在 repl 里加载racket 的方法：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token operator\">></span> <span class=\"token punctuation\">(</span>load <span class=\"token string\">\"hello.rkt\"</span><span class=\"token punctuation\">)</span></code></pre></div>\n<h2>Ch1 Inductive Sets of Data</h2>\n<h3>1.1 Recursively Specified Data</h3>\n<h4>1.1.1 Inductive Specification</h4>\n<p>这一节介绍了中间画横线表示 hypothesis 至 conclusion 的因果关系，被称为 rule of inference。这种表示方式貌似也是 PL 中比较常见的方法。</p>\n<h4>1.1.2 Defining Sets Using Grammars</h4>\n<p>这里就开始用语法表示集合了，是不是和 Lean prover 在做的东西有点像？</p>\n<p>List 的语法：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">List-of-Int ::= ()\nList-of-Int ::= (Int . List-of-Int)</code></pre></div>\n<ul>\n<li>nonterminal symbols: 被定义的名字。例如上面的 List-of-Int。本书会用大写开头表示 nonerminals，并用小写开头的名字表示其成员，例如 <code class=\"language-text\">e in Expression</code>。在 BNF 中，一般用尖括号包住，表示为 <code class=\"language-text\">&lt;expression&gt;</code>。</li>\n<li>terminal symbols: 那些外部的符号，或者关键词，例如 <code class=\"language-text\">.</code>， <code class=\"language-text\">(</code>，<code class=\"language-text\">)</code>，<code class=\"language-text\">lambda</code>。</li>\n<li>Productions: 规则被称为 productions。每条规则的左边为 nonterminal，右边为 terminal 和 nonterminal 混合。</li>\n</ul>\n<p>常见的语法写法：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">List-of-Int ::<span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n            ::<span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>Int <span class=\"token keyword\">.</span> List-of-Int<span class=\"token punctuation\">)</span>\n\nList-of-Int ::<span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">|</span> <span class=\"token punctuation\">(</span>Int <span class=\"token keyword\">.</span> List-of-Int<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># `*` 名叫 Kleene star，表示任意个</span>\nList-if-Int ::<span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>Int<span class=\"token punctuation\">}</span>*<span class=\"token punctuation\">)</span></code></pre></div>\n<p><strong>lambda calculus</strong> 的语法为：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">LcExp ::= Identifier\n      ::= (lambda (Identifier) LcExp)\n      ::= (LcExp LcExp)</code></pre></div>\n<p>这个语言的函数都只有一个参数。这里第二行的 <code class=\"language-text\">Identifier</code> 被称为 bound variable。</p>\n<p>在定义二叉搜索树的时候，如果仅用下面的方法进行定义：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Binary-search-tree ::= () | (Int Binary-search-tree Binary-search-tree)</code></pre></div>\n<p>是没有办法保证树内部的序的（左树小于右树），这种限制被称为 context-sensitive constraints 或者 invariant。</p>\n<p>在编程语言中也有很多 context-sensitive constraints，例如 variable 必须先定义再使用。可以用形式化的手段来保证这种 constraint，不过这已经超过本章的范畴了。而在实践中，我们往往会使用 context-free grammar。在 ch7 中，我们会介绍一些针对这种 constraint 的方法。</p>\n<h3>1.2 Deriving Recursive Programs</h3>\n<ul>\n<li><strong>The Smaller-Subproblem Principle</strong>: 如果我们可以把问题规约至一个更小的子问题，那么我们可以用解该问题的程序去求解这个子问题。</li>\n</ul>\n<p>子问题的解可能可以用来解原问题。</p>\n<p>这一节里面都是些如何用递归的方法去写一些 list 相关的函数。可以去看看的是 1.2.4 的 <code class=\"language-text\">occur-free</code>。</p>\n<p>写起来的一个感觉就是，因为其实都通过展开变量定义来做递归，所以 ADT 可能的确是写起来更方便。</p>\n<h3>1.3 Auxiliary Procedures and Context Arguments</h3>\n<p>用辅助函数进行 generalize 来帮助实现。辅助函数帮助的方法就是把 context 作为参数传进来。</p>\n<h2>Ch2 Data Abstraction</h2>\n<h3>2.1 Specifying Data via Interface</h3>\n<p>ADT，也就是 abstract data type，是指将 interface 和 implementation 区分开的数据类型。</p>\n<p>例如自然数，就可以用以下的几个 interface 代表：<code class=\"language-text\">zero</code>, <code class=\"language-text\">is-zero?</code>, <code class=\"language-text\">successor</code>, <code class=\"language-text\">predecessor</code>。</p>\n<p>因为实现和接口分离，所以我们可以有多种表示自然数的方式：</p>\n<ul>\n<li>Unary representation</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"lisp\"><pre class=\"language-lisp\"><code class=\"language-lisp\"><span class=\"token punctuation\">(</span><span class=\"token car\">define</span> zero <span class=\"token punctuation\">(</span><span class=\"token lambda\"><span class=\"token keyword\">lambda</span> <span class=\"token punctuation\">(</span><span class=\"token arguments\"></span><span class=\"token punctuation\">)</span></span> ’<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token car\">define</span> is-zero? <span class=\"token punctuation\">(</span><span class=\"token lambda\"><span class=\"token keyword\">lambda</span> <span class=\"token punctuation\">(</span><span class=\"token arguments\"><span class=\"token argument variable\">n</span></span><span class=\"token punctuation\">)</span></span> <span class=\"token punctuation\">(</span><span class=\"token car\">null</span>? n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token car\">define</span> successor <span class=\"token punctuation\">(</span><span class=\"token lambda\"><span class=\"token keyword\">lambda</span> <span class=\"token punctuation\">(</span><span class=\"token arguments\"><span class=\"token argument variable\">n</span></span><span class=\"token punctuation\">)</span></span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">cons</span> #t n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token car\">define</span> predecessor <span class=\"token punctuation\">(</span><span class=\"token lambda\"><span class=\"token keyword\">lambda</span> <span class=\"token punctuation\">(</span><span class=\"token arguments\"><span class=\"token argument variable\">n</span></span><span class=\"token punctuation\">)</span></span> <span class=\"token punctuation\">(</span><span class=\"token car\">cdr</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<ul>\n<li>Scheme number representation</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"lisp\"><pre class=\"language-lisp\"><code class=\"language-lisp\"><span class=\"token punctuation\">(</span><span class=\"token car\">define</span> zero <span class=\"token punctuation\">(</span><span class=\"token lambda\"><span class=\"token keyword\">lambda</span> <span class=\"token punctuation\">(</span><span class=\"token arguments\"></span><span class=\"token punctuation\">)</span></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token car\">define</span> is-zero? <span class=\"token punctuation\">(</span><span class=\"token lambda\"><span class=\"token keyword\">lambda</span> <span class=\"token punctuation\">(</span><span class=\"token arguments\"><span class=\"token argument variable\">n</span></span><span class=\"token punctuation\">)</span></span> <span class=\"token punctuation\">(</span><span class=\"token car\">zero</span>? n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token car\">define</span> successor <span class=\"token punctuation\">(</span><span class=\"token lambda\"><span class=\"token keyword\">lambda</span> <span class=\"token punctuation\">(</span><span class=\"token arguments\"><span class=\"token argument variable\">n</span></span><span class=\"token punctuation\">)</span></span> <span class=\"token punctuation\">(</span><span class=\"token car\">+</span> n <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token car\">define</span> predecessor <span class=\"token punctuation\">(</span><span class=\"token lambda\"><span class=\"token keyword\">lambda</span> <span class=\"token punctuation\">(</span><span class=\"token arguments\"><span class=\"token argument variable\">n</span></span><span class=\"token punctuation\">)</span></span> <span class=\"token punctuation\">(</span><span class=\"token car\">-</span> n <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<ul>\n<li>Bignum representation</li>\n</ul>\n<p>也就是用一个 list 来表示某一个进制的值，例如如果是 16 进制，那么 <code class=\"language-text\">33 = (1 2)</code>，<code class=\"language-text\">258 = (2 0 1)</code></p>\n<p>如果一个类型的内部表达方式是被隐藏的，就被称为 opaque，反之，被称为 transparent。</p>\n<h3>2.2 Representation Strategies for Data Types</h3>\n<p>本节中，我们将通过数据类型 <code class=\"language-text\">environments</code> 介绍一些表示 ADT 的方法。</p>\n<p><code class=\"language-text\">environment</code> 用于记录编程语言实现中，变量和其值的对应关系。</p>\n<p>只要能相互区分（compare for equality），变量用啥表示都行，这里我们选择用 Scheme symbol 表示。</p>\n<h4>2.2.1 The Enviroment Interface</h4>\n<p>我们设计的 interface 有  3 个函数：</p>\n<ul>\n<li><code class=\"language-text\">(empty-env)</code>：表示空环境</li>\n<li><code class=\"language-text\">(apply-env f var)</code>：返回 <code class=\"language-text\">f(var)</code>，这里 <code class=\"language-text\">f</code> 是个环境。</li>\n<li><code class=\"language-text\">(extend-env var v f)</code>：返回的新环境里，<code class=\"language-text\">var</code> 的值改为 <code class=\"language-text\">v</code>。</li>\n</ul>\n<p>我们可以把这 3 个函数分为 constructor 和 observer，<code class=\"language-text\">empty-env</code> 和 <code class=\"language-text\">extent-env</code> 是 constructor， <code class=\"language-text\">apply-env</code> 是 observer。</p>\n<h4>2.2.2 Data Structure Representation</h4>\n<p>从上面的接口，我们有：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Env-exp ::= (empty-env)\n        ::= (extend-env Identifier Scheme-value Env-exp)</code></pre></div>\n<ul>\n<li>\n<p><strong>The Interpreter Recipe</strong></p>\n<ol>\n<li>Look at a piece of data.</li>\n<li>Decide what kind of data it represents.</li>\n<li>Extract the components of the datum and do the right thing with them.</li>\n</ol>\n</li>\n</ul>\n<p>这一节提出了一种完全拿 list 的方式表示，就是包括 <code class=\"language-text\">extend-env</code> 和 <code class=\"language-text\">empty-env</code> 都做成 symbol 放在 list 里面。</p>\n<h4>2.2.3 Procedural Representation</h4>\n<p>由于 environment 只有一个 observer。所以可以用函数来表示 environment。其中 <code class=\"language-text\">empty-env</code> 就表示的是一个传入任何参数都会报错的；<code class=\"language-text\">extend-env</code> 则是用闭包的方式保存添加的值；<code class=\"language-text\">apply-env</code> 则就是以变量名为参数，调用 env。</p>\n<p>这种表示方法被称为 <code class=\"language-text\">procedural representation</code>，其中的数据是 action under <code class=\"language-text\">apply-env</code>。</p>\n<p>这种只有一个 observer 的数据类型还挺常见的，我们总结了如下的提取 interface 并使用 procedural representation 的方法：</p>\n<ol>\n<li>找出会返回该类型的值的 lambda 表达式，并给每个这种 lambda 表达式对应上一个 constructor。constructor 的参数应该是该 lambda 表达式的 free variable。把源代码中对这个 lambda 表达式的调用都换成这个构造函数。</li>\n<li>定一个一个类似 <code class=\"language-text\">apply-env</code> 的 <code class=\"language-text\">apply-</code> 函数。把所有会使用该类型值的地方都换成调用这个 <code class=\"language-text\">apply-</code> 函数。</li>\n</ol>\n<p>这样修改后，client code 就变为 representation independent。</p>\n<p>如果实现所用的语言用不了 higher-order procedure （把函数作为函数的参数），那么可以把得到的 interface 再用 data structure representation 和 interpreter recipe 实现一下。这被称为 defunctionalization。</p>\n<h3>2.3 Interfaces for Recursive Data Types</h3>\n<p>在 ch1，我们定义了 lambda calculus expression：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">LcExp ::= Identifier\n      ::= (lambda (Identifier) LcExp)\n      ::= (LcExp LcExp)</code></pre></div>\n<p>并写了 <code class=\"language-text\">occurs-free?</code> 这样的函数。但是当时的写法不太好懂，因为当时的写法是和 representation 强绑定的。我们可以通过引入 interface 的方式来解决这个问题。我们提出了如下的接口：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># constructors:</span>\nvar-exp <span class=\"token keyword\">:</span> Var → Lc-exp\nlambda-exp <span class=\"token keyword\">:</span> Var×Lc-exp → Lc-exp\napp-exp <span class=\"token keyword\">:</span> Lc-exp×Lc-exp → Lc-exp\n<span class=\"token comment\"># predicates:</span>\nvar-exp? <span class=\"token keyword\">:</span> Lc-exp → Bool\nlambda-exp? <span class=\"token keyword\">:</span> Lc-exp → Bool\napp-exp? <span class=\"token keyword\">:</span> Lc-exp → Bool\n<span class=\"token comment\"># extractors:</span>\nvar-exp-<span class=\"token operator\">></span>var <span class=\"token keyword\">:</span> Lc-exp → Var\nlambda-exp-<span class=\"token operator\">></span>bound-var <span class=\"token keyword\">:</span> Lc-exp → Var\nlambda-exp-<span class=\"token operator\">></span>body <span class=\"token keyword\">:</span> Lc-exp → Lc-exp\napp-exp-<span class=\"token operator\">></span>rator <span class=\"token keyword\">:</span> Lc-exp → Lc-exp\napp-exp-<span class=\"token operator\">></span>rand <span class=\"token keyword\">:</span> Lc-exp → Lc-exp</code></pre></div>\n<p>有了这些之后，<code class=\"language-text\">occurs-free?</code> 变成了：</p>\n<div class=\"gatsby-highlight\" data-language=\"lisp\"><pre class=\"language-lisp\"><code class=\"language-lisp\"><span class=\"token comment\">; occurs-free? : Sym × LcExp → Bool</span>\n<span class=\"token punctuation\">(</span><span class=\"token car\">define</span> occurs-free?\n  <span class=\"token punctuation\">(</span><span class=\"token lambda\"><span class=\"token keyword\">lambda</span> <span class=\"token punctuation\">(</span><span class=\"token arguments\"><span class=\"token argument variable\">search-var</span> <span class=\"token argument variable\">exp</span></span><span class=\"token punctuation\">)</span></span>\n    <span class=\"token punctuation\">(</span><span class=\"token keyword\">cond</span>\n      <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token car\">var-exp</span>? exp<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token car\">eqv</span>? search-var <span class=\"token punctuation\">(</span><span class=\"token car\">var-exp->var</span> exp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token car\">lambda-exp</span>? exp<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">(</span><span class=\"token keyword\">and</span>\n          <span class=\"token punctuation\">(</span><span class=\"token keyword\">not</span> <span class=\"token punctuation\">(</span><span class=\"token car\">eqv</span>? search-var <span class=\"token punctuation\">(</span><span class=\"token car\">lambda-exp->bound-var</span> exp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n          <span class=\"token punctuation\">(</span><span class=\"token car\">occurs-free</span>? search-var <span class=\"token punctuation\">(</span><span class=\"token car\">lambda-exp->body</span> exp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">(</span><span class=\"token car\">else</span>\n        <span class=\"token punctuation\">(</span><span class=\"token keyword\">or</span>\n          <span class=\"token punctuation\">(</span><span class=\"token car\">occurs-free</span>? search-var <span class=\"token punctuation\">(</span><span class=\"token car\">app-exp->rator</span> exp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n          <span class=\"token punctuation\">(</span><span class=\"token car\">occurs-free</span>? search-var <span class=\"token punctuation\">(</span><span class=\"token car\">app-exp->rand</span> exp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span></code></pre></div>\n<p>我们可以写出一个制作 recursive data type 的 recipe：</p>\n<ul>\n<li><strong>Designing an interface for a recursive data type</strong></li>\n<li>Include one constructor for each kind of data in the data type.</li>\n<li>Include one predicate for each kind of data in the data type.</li>\n<li>Include one extractor for each piece of data passed to a constructor of the data type.</li>\n</ul>\n<h3>2.4 A Tool for Defining Recursive Data Type</h3>\n<p>这一节介绍该如何自动创建 interface。</p>\n<div class=\"gatsby-highlight\" data-language=\"lisp\"><pre class=\"language-lisp\"><code class=\"language-lisp\"><span class=\"token punctuation\">(</span><span class=\"token car\">define-datatype</span> lc-exp lc-exp?\n  <span class=\"token punctuation\">(</span><span class=\"token car\">var-exp</span>\n  \t<span class=\"token punctuation\">(</span><span class=\"token car\">var</span> identifier?<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">(</span><span class=\"token car\">lambda-exp</span>\n  \t<span class=\"token punctuation\">(</span><span class=\"token car\">bound-var</span> identifier?<span class=\"token punctuation\">)</span>\n  \t<span class=\"token punctuation\">(</span><span class=\"token car\">body</span> lc-exp?<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">(</span><span class=\"token car\">app-exp</span>\n  \t<span class=\"token punctuation\">(</span><span class=\"token car\">rator</span> lc-exp?<span class=\"token punctuation\">)</span>\n  \t<span class=\"token punctuation\">(</span><span class=\"token car\">rand</span> lc-exp?<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span></code></pre></div>\n<p>使用方法如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"lisp\"><pre class=\"language-lisp\"><code class=\"language-lisp\"><span class=\"token punctuation\">(</span><span class=\"token car\">define</span> occurs-free?\n  <span class=\"token punctuation\">(</span><span class=\"token lambda\"><span class=\"token keyword\">lambda</span> <span class=\"token punctuation\">(</span><span class=\"token arguments\"><span class=\"token argument variable\">search-var</span> <span class=\"token argument variable\">exp</span></span><span class=\"token punctuation\">)</span></span>\n    <span class=\"token punctuation\">(</span><span class=\"token car\">cases</span> lc-exp exp\n      <span class=\"token punctuation\">(</span><span class=\"token car\">var-exp</span> <span class=\"token punctuation\">(</span><span class=\"token car\">var</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token car\">eqv</span>? var search-var<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">(</span><span class=\"token car\">lambda-exp</span> <span class=\"token punctuation\">(</span><span class=\"token car\">bound-var</span> body<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">(</span><span class=\"token keyword\">and</span>\n          <span class=\"token punctuation\">(</span><span class=\"token keyword\">not</span> <span class=\"token punctuation\">(</span><span class=\"token car\">eqv</span>? search-var bound-var<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n          <span class=\"token punctuation\">(</span><span class=\"token car\">occurs-free</span>? search-var body<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">(</span><span class=\"token car\">app-exp</span> <span class=\"token punctuation\">(</span><span class=\"token car\">rator</span> rand<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">(</span><span class=\"token keyword\">or</span>\n          <span class=\"token punctuation\">(</span><span class=\"token car\">occurs-free</span>? search-var rator<span class=\"token punctuation\">)</span>\n          <span class=\"token punctuation\">(</span><span class=\"token car\">occurs-free</span>? search-var rand<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>换个例子来说，如果是 <code class=\"language-text\">s-list</code> （symbol list）：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">S-list ::= ({S-exp}∗)\nS-exp ::= Symbol | S-list</code></pre></div>\n<p>其定义方法是：</p>\n<div class=\"gatsby-highlight\" data-language=\"lisp\"><pre class=\"language-lisp\"><code class=\"language-lisp\"><span class=\"token punctuation\">(</span><span class=\"token car\">define-datatype</span> s-list s-list?\n  <span class=\"token punctuation\">(</span><span class=\"token car\">empty-s-list</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">(</span><span class=\"token car\">non-empty-s-list</span>\n    <span class=\"token punctuation\">(</span><span class=\"token car\">first</span> s-exp?<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">(</span><span class=\"token car\">rest</span> s-list?<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token punctuation\">(</span><span class=\"token car\">define-datatype</span> s-exp s-exp?\n  <span class=\"token punctuation\">(</span><span class=\"token car\">symbol-s-exp</span>\n  \t<span class=\"token punctuation\">(</span><span class=\"token car\">sym</span> symbol?<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">(</span><span class=\"token car\">s-list-s-exp</span>\n    <span class=\"token punctuation\">(</span><span class=\"token car\">slst</span> s-list?<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>或者也可以是：</p>\n<div class=\"gatsby-highlight\" data-language=\"lisp\"><pre class=\"language-lisp\"><code class=\"language-lisp\"><span class=\"token punctuation\">(</span><span class=\"token car\">define-datatype</span> s-list s-list?\n\t<span class=\"token punctuation\">(</span><span class=\"token car\">an-s-list</span>\n\t\t<span class=\"token punctuation\">(</span><span class=\"token car\">sexps</span> <span class=\"token punctuation\">(</span><span class=\"token car\">list-of</span> s-exp?<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token punctuation\">(</span><span class=\"token car\">define</span> list-of\n  <span class=\"token punctuation\">(</span><span class=\"token lambda\"><span class=\"token keyword\">lambda</span> <span class=\"token punctuation\">(</span><span class=\"token arguments\"><span class=\"token argument variable\">pred</span></span><span class=\"token punctuation\">)</span></span>\n    <span class=\"token punctuation\">(</span><span class=\"token lambda\"><span class=\"token keyword\">lambda</span> <span class=\"token punctuation\">(</span><span class=\"token arguments\"><span class=\"token argument variable\">val</span></span><span class=\"token punctuation\">)</span></span>\n      <span class=\"token punctuation\">(</span><span class=\"token keyword\">or</span> <span class=\"token punctuation\">(</span><span class=\"token car\">null</span>? val<span class=\"token punctuation\">)</span>\n          <span class=\"token punctuation\">(</span><span class=\"token keyword\">and</span> <span class=\"token punctuation\">(</span><span class=\"token car\">pair</span>? val<span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">(</span><span class=\"token car\">pred</span> <span class=\"token punctuation\">(</span><span class=\"token car\">car</span> val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token car\">list-of</span> pred<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token car\">cdr</span> val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>也就是通过一个辅助函数 <code class=\"language-text\">list-of</code>，构造了 <code class=\"language-text\">(list-of s-exp?)</code> 这个新的 predicate，从而创建了任意长的字符串。</p>\n<p><code class=\"language-text\">define-datatype</code> 是 DSL 的一个例子，这里解决的任务是如何定义 recursive data type。</p>\n<h3>2.5 Abstract Synntax and Its Representation</h3>\n<p>当语法指定了 inductive data type 的 representation 的时候，这种 representation 被称为 concrete syntax，或者 external representation。之前 lambda calculus 的定义就是一种 concrete syntax，因为其引入了 <code class=\"language-text\">lambda</code> 这个字符串。</p>\n<p>我们需要把这种 external representation 转化为 internal 的才可以处理数据。<code class=\"language-text\">define-datatype</code> 这种语法利于实现 internal representation，或者称为 abstract syntax。在 abstract syntax 中，不需要存储 terminal，因为他们不包含信息。</p>\n<p>为了用 abstract syntax 来表示 concrete syntax，我们需要给 concrete syntax 的每条 production（规则）以及每个 production 中的 nonterminal 的每次 occurence 命名。转化后的结果如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"lisp\"><pre class=\"language-lisp\"><code class=\"language-lisp\">Lc-exp :<span class=\"token lisp-property property\">:=</span> Identifier\n           var-exp <span class=\"token punctuation\">(</span><span class=\"token car\">var</span><span class=\"token punctuation\">)</span>\n       :<span class=\"token lisp-property property\">:=</span> <span class=\"token punctuation\">(</span><span class=\"token lambda\"><span class=\"token keyword\">lambda</span> <span class=\"token punctuation\">(</span><span class=\"token arguments\"><span class=\"token argument variable\">Identifier</span></span><span class=\"token punctuation\">)</span></span> Lc-exp<span class=\"token punctuation\">)</span>\n           lambda-exp <span class=\"token punctuation\">(</span><span class=\"token car\">bound-var</span> body<span class=\"token punctuation\">)</span>\n       :<span class=\"token lisp-property property\">:=</span> <span class=\"token punctuation\">(</span><span class=\"token car\">Lc-exp</span> Lc-exp<span class=\"token punctuation\">)</span>\n           app-exp <span class=\"token punctuation\">(</span><span class=\"token car\">rator</span> rand<span class=\"token punctuation\">)</span></code></pre></div>\n<p>在本书中，我们会经常用到这种同时展示 concrete 和 abstract syntax 的表达方式。</p>\n<p>concrete syntax 主要是为人服务的，而 abstract syntax 则是为计算机服务的。我们要考虑如何在这两者之间相互转换 。这个转化过程称为 parsing。</p>\n<p>下面这段代码就是从 concrete syntax 转为 abstract syntax 的 parser</p>\n<div class=\"gatsby-highlight\" data-language=\"lisp\"><pre class=\"language-lisp\"><code class=\"language-lisp\"><span class=\"token comment\">; parse-expression : SchemeVal → LcExp</span>\n<span class=\"token punctuation\">(</span><span class=\"token car\">define</span> parse-expression\n  <span class=\"token punctuation\">(</span><span class=\"token lambda\"><span class=\"token keyword\">lambda</span> <span class=\"token punctuation\">(</span><span class=\"token arguments\"><span class=\"token argument variable\">datum</span></span><span class=\"token punctuation\">)</span></span>\n    <span class=\"token punctuation\">(</span><span class=\"token keyword\">cond</span>\n      <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token car\">symbol</span>? datum<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token car\">var-exp</span> datum<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token car\">pair</span>? datum<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">(</span><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token car\">eqv</span>? <span class=\"token punctuation\">(</span><span class=\"token car\">car</span> datum<span class=\"token punctuation\">)</span> ’lambda<span class=\"token punctuation\">)</span>\n          <span class=\"token punctuation\">(</span><span class=\"token car\">lambda-exp</span>\n          \t<span class=\"token punctuation\">(</span><span class=\"token car\">car</span> <span class=\"token punctuation\">(</span><span class=\"token car\">cadr</span> datum<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n          \t<span class=\"token punctuation\">(</span><span class=\"token car\">parse-expression</span> <span class=\"token punctuation\">(</span><span class=\"token car\">caddr</span> datum<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n          <span class=\"token punctuation\">(</span><span class=\"token car\">app-exp</span>\n            <span class=\"token punctuation\">(</span><span class=\"token car\">parse-expression</span> <span class=\"token punctuation\">(</span><span class=\"token car\">car</span> datum<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">(</span><span class=\"token car\">parse-expression</span> <span class=\"token punctuation\">(</span><span class=\"token car\">cadr</span> datum<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">(</span><span class=\"token car\">else</span> <span class=\"token punctuation\">(</span><span class=\"token car\">report-invalid-concrete-syntax</span> datum<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>反向转化，也就是 unparse，如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"lisp\"><pre class=\"language-lisp\"><code class=\"language-lisp\"><span class=\"token comment\">; unparse-lc-exp : LcExp → SchemeVal</span>\n<span class=\"token punctuation\">(</span><span class=\"token car\">define</span> unparse-lc-exp\n  <span class=\"token punctuation\">(</span><span class=\"token lambda\"><span class=\"token keyword\">lambda</span> <span class=\"token punctuation\">(</span><span class=\"token arguments\"><span class=\"token argument variable\">exp</span></span><span class=\"token punctuation\">)</span></span>\n    <span class=\"token punctuation\">(</span><span class=\"token car\">cases</span> lc-exp exp\n    \t<span class=\"token punctuation\">(</span><span class=\"token car\">var-exp</span> <span class=\"token punctuation\">(</span><span class=\"token car\">var</span><span class=\"token punctuation\">)</span> var<span class=\"token punctuation\">)</span>\n    \t<span class=\"token punctuation\">(</span><span class=\"token car\">lambda-exp</span> <span class=\"token punctuation\">(</span><span class=\"token car\">bound-var</span> body<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">(</span><span class=\"token car\">list</span> ’lambda <span class=\"token punctuation\">(</span><span class=\"token car\">list</span> bound-var<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">(</span><span class=\"token car\">unparse-lc-exp</span> body<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">(</span><span class=\"token car\">app-exp</span> <span class=\"token punctuation\">(</span><span class=\"token car\">rator</span> rand<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">(</span><span class=\"token car\">list</span>\n        \t<span class=\"token punctuation\">(</span><span class=\"token car\">unparse-lc-exp</span> rator<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token car\">unparse-lc-exp</span> rand<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>","frontmatter":{"title":"EOPL 读书笔记 Ch1 & Ch2","date":"2021-05-05T22:41:00.000Z","tags":["PL"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/EOPL-读书笔记-Ch1-&-Ch2/"}}}