{"componentChunkName":"component---src-templates-blog-post-js","path":"/6.828-note6/","webpackCompilationHash":"bb5c7520fcd440d7acfc","result":{"data":{"markdownRemark":{"html":"<p>这里会记录阅读6.828课程lecture note的我的个人笔记。可能会中英混杂，不是很适合外人阅读，也请见谅。</p>\n<h2>Lecture 7: Using Virtual Memory</h2>\n<ul>\n<li>\n<p>step back: 从整个课程的角度</p>\n<p>没有设计OS的最好方式</p>\n<p>很多OS都使用虚拟内存，但是这不一定。</p>\n<p>xv6和JOS都是OS设计的例子，但是他们和真正的OS相比还是有很大差距的。</p>\n</li>\n<li>\n<p>guard page to protect against stack overflow</p>\n<p>在user stack后面放一个没有被map的page，这样如果stack overflow了，会得到page fault</p>\n<p>当application跑到guard page上来的时候分配more stack。</p>\n</li>\n<li>\n<p>优化：one zero-filled page</p>\n<p>观察到很多时候一些memory从来不会被写入，而因为所有的内存都会用0进行初始化，所以可以使用一个zeroed page for all zero mappings。</p>\n<p>当需要zero-filled page的时候，就map到这个zeroed page</p>\n<p>在写入的时候，make copy of page  and map it read/write in app address space</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">case</span> T_PGFLT<span class=\"token operator\">:</span> \n<span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">int</span> write <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>tf<span class=\"token operator\">-></span>err <span class=\"token operator\">&amp;</span> FEC_WR<span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\tuint va <span class=\"token operator\">=</span> <span class=\"token function\">PGROUNDDOWN</span><span class=\"token punctuation\">(</span><span class=\"token function\">rcr2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>va <span class=\"token operator\">&lt;</span> proc<span class=\"token operator\">-></span>sz<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>write<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t\t\t<span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>mem <span class=\"token operator\">=</span> <span class=\"token function\">kalloc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>mem <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t\t\t\t<span class=\"token function\">cprintf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"out of memory\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t\t<span class=\"token function\">exit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t\t<span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token punctuation\">}</span>\n\t\t\t<span class=\"token function\">memset</span><span class=\"token punctuation\">(</span>mem<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> PGSIZE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token function\">cprintf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"kernel faulting in read/write page at %x\\n\"</span><span class=\"token punctuation\">,</span> va<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token function\">mappages</span><span class=\"token punctuation\">(</span>proc<span class=\"token operator\">-></span>pgdir<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>va<span class=\"token punctuation\">,</span> PGSIZE<span class=\"token punctuation\">,</span> <span class=\"token function\">v2p</span><span class=\"token punctuation\">(</span>mem<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> PTE_W<span class=\"token operator\">|</span>PTE_U<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span><span class=\"token punctuation\">{</span>\n\t\t\t<span class=\"token function\">cprintf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"kernel faulting in read-only zero page at %x\\n\"</span><span class=\"token punctuation\">,</span> va<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token function\">mappages</span><span class=\"token punctuation\">(</span>proc<span class=\"token operator\">-></span>pgdir<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>va<span class=\"token punctuation\">,</span> PGSIZE<span class=\"token punctuation\">,</span> <span class=\"token function\">v2p</span><span class=\"token punctuation\">(</span>zero_page<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> PTE_U<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t\t<span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>这里我并没有在xv6黎曼进行修改，因为不知道这个<code class=\"language-text\">zero_page</code>是应该在什么时候实现。</p>\n</li>\n<li>\n<p>优化：share kernel page mapping</p>\n<p>注意到<code class=\"language-text\">kvmalloc</code>会对所有的process都分配kernel page table。但是他们都是一样的。所以实际上可以统一一下。修改方式是改<code class=\"language-text\">kvmalloc</code>和<code class=\"language-text\">freevm</code>（不知道该怎么改，主要是现在的版本只有在main里面会调用一次<code class=\"language-text\">kvmalloc</code>，而不是每次执行新的process都会，所以就不知道该怎么弄了）</p>\n</li>\n<li>\n<p>优化：copy-on-write fork</p>\n<p>很多时候都是fork之后马上exec，如果赋值了会很浪费，所以把parent和child的内存先共享着，并且把child的内存设置为copy on write，也就是有写入的时候再复制。</p>\n<p>稍微具体一点就是修改<code class=\"language-text\">fork</code>来map pages copy-on-write （use extra available system bits in PTEs and PDEs）</p>\n<p>on page fault, make copy of page and map it read/write</p>\n</li>\n<li>\n<p>优化：demanding paging</p>\n<p>现在的exec可能会把整个文件都加载到内存中，这样会很慢，并且有可能没必要。可以先分配page，并标记为on demand，on default从file中读取对应的page。会遇到的挑战就是如果文件比物理内存还大怎么办？下一条会给出解决方案。</p>\n</li>\n<li>\n<p>Feature: 用比物理内存更大的虚拟内存</p>\n<p>有的时候可能需要比物理内存还大的内存。解决方法就是把内存中不常用的部分存在硬盘上。</p>\n<p>在硬盘和内存之间\"page in\" and out数据</p>\n<ul>\n<li>使用PTE来检测什么时候需要disk access</li>\n<li>用page table来找到least recent used disk block 并把其写回硬盘（LRU）</li>\n</ul>\n<p>当同时使用的内存小于RAM的时候，非常work。</p>\n</li>\n<li>\n<p>Feature: memory-mapped files</p>\n<p>通过load, store而不是read, write, lseek来access files以轻松访问文件的某一部分</p>\n<ul>\n<li>会使用<code class=\"language-text\">mmap</code> system call</li>\n<li>用memory offset而不是seeking</li>\n</ul>\n</li>\n<li>\n<p>Feature: distributed shared memory</p>\n<p>用虚拟内存来假装物理内存 is shared between several machines on the network</p>\n<p>注意只有read only page可以复制，而能够写入的不能。</p>\n</li>\n</ul>\n<h3>JOS and virtual memory</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    4 Gig --------&gt;  +------------------------------+\n                     |                              | RW/--\n                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n                     :              .               :\n                     :              .               :\n                     :              .               :\n                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| RW/--\n                     |                              | RW/--\n                     |   Remapped Physical Memory   | RW/--\n                     |                              | RW/--\n    KERNBASE, ----&gt;  +------------------------------+ 0xf0000000      --+\n    KSTACKTOP        |     CPU0&#39;s Kernel Stack      | RW/--  KSTKSIZE   |\n                     | - - - - - - - - - - - - - - -|                   |\n                     |      Invalid Memory (*)      | --/--  KSTKGAP    |\n                     +------------------------------+                   |\n                     |     CPU1&#39;s Kernel Stack      | RW/--  KSTKSIZE   |\n                     | - - - - - - - - - - - - - - -|                 PTSIZE\n                     |      Invalid Memory (*)      | --/--  KSTKGAP    |\n                     +------------------------------+                   |\n                     :              .               :                   |\n                     :              .               :                   |\n    MMIOLIM ------&gt;  +------------------------------+ 0xefc00000      --+\n                     |       Memory-mapped I/O      | RW/--  PTSIZE\n ULIM, MMIOBASE --&gt;  +------------------------------+ 0xef800000\n                     |  Cur. Page Table (User R-)   | R-/R-  PTSIZE\n    UVPT      ----&gt;  +------------------------------+ 0xef400000\n                     |          RO PAGES            | R-/R-  PTSIZE\n    UPAGES    ----&gt;  +------------------------------+ 0xef000000\n                     |           RO ENVS            | R-/R-  PTSIZE\n UTOP,UENVS ------&gt;  +------------------------------+ 0xeec00000\n UXSTACKTOP -/       |     User Exception Stack     | RW/RW  PGSIZE\n                     +------------------------------+ 0xeebff000\n                     |       Empty Memory (*)       | --/--  PGSIZE\n    USTACKTOP  ---&gt;  +------------------------------+ 0xeebfe000\n                     |      Normal User Stack       | RW/RW  PGSIZE\n                     +------------------------------+ 0xeebfd000\n                     |                              |\n                     |                              |\n                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n                     .                              .\n                     .                              .\n                     .                              .\n                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|\n                     |     Program Data &amp; Heap      |\n    UTEXT --------&gt;  +------------------------------+ 0x00800000\n    PFTEMP -------&gt;  |       Empty Memory (*)       |        PTSIZE\n                     |                              |\n    UTEMP --------&gt;  +------------------------------+ 0x00400000      --+\n                     |       Empty Memory (*)       |                   |\n                     | - - - - - - - - - - - - - - -|                   |\n                     |  User STAB Data (optional)   |                 PTSIZE\n    USTABDATA ----&gt;  +------------------------------+ 0x00200000        |\n                     |       Empty Memory (*)       |                   |\n    0 ------------&gt;  +------------------------------+                 --+</code></pre></div>\n<ul>\n<li>segment仅仅用来切换隐私权限。</li>\n<li>用paging来处理进程的地址空间。</li>\n<li>用pagine来管理地址空间的访问权限。</li>\n</ul>\n<h3>The UVPD</h3>\n<p>不是很明白这个的全称是啥？User Virtual Page Directory?</p>\n<p>下图和下面的代码很好的演示了如何能够找到一个虚拟地址。</p>\n<p><img src=\"https://pdos.csail.mit.edu/6.828/2014/lec/pagetables.png\" alt=\"访问方式\"></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">pd = lcr3();\npt = *(pd + 4*PDX);\npage = *(pt + 4*PTX);</code></pre></div>\n<p>但是这种方式我们该如何用VA来访问PD或者某一个page table呢？或者说PD和PT也应该有自己的映射才对。采用的方法是通过让PD自己指向自己，也就是两步都是指向自己的开头，在JOS中V是<code class=\"language-text\">0x3BD</code>。UVPD（应该就是page directory）是 (0x3BD&#x3C;&#x3C;22)|(0x3BD&#x3C;&#x3C;12)，然后如下图：</p>\n<p><img src=\"https://pdos.csail.mit.edu/6.828/2014/lec/vpt.png\" alt=\"PD指向自己\"></p>\n<p>这样如果PDX和PTX都是V，两次之后还是会指向PD，如果PDX=V但是PTX!=V，那么运行之后就会指向某一个page table。通过以上的方式，我们就把虚拟地址映射到了PD和PT了。</p>","frontmatter":{"title":"6.828 笔记6"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/6.828-note6/"}}}