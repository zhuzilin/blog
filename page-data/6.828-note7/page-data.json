{"componentChunkName":"component---src-templates-blog-post-js","path":"/6.828-note7/","webpackCompilationHash":"7b874fc567e065ad1396","result":{"data":{"markdownRemark":{"html":"<p>这里会记录阅读6.828课程lecture note的我的个人笔记。可能会中英混杂，不是很适合外人阅读，也请见谅。</p>\n<h2>Lecture 8: Interrupts, System calls, and Exceptions</h2>\n<p>这次的主题就是说当硬件want attention的时候，kernel该如何进行中断。发生这件事主要有3种情况：</p>\n<ul>\n<li>Exceptions (page fault, divide by zero)</li>\n<li>System calls (<code class=\"language-text\">INT</code>, intended exception)</li>\n<li>Interrupts (devices want attention)</li>\n</ul>\n<p>注意在术语上<code class=\"language-text\">trap</code>是被当前进程引发的，如system call，而interrupt是由外界device触发的。</p>\n<p>device interrupt都来自哪里呢？</p>\n<ul>\n<li>CPUs, </li>\n<li>LAPICs (Local Advaned Programmable Interrupt Controller)，一个负责接受/发送中断的芯片，集成在CPU内部。</li>\n<li>IOAPIC (I/O Advanced Programmable Interrupt Controller)，通常位于南桥，负责外部IO设备发来的中断。</li>\n<li>devices</li>\n<li>data bus</li>\n<li>interrupt bus</li>\n</ul>\n<p>中断会告诉kernel，某个设备want attention。kernel中的驱动来负责告诉设备之后该如何do things。</p>\n<p>很多时候interrupt handler会直接调用相关的驱动。</p>\n<p><code class=\"language-text\">trap()</code>函数是如何知道哪个设备出发了中断？</p>\n<ul>\n<li>\n<p>kernel设置LAPIC/IOAPIC ，把某个类型的中断设置为对应的vector number</p>\n<ul>\n<li>page fault也有vectors</li>\n<li>LAPIC/IOAPIC是PC的常规硬件，其中每个cpu有一个LAPIC</li>\n</ul>\n</li>\n<li>\n<p>IDT (interrupt descriptor table)用vector number来联系一个instruction address</p>\n<ul>\n<li>这个table的内容是怎么设置的可以看下面的<code class=\"language-text\">SETGATE</code>函数。</li>\n<li>IDT的格式是由Intel定义的，由kernel设置的</li>\n</ul>\n</li>\n<li>每个vector都会跳到<code class=\"language-text\">alltraps</code></li>\n<li>CPU会通过IDT发送各种trap，其中lower 32 IDT entries有特殊的含义。</li>\n<li>在xv6中，system call(IRQ)被设置为<code class=\"language-text\">0x40</code>.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">diagram:\n  IRQ or trap, IDT table, vectors, alltraps\n  IDT:\n    0: divide by zero\n    13: general protection\n    14: page fault\n    32-255: device IRQs\n    32: timer\n    33: keyboard\n    46: IDE\n    64: INT</code></pre></div>\n<h3>How xv6 sets up the iterrupt vector machinery</h3>\n<p>那么xv6中interrupt vector机制是如何被设置的呢？</p>\n<p>首先是在<code class=\"language-text\">main.c</code>中前后运行了<code class=\"language-text\">lapicinit()</code>、<code class=\"language-text\">ioapicinit()</code>与<code class=\"language-text\">tvinit()</code>。</p>\n<p>在<code class=\"language-text\">lapicinit()</code>中告诉LAPIC这个硬件把例如timer设置为对应的vector number(32)。<code class=\"language-text\">ioapicinit()</code>设置和redirection table（这是啥。。。）相关的中断。最后<code class=\"language-text\">tvinit()</code>用<code class=\"language-text\">SETGATE</code>这个宏来把vector number指向code at vector[i]，也就是vector number对应的中断发生的时候需要运行的代码。</p>\n<p>下面来看一下具体的代码：</p>\n<p>首先是<code class=\"language-text\">lapicinit()</code>，这个函数里面是像这样的方式设置：</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token function\">lapicw</span><span class=\"token punctuation\">(</span>TIMER<span class=\"token punctuation\">,</span> PERIODIC <span class=\"token operator\">|</span> <span class=\"token punctuation\">(</span>T_IRQ0 <span class=\"token operator\">+</span> IRQ_TIMER<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>而这个函数是：</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">volatile</span> uint <span class=\"token operator\">*</span>lapic<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// Initialized in mp.c</span>\n\n<span class=\"token comment\">//PAGEBREAK!</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span>\n<span class=\"token function\">lapicw</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> index<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> value<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n  lapic<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span>\n  lapic<span class=\"token punctuation\">[</span>ID<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// wait for write to finish, by reading</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>这里的<code class=\"language-text\">lapic</code>的地址在<code class=\"language-text\">mp.c/mpinit()</code>中初始化了。</p>\n<p>然后看一下<code class=\"language-text\">tvinit()</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">extern</span> uint vectors<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// in vectors.S: array of 256 entry pointers</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token keyword\">void</span>\n<span class=\"token function\">tvinit</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">256</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">SETGATE</span><span class=\"token punctuation\">(</span>idt<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> SEG_KCODE<span class=\"token operator\">&lt;&lt;</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> vectors<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">SETGATE</span><span class=\"token punctuation\">(</span>idt<span class=\"token punctuation\">[</span>T_SYSCALL<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> SEG_KCODE<span class=\"token operator\">&lt;&lt;</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> vectors<span class=\"token punctuation\">[</span>T_SYSCALL<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> DPL_USER<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">initlock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>tickslock<span class=\"token punctuation\">,</span> <span class=\"token string\">\"time\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>上面的这个<code class=\"language-text\">vectors</code>中的某一个指会对应如下的一段汇编，如：</p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\"># vector.S\n.globl vector32\nvector32:\n  pushl $0\n  pushl $32\n  jmp alltraps</code></pre></div>\n<p><code class=\"language-text\">vector.S</code>是由<code class=\"language-text\">vector.pl</code>生成的（貌似之前提到过）。先<code class=\"language-text\">pushl</code>一个fakes \"error\" slot in trapframe（应该是指<code class=\"language-text\">$0</code>了），因为硬件对于某些trap并不push（没懂）。第二个<code class=\"language-text\">pushl</code>就是vector number了，对应<code class=\"language-text\">tf-&gt;trapno</code>。</p>\n<p>下面的这个<code class=\"language-text\">SETGATE</code>宏是上面用来设置IDT里面的每个vector用的。</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// Set up a normal interrupt/trap gate descriptor.</span>\n<span class=\"token comment\">// - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate.</span>\n<span class=\"token comment\">//   interrupt gate clears FL_IF, trap gate leaves FL_IF alone</span>\n<span class=\"token comment\">// - sel: Code segment selector for interrupt/trap handler</span>\n<span class=\"token comment\">// - off: Offset in code segment for interrupt/trap handler</span>\n<span class=\"token comment\">// - dpl: Descriptor Privilege Level -</span>\n<span class=\"token comment\">//        the privilege level required for software to invoke</span>\n<span class=\"token comment\">//        this interrupt/trap gate explicitly using an int instruction.</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> SETGATE(gate, istrap, sel, off, d)                \\\n{                                                         \\\n  (gate).off_15_0 = (uint)(off) &amp; 0xffff;                \\\n  (gate).cs = (sel);                                      \\\n  (gate).args = 0;                                        \\\n  (gate).rsv1 = 0;                                        \\\n  (gate).type = (istrap) ? STS_TG32 : STS_IG32;           \\\n  (gate).s = 0;                                           \\\n  (gate).dpl = (d);                                       \\\n  (gate).p = 1;                                           \\\n  (gate).off_31_16 = (uint)(off) >> 16;                  \\\n}</span></code></pre></div>\n<p>设置好之后就可以让中断跳进<code class=\"language-text\">alltraps</code>了。</p>\n<p><code class=\"language-text\">tvinit</code>中大多数都是机械性的设置，唯有<code class=\"language-text\">T_SYSCALL</code>里面设置了<code class=\"language-text\">istrap=1</code>，也就是让系统在进行system call的时候仍然<strong>保留中断</strong>，而其他的device interrupt就不保留了。</p>\n<p>思考两个问题（我现在还不明白...）</p>\n<ul>\n<li>为什么在system call的过程中允许中断？</li>\n<li>为什么在interrupt handing之中disable interrupt。</li>\n</ul>\n<p>硬件如何知道interrupt里面调用的代码该用user stack还是kernel stack（例如hw xv6 cpu alarm就是用user space）？</p>\n<ul>\n<li>\n<p>当因为中断从user space到kernel space的时候，hardware-defined TSS (task state segment) 让kernel获取CPU的一些详细信息，如寄存器状态，I/O permission之类的。这样就可以知道是应该使用哪个stack了。</p>\n<ul>\n<li>TSS是one per CPU，从而使得不同CPU可以运行不同的进程，并take traps on different stacks</li>\n</ul>\n</li>\n<li><code class=\"language-text\">proc.c/scheduler()</code>: one per CPU</li>\n<li>\n<p><code class=\"language-text\">vm.c/switchuvm()</code></p>\n<p>tells CPU what kernel stack to use</p>\n<p>tells kernel what page table to use</p>\n</li>\n</ul>\n<p>在trapping into kernel之前，CPU应该把<code class=\"language-text\">eip</code>保存为正在运行的instruct。</p>\n<p>这中间有很长一部分是讲解cpu alarm作业的，这部分内容记录在了对应的作业的博文中。</p>\n<h3>Interrupt more generally</h3>\n<p>中断引入了并行的问题：</p>\n<ul>\n<li>因为代码运行过程中可能会有其他的代码因中断而被运行。</li>\n<li>\n<p>对于用户代码来说，因为kernel会存储状态，所以影响不大，但是对于kernel代码来说，就可能很糟糕了。</p>\n<p>例如：</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">my code<span class=\"token operator\">:</span>               interrupt<span class=\"token operator\">:</span>\n    <span class=\"token operator\">%</span>eax <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    <span class=\"token keyword\">if</span> <span class=\"token operator\">%</span>eax <span class=\"token operator\">=</span> <span class=\"token number\">0</span> then        <span class=\"token operator\">%</span>eax <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n      <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>我们不知道<code class=\"language-text\">f</code>是不是被执行了。</p>\n<p>所以为了让一段代码<code class=\"language-text\">atomic</code>，我们需要关闭中断，也就是使用</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token function\">cli</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\">// 和汇编中的cli，也就是clear interrupt同义</span>\n<span class=\"token function\">sti</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\">// 和汇编中的sti，也就是set interrupt同以</span></code></pre></div>\n</li>\n</ul>\n<p>这是我们对并行的初探，之后讨论锁的时候还会再来讨论。</p>\n<p>Interrupt evolution</p>\n<ul>\n<li>\n<p>Interrupt在归去是相对快的，现在却是相对慢的了。</p>\n<p>因为老的方法是所有事件都会触法中断，硬件简单，软件智能。</p>\n<p>而新的方法是硬件在中断之前会事先完成一些工作。</p>\n</li>\n<li>一些设备可以在不到1微秒的时间内生成中断。比如GB ethernet。</li>\n<li>而中断却需要大约微妙时间量级。因为需要保存和恢复状态，同时中断伴随着cache misses。</li>\n<li>那么我们该如何处理间隔小于1微秒的中断呢？</li>\n</ul>\n<h3>Polling: 另一种和设备交互的方法。</h3>\n<ul>\n<li>\n<p>处理器spin until device wants attention（按一定周期检查设备是否有需要）</p>\n<p>这种方法虽然在设备很慢的时候很浪费，但是设备很快的时候就很好了，因为不需要保存寄存器等等。</p>\n<p>If events are always waiting, not need to keep alerting the software. (这句没懂)</p>\n</li>\n</ul>\n<p>Polling versus Interrupt</p>\n<ul>\n<li>对high-rate device用polling，慢的用interrupt</li>\n<li>也可以在polling和interrupt之间相互切换，如果rate is low用interrupt，反之用polling</li>\n<li>\n<p>Faster forwarding of interrupts to user space（这里没明白是说polling会帮助还是interrupt可以有更好的机制）</p>\n<p>for page faults and user-handled devices</p>\n<p>h/w delivers directly to user, w/o kernel intervention?</p>\n<p>faster forwarding path through kernel?</p>\n</li>\n</ul>","frontmatter":{"title":"6.828 笔记7","date":"2019-02-27T12:20:00.000Z","tags":["OS","6.828"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/6.828-note7/"}}}