{"data":{"markdownRemark":{"html":"<p>This post is full of quote right now. Maybe sometime I will add some of my own understanding. But at the moment, the words in the reference has already good enough.</p>\n<h2>module</h2>\n<p>From the document, the definition of module in python is</p>\n<blockquote>\n<p>A module is a file containing Python definitions and statements. The file name is the module name with the suffix <code>.py</code> appended.</p>\n</blockquote>\n<p>The use of modules saves the authors of different modules from having to worry about each other’s global variable names.</p>\n<h3>__name__</h3>\n<blockquote>\n<p>Within a module, the module’s name (as a string) is available as the value of the global variable<code>__name__</code></p>\n</blockquote>\n<p>Therefore, any <code>.py</code> file is a module.  And any module can be imported by the <code>import</code> statement with its <code>__name__</code>.</p>\n<p>Then what is <code>if __name__ == \"__main__:\"</code>? </p>\n<blockquote>\n<p><code>'__main__'</code> is the name of the scope in which top-level code executes. A module’s <strong>name</strong> is set equal to <code>'__main__'</code> when read from standard input, a script, or from an interactive prompt.</p>\n</blockquote>\n\n    <div class=\"gatsby-highlight\" data-language=\"bash\">\n      <pre class=\" cm-s-default\"\n      ><code><span>$ python\n>>> __name__\n'__main__'</span></code></pre>\n    </div>\n<p>Notice that if a module is run by <code>python -m</code>, the name would also be set as <code>'__main__'</code>.</p>\n<h3>Symbol table</h3>\n<blockquote>\n<p>Each module has its own private symbol table, which is used as the global symbol table by all functions defined in the module. Thus, the author of a module can use global variables in the module without worrying about accidental clashes with a user’s global variables.</p>\n</blockquote>\n<blockquote>\n<p>The imported module names are placed in the importing module’s global symbol table</p>\n</blockquote>\n<h3>.pyc</h3>\n<blockquote>\n<p>Python checks the modification date of the source against the compiled version to see if it’s out of date and needs to be recompiled. This is a completely automatic process. Also, the compiled modules are platform-independent, so the same library can be shared among systems with different architectures.</p>\n<p>Python does not check the cache in two circumstances. First, it always recompiles and does not store the result for the module that’s loaded directly from the command line. Second, it does not check the cache if there is no source module. To support a non-source (compiled only) distribution, the compiled module must be in the source directory, and there must not be a source module.</p>\n</blockquote>\n<h2>package</h2>\n<p>Also from the document, a package is:</p>\n<blockquote>\n<p>Packages are a way of structuring Python’s module namespace by using “dotted module names”. For example, the module name <code>A.B</code> designates a submodule named <code>B</code> in a package named <code>A</code>.</p>\n</blockquote>\n<p>It is possible and convenient that we could have the same module name in different package.</p>\n<blockquote>\n<p>You can think of packages as the directories on a file system and modules as files within directories, but don’t take this analogy too literally since packages and modules need not originate from the file system.</p>\n</blockquote>\n<p>In fact, package is a special kind of module:</p>\n<blockquote>\n<p>It’s important to keep in mind that all packages are modules, but not all modules are packages. Or put another way, packages are just a special kind of module. Specifically, any module that contains a <code>__path__</code> attribute is considered a package.</p>\n</blockquote>\n<p>There are two kinds of packages: regular packages and namespace packages, here we will only talk about the regular ones.</p>\n<h3><em>\\</em>init__.py</h3>\n<blockquote>\n<p>A regular package is typically implemented as a directory containing an <code>__init__.py</code> file. When a regular package is imported, this <code>__init__.py</code> file is implicitly executed, and the objects it defines are bound to names in the package’s namespace. The <code>__init__.py</code> file can contain the same Python code that any other module can contain, and Python will add some additional attributes to the module when it is imported.</p>\n</blockquote>\n<h3>__main__.py</h3>\n<p>Many may have heard of <code>__init__.py</code> but I believe few have heard of <code>__main__.py</code>. This file would be run as the entrance of a directory. </p>\n<blockquote>\n<p>For a package, the same effect can be achieved by including a <code>__main__.py</code> module, the contents of which will be executed when the module is run with <code>-m</code>.</p>\n</blockquote>\n<p>For example, if the file directory is (to show the directory, use <a href=\"https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/tree\">tree</a>)</p>\n\n    <div class=\"gatsby-highlight\" data-language=\"bash\">\n      <pre class=\" cm-s-default\"\n      ><code><span>hello\n    hello.py\n    __main__.py</span></code></pre>\n    </div>\n<p>With the code:</p>\n\n    <div class=\"gatsby-highlight\" data-language=\"python\">\n      <pre class=\" cm-s-default\"\n      ><code><span class=\"cm-comment\"># __main__.py</span><span>\n</span><span class=\"cm-builtin\">print</span><span>(</span><span class=\"cm-string\">\"This is __main__\"</span><span>)</span><span>\n\n</span><span class=\"cm-comment\"># hello.py</span><span>\n</span><span class=\"cm-builtin\">print</span><span>(</span><span class=\"cm-string\">\"hello world\"</span><span>)</span></code></pre>\n    </div>\n<p>And we run python on the </p>\n\n    <div class=\"gatsby-highlight\" data-language=\"bash\">\n      <pre class=\" cm-s-default\"\n      ><code><span>$ python hello/\nThis is __main__</span></code></pre>\n    </div>\n<p>If we delete the <code>__main__.py</code> and run again, the result would be</p>\n\n    <div class=\"gatsby-highlight\" data-language=\"bash\">\n      <pre class=\" cm-s-default\"\n      ><code><span>$ python hello/\nXXX: can't find '__main__' module in 'hello'</span></code></pre>\n    </div>\n<h2>Import</h2>\n<blockquote>\n<p>Note that relative imports are based on the name of the current module. Since the name of the main module is always <code>\"__main__\"</code>, modules intended for use as the main module of a Python application must always use absolute imports.</p>\n</blockquote>\n<h2>Reference</h2>\n<ol>\n<li><a href=\"https://docs.python.org/3/tutorial/modules.html\">https://docs.python.org/3/tutorial/modules.html</a></li>\n<li><a href=\"https://docs.python.org/3/reference/import.html\">https://docs.python.org/3/reference/import.html</a></li>\n<li><a href=\"https://docs.python.org/3/library/%5C_%5C_main%5C_%5C_.html\">https://docs.python.org/3/library/__main__.html</a></li>\n</ol>","frontmatter":{"title":"About Python modularity"}}},"pageContext":{"slug":"/about-python-modularity/"}}