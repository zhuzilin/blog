{"data":{"markdownRemark":{"html":"<p>这里会记录阅读6.828课程lecture note的我的个人笔记。可能会中英混杂，不是很适合外人阅读，也请见谅。</p>\n<h2>Lecture 8: Interrupts, System calls, and Exceptions</h2>\n<p>这次的主题就是说当硬件want attention的时候，kernel该如何进行中断。发生这件事主要有3种情况：</p>\n<ul>\n<li>Exceptions (page fault, divide by zero)</li>\n<li>System calls (<code class=\"language-text\">INT</code>, intended exception)</li>\n<li>Interrupts (devices want attention)</li>\n</ul>\n<p>注意在术语上<code class=\"language-text\">trap</code>是被当前进程引发的，如system call，而interrupt是由外界device触发的。</p>\n<p>device interrupt都来自哪里呢？</p>\n<ul>\n<li>CPUs, </li>\n<li>LAPICs (Local Advaned Programmable Interrupt Controller)，一个负责接受/发送中断的芯片，集成在CPU内部。</li>\n<li>IOAPIC (I/O Advanced Programmable Interrupt Controller)，通常位于南桥，负责外部IO设备发来的中断。</li>\n<li>devices</li>\n<li>data bus</li>\n<li>interrupt bus</li>\n</ul>\n<p>中断会告诉kernel，某个设备want attention。kernel中的驱动来负责告诉设备之后该如何do things。</p>\n<p>很多时候interrupt handler会直接调用相关的驱动。</p>\n<p><code class=\"language-text\">trap()</code>函数是如何知道哪个设备出发了中断？</p>\n<ul>\n<li>\n<p>kernrl告诉LAPIC/IOAPIC 应当使用哪个vector number</p>\n<ul>\n<li>page fault也有vectors</li>\n<li>LAPIC/IOAPIC是PC的常规硬件，其中每个cpu有一个LAPIC</li>\n</ul>\n</li>\n<li>\n<p>IDT用vector number来联系一个instruction address</p>\n<ul>\n<li>IDT的格式是由Intel定义的，由kernel设置的</li>\n</ul>\n</li>\n<li>每个vector都会跳到<code class=\"language-text\">alltraps</code></li>\n<li>CPU会通过IDT发送各种trap，其中lower 32 IDT entries有特殊的含义。</li>\n<li>在xv6中，system call(IRQ)被设置为<code class=\"language-text\">0x40</code>.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">diagram:\n  IRQ or trap, IDT table, vectors, alltraps\n  IDT:\n    0: divide by zero\n    13: general protection\n    14: page fault\n    32-255: device IRQs\n    32: timer\n    33: keyboard\n    46: IDE\n    64: INT</code></pre></div>\n<p> 那么xv6中interrupt vector机制是如何被设置的呢？</p>\n<p>首先是在<code class=\"language-text\">main.c</code>中前后运行了<code class=\"language-text\">lapicinit()</code>、<code class=\"language-text\">ioapicinit()</code>与<code class=\"language-text\">tvinit()</code>。</p>\n<p>在<code class=\"language-text\">lapicinit()</code>中告诉LAPIC这个硬件把例如timer设置为对应的vector number(32)。<code class=\"language-text\">ioapicinit()</code>设置和redirection table（这是啥。。。）相关的中断。最后<code class=\"language-text\">tvinit()</code>用<code class=\"language-text\">SETGATE</code>这个宏来把vector number指向code at vector[i]，也就是vector number对应的中断发生的时候需要运行的代码。</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// Set up a normal interrupt/trap gate descriptor.</span>\n<span class=\"token comment\">// - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate.</span>\n<span class=\"token comment\">//   interrupt gate clears FL_IF, trap gate leaves FL_IF alone</span>\n<span class=\"token comment\">// - sel: Code segment selector for interrupt/trap handler</span>\n<span class=\"token comment\">// - off: Offset in code segment for interrupt/trap handler</span>\n<span class=\"token comment\">// - dpl: Descriptor Privilege Level -</span>\n<span class=\"token comment\">//        the privilege level required for software to invoke</span>\n<span class=\"token comment\">//        this interrupt/trap gate explicitly using an int instruction.</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> SETGATE(gate, istrap, sel, off, d)                \\\n{                                                         \\\n  (gate).off_15_0 = (uint)(off) &amp; 0xffff;                \\\n  (gate).cs = (sel);                                      \\\n  (gate).args = 0;                                        \\\n  (gate).rsv1 = 0;                                        \\\n  (gate).type = (istrap) ? STS_TG32 : STS_IG32;           \\\n  (gate).s = 0;                                           \\\n  (gate).dpl = (d);                                       \\\n  (gate).p = 1;                                           \\\n  (gate).off_31_16 = (uint)(off) >> 16;                  \\\n}</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">extern</span> uint vectors<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// in vectors.S: array of 256 entry pointers</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token keyword\">void</span>\n<span class=\"token function\">tvinit</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">256</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">SETGATE</span><span class=\"token punctuation\">(</span>idt<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> SEG_KCODE<span class=\"token operator\">&lt;&lt;</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> vectors<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">SETGATE</span><span class=\"token punctuation\">(</span>idt<span class=\"token punctuation\">[</span>T_SYSCALL<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> SEG_KCODE<span class=\"token operator\">&lt;&lt;</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> vectors<span class=\"token punctuation\">[</span>T_SYSCALL<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> DPL_USER<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">initlock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>tickslock<span class=\"token punctuation\">,</span> <span class=\"token string\">\"time\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>上面的这个<code class=\"language-text\">vectors</code>中的某一个指会对应如下的一段汇编，如：</p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\"># vector.S\n.globl vector32\nvector32:\n  pushl $0\n  pushl $32\n  jmp alltraps</code></pre></div>\n<p><code class=\"language-text\">vector.S</code>是由<code class=\"language-text\">vector.pl</code>生成的（貌似之前提到过）。先<code class=\"language-text\">pushl</code>一个fakes \"error\" slot in trapframe（应该是指<code class=\"language-text\">$0</code>了），因为硬件对于某些trap并不push（没懂）。第二个<code class=\"language-text\">pushl</code>就是vector number了，对应<code class=\"language-text\">tf-&gt;trapno</code>。</p>\n<p>设置好之后就可以让中断跳进<code class=\"language-text\">alltraps</code>了。</p>\n<p><code class=\"language-text\">tvinit</code>中大多数都是机械性的设置，唯有<code class=\"language-text\">T_SYSCALL</code>里面设置了<code class=\"language-text\">istrap=1</code>，也就是让系统在进行system call的时候仍然<strong>保留中断</strong>，而其他的device interrupt就不保留了。</p>\n<p>思考两个问题（我现在还不明白...）</p>\n<ul>\n<li>为什么在system call的过程中允许中断？</li>\n<li>为什么在interrupt handing之中disable interrupt。</li>\n</ul>\n<p>硬件如何知道interrupt里面调用的代码该用user stack还是kernel stack（例如hw xv6 cpu alarm就是用user space）？</p>\n<ul>\n<li>\n<p>当因为中断从user space到kernel space的时候，hardware-defined TSS (task state segment) 让kernel获取CPU的一些详细信息，如寄存器状态，I/O permission之类的。这样就可以知道是应该使用哪个stack了。</p>\n<ul>\n<li>TSS是one per CPU，从而使得不同CPU可以运行不同的进程，并take traps on different stacks</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">proc.c/scheduler()</code>: one per CPU</p>\n</li>\n<li>\n<p><code class=\"language-text\">vm.c/switchuvm()</code></p>\n<p>tells CPU what kernel stack to use</p>\n<p>tells kernel what page table to use</p>\n</li>\n</ul>\n<p>在trapping into kernel之前，CPU应该把<code class=\"language-text\">eip</code>保存为正在运行的instruct。</p>\n<p>这中间有很长一部分是讲解cpu alarm作业的，这部分内容记录在了对应的作业的博文中。</p>\n<p>我们来从一个更笼统的角度看代中断：</p>","frontmatter":{"title":"6.828 笔记6"}}},"pageContext":{"slug":"/6.828-note7/"}}