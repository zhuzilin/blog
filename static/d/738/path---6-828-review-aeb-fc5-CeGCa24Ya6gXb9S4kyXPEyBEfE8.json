{"data":{"markdownRemark":{"html":"<h2>Boot Loader</h2>\n<p>首先当机器启动的时候，会自动加载BIOS。BIOS会检查有无bootable disk，如果有的话，会加载其boot loader（实际上就是加载boot loader）的ELF，也就是boot loader对应的二进制文件。其位于第一个IDE disk的第一个sector，之后的sector就是kernel了。</p>\n<p>然后boot loader会首先把处理器从16位的real mode转化为32位的protected mode，然后读一个page进来，也就是读进来kernel的ELF header，通过其ELF header把kernel一个sector一个sector地读进来，然后跳转到kernel ELF header里面记录的入口，从而进入kernel。</p>\n<p>值得注意的是kernel和boot loader的ELF的不同。也就是kernel的LMA和VMA是不同的，也就是加载到内存的位置和开始运行的位置是不同的。这是因为kernel额VMA是虚拟地址，其实际映射是<code class=\"language-text\">0x00000000</code>到<code class=\"language-text\">0x0fffffff</code>映射到<code class=\"language-text\">0xf0000000</code>到<code class=\"language-text\">0xffffffff</code>。所以即使VMA是高地址的<code class=\"language-text\">0xf0100000</code>实际上运行的时候对应的物理地址还是<code class=\"language-text\">0x00100000</code>，也就是LMA对应的地址。</p>\n<h2>Isolation mechanism</h2>\n<p>kernel通过硬件机制辅助来进行process isolation。硬件上的user/kernel mode flag，在x86上叫CPL，是<code class=\"language-text\">%cs</code>的后两位，CPL=0就是kernel mode，=3就是user mode。通过给几个permissible kernel entry points来跳到kernel里面去，这样就可以防止在转换的时候用户可以破坏Kernel。</p>\n<p>对内存的隔离是利用address space，其目的是可以让每个进程有内存来访问自己的code，variables，heap，stack 并不访问其他的内存。</p>\n<h2>System Call</h2>\n<p>system call的具体流程如下：</p>","frontmatter":{"title":"6.828 总结"}}},"pageContext":{"slug":"/6.828-review/"}}