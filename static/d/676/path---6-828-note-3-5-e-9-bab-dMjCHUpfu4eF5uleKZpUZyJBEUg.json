{"data":{"markdownRemark":{"html":"<p>这里会记录阅读6.828课程lecture note的我的个人笔记。可能会中英混杂，不是很适合外人阅读，也请见谅。</p>\n<h2>Lecture 3: C and gdb</h2>\n<p>这一讲基本上都是介绍工具，就不在此记录了，C的部分可以看K&#x26;R，gdb的部分可以直接搜课件。<code class=\"language-text\">pointer.c</code>的例子应该在lab1中已经进行了解释。</p>\n<h2>Lecture 4: Shell &#x26; OS organization</h2>\n<h3>Lecture Topic</h3>\n<ul>\n<li>\n<p>kernel system call API</p>\n<ul>\n<li>细节与设计</li>\n<li>isolation, multiplexing and sharing.</li>\n</ul>\n</li>\n<li>通过hw2来进行说明。</li>\n</ul>\n<h3>Overview Diagram</h3>\n<ul>\n<li>user / kernel</li>\n<li>process = address space + thread(s)，就是一个运行中的程序</li>\n<li><code class=\"language-text\">app -&gt; printf() -&gt; write() -&gt; SYSTEM CALL -&gt; sys_write() -&gt; ...</code></li>\n<li>user-level library是每个app自己的东西</li>\n<li>而kernel internal function不能被用户调用</li>\n</ul>\n<p>回顾作业（这部分就直接放在hw xv6 shell的那篇里面讲了，就不在这里赘述）。</p>\n<h3>UNIX system call observation</h3>\n<ul>\n<li>\n<p>fork/exec看起来很浪费，因为需要先复制parent的内存到child，之后再用exec替代。为什么不合二为一呢？</p>\n<p>因为分开非常方便。同时实际上因为使用了一些技巧（在lab4中有实现，就是利用page fault进行lazy allocation），<code class=\"language-text\">fork</code>的开销很小。</p>\n</li>\n<li>\n<p>file descriptor设计</p>\n<p>FDs are a level of indirection。</p>\n<ul>\n<li>真正的I/O环境被藏在内核里了。</li>\n<li>通过fork, exec进行保留。</li>\n<li>imagine writefile(filename, offset, buf size) (这啥意思。。。)</li>\n</ul>\n<p>FD统一了console, pipe和files的接口</p>\n</li>\n<li>\n<p>整体的设计哲学：用简洁的接口相互组合实现复杂功能。</p>\n</li>\n<li>\n<p>为什么kernel需要pip而不用一个临时文件进行redirect:</p>\n<p>pipe有如下四点优势：</p>\n<blockquote>\n<ul>\n<li>\n<p>pipes automatically clean themselves up; with the file redirection, a shell would have to be\ncareful to remove /tmp/xyz when done. </p>\n</li>\n<li>\n<p>pipes can pass arbitrarily long streams of data, while file redirection requires enough free space on disk to store all the data. (这也是为什么pipe需要多个指令同时执行)</p>\n</li>\n<li>\n<p>pipes allow for parallel execution of pipeline stages, while the file approach requires the first program to finish before the second starts. </p>\n</li>\n<li>\n<p>if you are implementing inter-process communication, pipes’ blocking reads and writes are more efficient than the non-blocking semantics of files.</p>\n</li>\n</ul>\n</blockquote>\n</li>\n<li>\n<p>为什么kernel的system call只用int char作为buffer，而不用一个pointer指向kernel file object?</p>\n<p>我不确定这个是为什么，感觉就是为了isolation吧，如果给一个pointer，那用户就很容易把kernel代码搞崩。</p>\n</li>\n<li>\n<p>核心的unix system call已经很古老了，have they held up well?</p>\n<p>yes, very successful!</p>\n<p>不过UNIX的一些地方不是完美的：</p>\n<ul>\n<li>很多时候system call并不需要很方便程序员使用，因为会被包装。</li>\n<li>apps may have little to do with files &#x26;c, e.g. on smartphon （这个没懂。。。）</li>\n</ul>\n<p>一些UNIX abstractions不够高效：</p>\n<ul>\n<li>几个G的进程fork起来就很慢了</li>\n<li>FD隐藏了一些可能很重要的细节内容，如硬盘上的block size，网络数据的timing and size (这两个应该都是被buffer给盖住了)</li>\n</ul>\n<p>所以一直都有备用方案：</p>\n<ul>\n<li>有的是一些新的system call</li>\n<li>有的就是完全抛弃UNIX的这一套另起炉灶。</li>\n</ul>\n</li>\n</ul>\n<h3>OS organization</h3>\n<p>这部分最好先阅读一下xv6 book的第一章。</p>\n<p>OS的主要目的之一是进行isolation。</p>\n<ul>\n<li>处理器提供了user mode和kernel mode，前者不能处理privileged instructions</li>\n<li>OS是运行在kernel mode的</li>\n</ul>\n<p>monolithic kernel</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/7/78/Kernel-monolithic_zh.svg\" alt=\"monolithic kernel\"></p>\n<ul>\n<li>xv6用了一种传统的设计，monolithic kernel，也就是OS完全运行于kernel mode</li>\n<li>kernel interface == system call interface</li>\n<li>这样的有点是方便子系统相互协调，缺点是子系统之间的interaction会很复杂，也就bug prone</li>\n</ul>\n<p>microkernel design</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/6/67/OS-structure.svg\" alt=\"microkernel\"></p>\n<ul>\n<li>另外一种设计，让OS作为一个普通的user program。如file system再一个file server里。</li>\n<li>kernel implements minimal mechanism to run services in user space processes with memory 如IPC</li>\n<li>kernel interface != system call interface</li>\n<li>好处是isolation更好了</li>\n<li>坏处是性能会比较差</li>\n</ul>\n<p>exokernel</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/1/14/Exokernel.svg\" alt=\"exokernel\"></p>\n<ul>\n<li>\n<p>apps可以semi-directly使用</p>\n<p>apps can use hardware semi-directly, but O/S isolates\ne.g. app can read/write own page table, but O/S audits\ne.g. app can read/write disk blocks, but O/S tracks block owners\ngood: more flexibility for demanding applications\njos will be a mix of microkernel and exokernel</p>\n<p>（这里不是很明白，可能写完JOS作业就懂了...）</p>\n</li>\n</ul>\n<p>之后会有不适用硬件支撑kernel/user mode的isolation，叫Singularity O/S，之后的课中会讲到。</p>","frontmatter":{"title":"6.828 笔记3"}}},"pageContext":{"slug":"/6.828-note3/"}}