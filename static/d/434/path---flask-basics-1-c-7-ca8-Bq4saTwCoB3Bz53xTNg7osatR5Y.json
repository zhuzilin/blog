{"data":{"markdownRemark":{"html":"<p>During my internship at Face++, I participated in upgrading a tool platform for our group to package training data and test models. In this platform, we used flask as backend and here are some basics about this light weight framework.</p>\n<h2>Start the server</h2>\n<p>It is very easy to start a web app in flask:</p>\n<pre><code class=\"language-python\">from flask import Flask\n\napp = Flask(__name__)\n\nif __name__ == '__main__':\n   app.run('127.0.0.1', port=5000, debug=True, threaded=True)\n</code></pre>\n<p>Just run the above script, the server is started. But right now, our server have no idea what kind of request it need to response, therefore we need to add route. </p>\n<h2>Add blueprint</h2>\n<p>As a practical project, we could not add all our route in one python script, or I would be hard to maintain. Because of that, we used the blueprint function in flask. The following are the cases that blueprints are intended for.</p>\n<blockquote>\n<ul>\n<li>Factor an application into a set of blueprints. This is ideal for larger applications; a project could instantiate an application object, initialize several extensions, and register a collection of blueprints.</li>\n<li>Register a blueprint on an application at a URL prefix and/or subdomain. Parameters in the URL prefix/subdomain become common view arguments (with defaults) across all view functions in the blueprint.</li>\n<li>Register a blueprint multiple times on an application with different URL rules.</li>\n<li>Provide template filters, static files, templates, and other utilities through blueprints. A blueprint does not have to implement applications or view functions.</li>\n<li>Register a blueprint on an application for any of these cases when initializing a Flask extension.</li>\n</ul>\n</blockquote>\n<p>Before adding blueprint, we need to introduce the structure of our flask module. The structure was really simple:</p>\n<pre><code>\\root\n    run.py\n    \\view.py\n        __init__.py\n        some_blueprint.py\n        ...\n</code></pre>\n<p>Here is an example of the blueprint, the simplified version of datasets.py:</p>\n<pre><code class=\"language-python\">from flask import Blueprint, jsonify, request, make_response\n\n__all__ = ['datasets']\ndatasets = Blueprint('datasets', __name__)\n\n@datasets.route(\"/api/datasets\")\ndef get_datasets():\n    usage = request.args.getlist('uses[]')\n    dataset = request.args.get('dataset')\n    ... ...\n    return jsonify({'data': data, 'total': len(data)})\n\n\n@datasets.route(\"/api/datasets/&#x3C;dataset_name>\")\ndef get_specific_dataset(dataset_name):\n    ... ...\n    return jsonify({\"name\": dataset_name, \"data\": data})\n\n@datasets.route(\"/api/datasets/download\", methods = ['post'])\ndef download_datasets():\n    datasets = request.get_json()['datasets']\n    ... ...\n    return jsonify(download_dir)\n</code></pre>\n<p>Above shows some basic usage of flask route. And in run.py, we need to attach all the blueprint to the app.</p>\n<pre><code class=\"language-python\">import os\nfrom flask import Flask\nimport views\n\ndef register_blueprint(app):\n    for module_name in views.__all__:\n        module = import_module('views.'+module_name)\n        for bp in module.__all__:\n            app.register_blueprint(getattr(module, bp))\n\n\napp = Flask(__name__, template_folder='dist')\nregister_blueprint(app)\n\nif __name__ == '__main__':\n    app.run('127.0.0.1', port=5000, debug=True, threaded=True)\n</code></pre>\n<p>And the backbone of a RESTful backend was finished. Easy, right?</p>","frontmatter":{"title":"Flask Basics"}}},"pageContext":{"slug":"/Flask-Basics/"}}