{"data":{"markdownRemark":{"html":"<p>这里会记录阅读6.828课程lecture note的我的个人笔记。可能会中英混杂，不是很适合外人阅读，也请见谅。</p>\n<h2>Lecture 9: Locking</h2>\n<p>lock的简单抽象：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  lock l\n  acquire(l)\n    x = x + 1 -- &quot;critical section&quot;\n  release(l)</code></pre></div>\n<p>lock就是一个object，如果多个线程调用<code class=\"language-text\">acquire</code>，只有一个thread能拿到，其他的就需要等待<code class=\"language-text\">release</code>。</p>\n<p>程序经常有很多数据，也就对应很多锁，不同的数据对应不同的锁。不过注意，锁并不是和数据绑定的，而是在和数据相关的critical region使用的。</p>\n<p>那我们什么时候需要锁呢？</p>\n<ul>\n<li>当2个或更多的线程触及到内存时。</li>\n<li>当至少一个线程写入时。</li>\n</ul>\n<p>执行上述的规则时，太过保守或是太过自由都不好。有的时候故意有一些race没关系。</p>\n<p>那我们能不能自动加锁呢？比如说每个数据都自动的和一个锁相连。</p>\n<p>这样太死板，会出现问题，比如说<code class=\"language-text\">rename(&quot;d1/x&quot;, &quot;d2/y&quot;)</code>，实行的步骤就会是</p>\n<ol>\n<li>lock d1, erase x, unlock d1</li>\n<li>lock d2 add y unlock d2</li>\n</ol>\n<p>这样会导致有一段时间文件消失了，那么信息也就没了...我们需要的是：</p>\n<ol>\n<li>lock d1; lock d2;</li>\n<li>erase x, add y</li>\n<li>unlock d2; unlock d1</li>\n</ol>\n<p>也就是说程序员需要能够控制中间过程。</p>\n<p>我们可以把锁想想成如下几点：</p>\n<ol>\n<li>avoid lost update</li>\n<li>create atomic multi-step operations  -- hide intermediate states</li>\n<li>maintain invariants on a data structure</li>\n</ol>\n<h3>deadlock</h3>\n<p>对于上面的那个<code class=\"language-text\">rename</code>，对于有2个锁的方案，如果同时运行<code class=\"language-text\">rename(d1/x, d2/y)</code>和<code class=\"language-text\">rename(d2/a, d1/b)</code>就会发生死锁。</p>\n<p>解决方案就是让程序员给所有的锁制定一个顺序，并让代码遵循这个顺序。显然这是很复杂的。。。</p>\n<h3>lock vs modularity tradeoff</h3>\n<p>同时这个解决方案会出现一个tradeoff，因为为了避免死锁，我们需要知道函数里面是怎么上锁的。或者说locks are often not the provate business of individual modules。所以一些时候，我们就 粗暴的在函数两端上锁来使其变为单线程运行的。</p>\n<h3>Locks and parallleism</h3>\n<p>锁实际上是在避免并行操作。而符合分割数据和锁，或者说设计\"fine grained locks\"是很难的。所以一般从一个单独的大锁开始，如果有需要再分为多个锁。</p>\n<h3>lock in xv6</h3>\n<p>比如<code class=\"language-text\">ide.c</code>，里面只有<code class=\"language-text\">idelock</code>这一个锁。</p>\n<h3>implement locks</h3>\n<p>下面的这种实现方法为什么不对呢？</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">  why not<span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">struct</span> lock <span class=\"token punctuation\">{</span> <span class=\"token keyword\">int</span> locked<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">acquire</span><span class=\"token punctuation\">(</span>l<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>l<span class=\"token operator\">-></span>locked <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span> <span class=\"token comment\">// A</span>\n          l<span class=\"token operator\">-></span>locked <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">// B</span>\n          <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span></code></pre></div>\n<p>因为有两个程序先后运行到A，而从而都获取了锁。所以我们应该把A,B变得atomic</p>\n<p>在x86中，有一个指令<code class=\"language-text\">xchg</code>就是用来做这个的，从而使得锁的实现变为：</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">  <span class=\"token function\">acquire</span><span class=\"token punctuation\">(</span>l<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token function\">xchg</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>l<span class=\"token operator\">-></span>locked<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">break</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span></code></pre></div>\n<p>xv6的实际代码是（<code class=\"language-text\">spinlock.c</code>）：</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">void</span>\n<span class=\"token function\">acquire</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> spinlock <span class=\"token operator\">*</span>lk<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n  <span class=\"token function\">pushcli</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// disable interrupts to avoid deadlock.</span>\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token function\">holding</span><span class=\"token punctuation\">(</span>lk<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">panic</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"acquire\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// The xchg is atomic.</span>\n  <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token function\">xchg</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>lk<span class=\"token operator\">-></span>locked<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// Tell the C compiler and the processor to not move loads or stores</span>\n  <span class=\"token comment\">// past this point, to ensure that the critical section's memory</span>\n  <span class=\"token comment\">// references happen after the lock is acquired.</span>\n  <span class=\"token function\">__sync_synchronize</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// Record info about lock acquisition for debugging.</span>\n  lk<span class=\"token operator\">-></span>cpu <span class=\"token operator\">=</span> <span class=\"token function\">mycpu</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">getcallerpcs</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>lk<span class=\"token punctuation\">,</span> lk<span class=\"token operator\">-></span>pcs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>注意出了使用了<code class=\"language-text\">xchg</code>，还使用了<code class=\"language-text\">pushcli</code>，也就是关闭了中断机制，因为中断可能会导致死锁。</p>\n<p><code class=\"language-text\">release</code>的代码就简单的多：</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">void</span>\n<span class=\"token function\">release</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> spinlock <span class=\"token operator\">*</span>lk<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">holding</span><span class=\"token punctuation\">(</span>lk<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">panic</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"release\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  lk<span class=\"token operator\">-></span>pcs<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  lk<span class=\"token operator\">-></span>cpu <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// Tell the C compiler and the processor to not move loads or stores</span>\n  <span class=\"token comment\">// past this point, to ensure that all the stores in the critical</span>\n  <span class=\"token comment\">// section are visible to other cores before the lock is released.</span>\n  <span class=\"token comment\">// Both the C compiler and the hardware may re-order loads and</span>\n  <span class=\"token comment\">// stores; __sync_synchronize() tells them both not to.</span>\n  <span class=\"token function\">__sync_synchronize</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// Release the lock, equivalent to lk->locked = 0.</span>\n  <span class=\"token comment\">// This code can't use a C assignment, since it might</span>\n  <span class=\"token comment\">// not be atomic. A real OS would use C atomics here.</span>\n  <span class=\"token keyword\">asm</span> <span class=\"token keyword\">volatile</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"movl $0, %0\"</span> <span class=\"token punctuation\">:</span> <span class=\"token string\">\"+m\"</span> <span class=\"token punctuation\">(</span>lk<span class=\"token operator\">-></span>locked<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">:</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">popcli</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>这里之所以要调用<code class=\"language-text\">__sync_synchronize()</code>，就是因为编译器可能会在优化的时候更改指令顺序。如，虽然我们写的是：</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">  Core A<span class=\"token punctuation\">:</span>          Core B<span class=\"token punctuation\">:</span>\n    locked <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n    x <span class=\"token operator\">=</span> x <span class=\"token operator\">+</span> <span class=\"token number\">1</span>      <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>locked <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    locked <span class=\"token operator\">=</span> <span class=\"token number\">0</span>       <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n                   locked <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n                   x <span class=\"token operator\">=</span> x <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n                   locked <span class=\"token operator\">=</span> <span class=\"token number\">0</span></code></pre></div>\n<p>但是有可能会被优化为：</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">      locked <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n      locked <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n      x <span class=\"token operator\">=</span> x <span class=\"token operator\">+</span> <span class=\"token number\">1</span></code></pre></div>\n<p>这样就让锁失效了。<code class=\"language-text\">__sync_synchronize()</code>就是有这样的作用，让编译器不会move a memory reference past it. 事实上<code class=\"language-text\">xchg</code>也会有同样的效果（intel保证的）。</p>\n<p>因为上述的存在，在用锁的情况下，不需要考虑memory ordering rules，只有在写exotic \"lock-free\"的代码的时候才需要。</p>\n<p>我们会发现spinlock会阻塞cpu，那么其只适合短时间的锁。我们之后会讨论和spinlock不太一样的一种锁，在等待的时候会让出CPU。</p>\n<p>关于用锁的几点建议： </p>\n<ul>\n<li>don't share if you don't have to</li>\n<li>start with a few coarse-grained locks</li>\n<li>instrument your code -- which locks are preventing parallelism?</li>\n<li>use fine-grained locks only as needed for parallel performance</li>\n<li>use an automated race detector</li>\n</ul>","frontmatter":{"title":"6.828 笔记8"}}},"pageContext":{"slug":"/6.828-note8/"}}