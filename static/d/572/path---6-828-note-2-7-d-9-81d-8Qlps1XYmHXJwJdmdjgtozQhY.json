{"data":{"markdownRemark":{"html":"<p>这里会记录阅读6.828课程lecture note的我的个人笔记。可能会中英混杂，不是很适合外人阅读，也请见谅。</p>\n<h2>Lecture 2: x86 and PC architecture</h2>\n<h3>PC architecture</h3>\n<p>一个完整的CPU有：</p>\n<ul>\n<li>x86 CPU与其寄存器，执行单元和内存管理部分</li>\n<li>CPU chip pins, include address and data signals</li>\n<li>memory</li>\n<li>disk</li>\n<li>keyboard</li>\n<li>display</li>\n<li>其他资源：BIOS, ROM, clock, ...</li>\n</ul>\n<p>我们从零来一步一步得到一个CPU:</p>\n<ul>\n<li>可以把CPU就想成一个无穷循环</li>\n</ul>\n\n    <div class=\"gatsby-highlight\" data-language=\"c\">\n      <pre class=\" cm-s-default\"\n      ><code><span>for(;;){\n\trun next instruction\n}</span></code></pre>\n    </div>\n<p>之后加入如AX, BX, CX, DX这样的register，他们速度非常快。</p>\n<ul>\n<li>加入内存</li>\n</ul>\n<p>内存，通过CPU sends out address on address lines (wires, one bit per wire)(这个是memory bus嘛？)，以读写数据。</p>\n\n    <div class=\"gatsby-highlight\" data-language=\"assembly\">\n      <pre class=\" cm-s-default\"\n      ><code><span>movl  %eax, %edx   # edx = eax; register mode\nmovl $0x123 %edx   # edx = 0x123; immediate\nmovl 0x123, %edx   # edx = *(int32_t*)0x123; direct\nmovl (%ebx), %edx  # edx = *(int32_t*)ebx; indirect\nmovl 4(%ebx), %edx # edx = *(int32_t*)(ebx+4); displaced</span></code></pre>\n    </div>\n<p>上面几行具体的address mode的解释可以看<a href=\"https://www.tutorialspoint.com/assembly_programming/assembly_addressing_modes.htm\">这里</a>。大致区别是：</p>\n<ol>\n<li>\n<p>register mode: 寄存器到寄存器</p>\n</li>\n<li>\n<p>immediate mode: 指令里头带的常数到寄存器</p>\n</li>\n<li>\n<p>后面几种都是计算到内存位置的</p>\n</li>\n<li>\n<p>address registers (栈与和栈类似的东西)</p>\n</li>\n</ol>\n<p>为了满足如上需求，就需要有address registers，也就是SP, BP, SI, DI这样的register。</p>\n<ul>\n<li>读取指令</li>\n</ul>\n<p>需要注意，instructions是存在内存中的，用EIP指向instruction，每执行一个就会增加EIP，而CALL, RET, JMP等汇编指令可以改变IP。</p>\n<ul>\n<li>FLAGS</li>\n</ul>\n<p>除了以上内容，我们还需要条件语句进行conditional jump，这就需要FLAGS，有各种各样的FLAGS。</p>\n<ul>\n<li>I/O</li>\n</ul>\n<p>有了以上功能的CPU仍然是一个没什么意思的程序，因为其没有IO。</p>\n\n    <div class=\"gatsby-highlight\" data-language=\"c\">\n      <pre class=\" cm-s-default\"\n      ><code><span>// write a byte to line printer\n#define DATA_PORT    0x378\n#define STATUS_PORT  0x379\n#define   BUSY 0x80\n#define CONTROL_PORT 0x37A\n#define   STROBE 0x01\nvoid\nlpt_putc(int c)\n{\n  /* wait for printer to consume previous byte */\n  while((inb(STATUS_PORT) & BUSY) == 0)\n    ;\n\n  /* put the byte on the parallel lines */\n  outb(DATA_PORT, c);\n\n  /* tell the printer to look at the data */\n  outb(CONTROL_PORT, STROBE);\n  outb(CONTROL_PORT, 0);\n}</span></code></pre>\n    </div>\n<p>上面的这段代码是传统的PC architecture: use dedicated I/O space. </p>\n<p>没太看懂，但是感觉这里的outb和inb和manul里的是不同的。。。</p>\n<p> 这种方式有如下的几个特点：</p>\n<ul>\n<li>和memory access类似，但是需要set I/O signal (代码里面的strobe是这个signal？)</li>\n<li>只有1024 I/O address，(1024是0x3ff，所以和上面PORT挺对应的)。</li>\n<li>需要特殊的指令（IN, OUT）</li>\n</ul>\n<p>而现在都是用Memory-Mapped I/O</p>\n<p>其特点是：</p>\n<ul>\n<li>\n<p>Use normal physical memory addresses</p>\n<ul>\n<li>Gets around limited size of I/O address space</li>\n<li>No need for special instructions</li>\n<li>System controller routes to appropriate device</li>\n</ul>\n</li>\n<li>\n<p>Works like \"magic'' memory:</p>\n<ul>\n<li><em>Addressed</em> and <em>accessed</em> like memory, but ...</li>\n<li>... does not <em>behave</em> like memory!</li>\n<li>Reads and writes can have <code></code>side effects''</li>\n<li>Read results can change due to external events</li>\n</ul>\n</li>\n<li>\n<p>如何使用不止2^16bytes的内存</p>\n</li>\n</ul>\n<p>虽然IP只有16位，但是加入了CS之后就可以有20位了。</p>\n<ul>\n<li>希望有超过16位的address</li>\n</ul>\n<p>80386首次支持32位地址。Boot的时候是16位，通过<code>boot.s</code>转换为32位。</p>\n<p>其寄存器也都是32位的，所以叫EAX而不是AX了。在32位模式下，通过前面加0x66前缀来toggle between 16-bit and 32-bit。而<code>boot.s</code>中的<code>.code32</code>正是做的这一点。如：</p>\n\n    <div class=\"gatsby-highlight\" data-language=\"assembly\">\n      <pre class=\" cm-s-default\"\n      ><code><span>b8 cd ab\t\t16-bit CPU,  AX <- 0xabcd\nb8 34 12 cd ab  32-bit CPU, EAX <- 0xabcd1234\n66 b8 cd ab\t\t32-bit CPU,  AX <- 0xabcd</span></code></pre>\n    </div>\n<h3>x86 Physical Memory Map</h3>\n<ul>\n<li>The physical address space mostly looks like ordinary RAM</li>\n<li>Except some low-memory addresses actually refer to other things</li>\n<li>Writes to VGA memory appear on the screen</li>\n<li>Reset or power-on jumps to ROM at 0xfffffff0 (so must be ROM at top...)</li>\n</ul>\n\n    <div class=\"gatsby-highlight\" data-language=\"null\">\n      <pre class=\" cm-s-default\"\n      ><code><span>+------------------+  <- 0xFFFFFFFF (4GB)\n|      32-bit      |\n|  memory mapped   |\n|     devices      |\n|                  |\n/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\\n\n/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\\n|                  |\n|      Unused      |\n|                  |\n+------------------+  <- depends on amount of RAM\n|                  |\n|                  |\n| Extended Memory  |\n|                  |\n|                  |\n+------------------+  <- 0x00100000 (1MB)\n|     BIOS ROM     |\n+------------------+  <- 0x000F0000 (960KB)\n|  16-bit devices, |\n|  expansion ROMs  |\n+------------------+  <- 0x000C0000 (768KB)\n|   VGA Display    |\n+------------------+  <- 0x000A0000 (640KB)\n|                  |\n|    Low Memory    |\n|                  |\n+------------------+  <- 0x00000000</span></code></pre>\n    </div>\n<p>这里的图在lab1中出现过，在lab1中有更详细的讲解。</p>\n<h3>x86 Instruction Set</h3>\n<p>对于本课使用的AT&#x26;T(gcc/gas) syntax: op src, dst。</p>\n<p>使用b, w, l来表示不同大小的操作。</p>\n<ul>\n<li>data movement: MOV, PUSH, POP, ...</li>\n<li>arithmetic: TEST, SHL, ADD, AND, ...</li>\n<li>i/o: IN, OUT, ...</li>\n<li>control: JMP, JZ, JNZ, CALL, RET</li>\n<li>string: REP MOVSB, ...</li>\n<li>system: IRET, INT</li>\n</ul>\n<h2>gcc x86 calling conventions</h2>\n<p>这里主要讲解了如何调用函数，也就是如何使用栈。</p>\n\n    <div class=\"gatsby-highlight\" data-language=\"assembly\">\n      <pre class=\" cm-s-default\"\n      ><code><span>pushl %eax   <=> subl $4, %esp # esp -= 4\n\t\t\t     movl %eax, (%esp) # *(esp) = eax\npopl %eax    <=> movl (%esp), %eax # eax = *(esp)\n\t\t\t     addl $4, %esp # esp += 4\ncall 0x12345 <=> pushl %eip(*) # 存起来call指令的地址\n\t\t\t\t movl $0x12345, %eip(*) # 下一个指令执行函数\nret \t\t <=> popl %eip(*) # 回到call指令\n# (*) mean it is not real instruction</span></code></pre>\n    </div>\n<p>GCC dictates 该如何使用栈. 在x86上，caller和callee之间的协议(Contract)如下:</p>\n<ul>\n<li>\n<p>在函数的入口处 (i.e. just after call):</p>\n<ul>\n<li>%eip 指向函数的首个指令的地址</li>\n<li>%esp+4 指首个参数（其实就是首个参数被push了）</li>\n<li>%esp 指向返回地址（return address）</li>\n</ul>\n</li>\n<li>\n<p>运行ret指令之后（函数返回之后）:</p>\n<ul>\n<li>%eip 包含%esp的值，也就是返回地址</li>\n<li>%esp 因为重新被addl 4, 所以指向首个参数</li>\n<li>函数可能有trashed argument（没懂什么意思）</li>\n<li>%eax (and %edx, if return type is 64-bit) 存有返回值 (or trash if function is <code>void</code>)</li>\n<li>%eax, %edx (above), and %ecx may be trashed</li>\n<li>%ebp, %ebx, %esi, %edi must contain contents from time of <code>call</code>（比如ebx是输入参数，ebp是caller的frame address）</li>\n</ul>\n</li>\n<li>\n<p>Terminology:</p>\n<ul>\n<li>%eax, %ecx, %edx are \"caller save\" registers</li>\n<li>%ebp, %ebx, %esi, %edi are \"callee save\" registers</li>\n</ul>\n</li>\n</ul>\n<p>这里原note中写的非常清楚，应仔细阅读。</p>\n<p>只要不违反上述contract，Function什么都可以做，根据习惯，GCC会：</p>\n<ul>\n<li>\n<p>each function has a stack frame marked by %ebp, %esp</p>\n\n    <div class=\"gatsby-highlight\" data-language=\"null\">\n      <pre class=\" cm-s-default\"\n      ><code><span>     +------------+   |\n     | arg 2      |   \\\n     +------------+    >- previous function's stack frame\n     | arg 1      |   /\n     +------------+   |\n     | ret %eip   |   /\n     +============+   \n     | saved %ebp |   \\\n%ebp-> +------------+   |\n     |            |   |\n     |   local    |   \\\n     | variables, |    >- current function's stack frame\n     |    etc.    |   /\n     |            |   |\n     |            |   |\n%esp-> +------------+   /</span></code></pre>\n    </div>\n</li>\n<li>\n<p>可以通过移动%esp来增大减小（应该就是通过push和pop，那到底有没有一个frame大小作为限制呢？）</p>\n</li>\n<li>\n<p>%ebp指向之前函数的%ebp，从而形成链（可以看后面两部分的代码）</p>\n</li>\n<li>\n<p>function prologue:</p>\n\n    <div class=\"gatsby-highlight\" data-language=\"assembly\">\n      <pre class=\" cm-s-default\"\n      ><code><span>pushl %ebp  # 把当前的frame address存在esp对应的地址里\nmovl %esp, %ebp\t # 把现在的esp的值存在ebp里，\n\t\t\t\t # 可以理解为*(ebp) = ebp_old\n\t\t\t\t # 从而组成了一个frame address的链</span></code></pre>\n    </div>\n<p>or</p>\n\n    <div class=\"gatsby-highlight\" data-language=\"assembly\">\n      <pre class=\" cm-s-default\"\n      ><code><span>enter $0, $0</span></code></pre>\n    </div>\n<p>enter usually not used: 4 bytes vs 3 for pushl+movl, not on hardware fast-path anymore</p>\n</li>\n<li>\n<p>function epilogue can easily find return EIP on stack:</p>\n\n    <div class=\"gatsby-highlight\" data-language=\"assembly\">\n      <pre class=\" cm-s-default\"\n      ><code><span>movl %ebp, %esp # esp = ebp，注意这时*(ebp) = ebp_old\npopl %ebp # 把*(ebp)也就是ebp_old重新赋给ebp, ebp = *(ebp)\n\t\t  # 同时esp也恢复到调用这个函数之前的值</span></code></pre>\n    </div>\n<p>or</p>\n\n    <div class=\"gatsby-highlight\" data-language=\"assembly\">\n      <pre class=\" cm-s-default\"\n      ><code><span>leave\t</span></code></pre>\n    </div>\n<p>leave used often because it's 1 byte, vs 3 for movl+popl</p>\n</li>\n</ul>\n<p>这里有一个简单的调用的例子：</p>\n<ul>\n<li>\n<p>C code</p>\n\n    <div class=\"gatsby-highlight\" data-language=\"c\">\n      <pre class=\" cm-s-default\"\n      ><code><span>int main(void) { return f(8)+1; }\nint f(int x) { return g(x); }\nint g(int x) { return x+3; }\t\t</span></code></pre>\n    </div>\n</li>\n<li>\n<p>assembler</p>\n\n    <div class=\"gatsby-highlight\" data-language=\"assembly\">\n      <pre class=\" cm-s-default\"\n      ><code><span>_main:\n\t\t\t\tprologue\n\tpushl %ebp\n\tmovl %esp, %ebp\n\t\t\t\tbody\n\tpushl $8 # 在调用前，把8，也就是参数推进栈\n  call _f # 调用\n  addl $1, %eax # 返回值存在eax中\n  \t\t\tepilogue\n\tmovl %ebp, %esp\n\tpopl %ebp\n\tret\n_f:\n\t\t\t\tprologue\n\tpushl %ebp # ebp为main的frame address\n\tmovl %esp, %ebp # ebp为f的frame address，指向main的\n\t\t\t\tbody\n\tpushl 8(%esp) # 这里的8(%esp)是x的地址对应的值，\n\t\t\t\t  # 把传入的x再次放入栈中\n\tcall _g\n\t\t\t\tepilogue\n\tmovl %ebp, %esp\n\tpopl %ebp\n\tret\n\n_g:\n\t\t\t\tprologue\n\tpushl %ebp\n\tmovl %esp, %ebp\n\t\t\t\tsave %ebx\n\tpushl %ebx # 这里不懂。。。\n\t\t\t\tbody\n\tmovl 8(%ebp), %ebx # 取出传入的x\n\taddl $3, %ebx\n\tmovl %ebx, %eax # 把计算结果存给eax\n\t\t\t\trestore %ebx\n\tpopl %ebx\n\t\t\t\tepilogue\n\tmovl %ebp, %esp\n\tpopl %ebp\n\tret</span></code></pre>\n    </div>\n<p>注意，如果使用<code>objdump -d</code>进行反汇编，会有出入。</p>\n</li>\n<li>\n<p>Super-small _g:</p>\n\n    <div class=\"gatsby-highlight\" data-language=\"assembly\">\n      <pre class=\" cm-s-default\"\n      ><code><span>_g:\n\tmovl 4(%esp), %eax\n\taddl $3, %eax\n\tret</span></code></pre>\n    </div>\n</li>\n</ul>\n<p>编译</p>\n<p>编译语言的方式可以见我之前的帖子How is python run.</p>\n<h3>PC emulation</h3>\n<p>The Bochs emulator(和qemu是不同的软件，不过差不多) works by</p>\n<ul>\n<li>和PC做完全一样的事</li>\n<li>全部只用软件实现</li>\n</ul>\n<p>而实际上只是host的一个普通进程。</p>\n<p>用进程的存储来模拟硬件状态，如：</p>\n<ul>\n<li>\n<p>把寄存器存为全局变量</p>\n\n    <div class=\"gatsby-highlight\" data-language=\"c\">\n      <pre class=\" cm-s-default\"\n      ><code><span>int32_t regs[8];\n#define REG_EAX 1;\n#define REG_EBX 2;\n#define REG_ECX 3;\n...\nint32_t eip;\nint16_t segregs[4];\n...</span></code></pre>\n    </div>\n</li>\n<li>\n<p>用一个数组模拟物理内存。</p>\n\n    <div class=\"gatsby-highlight\" data-language=\"c\">\n      <pre class=\" cm-s-default\"\n      ><code><span>char mem[256*1024*1024]         </span></code></pre>\n    </div>\n</li>\n</ul>\n<p>通过死循环来执行指令（可以和上面的CPU最开始对比）</p>\n\n    <div class=\"gatsby-highlight\" data-language=\"c\">\n      <pre class=\" cm-s-default\"\n      ><code><span>for (;;) {\n\tread_instruction();\n\tswitch (decode_instruction_opcode()) {\n\t\tcase OPCODE_ADD:\n\t\t\tint src = decode_src_reg();\n\t\t\tint dst = decode_dst_reg();\n\t\t\tregs[dst] = regs[dst] + regs[src];\n\t\t\tbreak;\n\t\tcase OPCODE_SUB:\n\t\t\tint src = decode_src_reg();\n\t\t\tint dst = decode_dst_reg();\n\t\t\tregs[dst] = regs[dst] - regs[src];\n\t\t\tbreak;\n\t\t...\n\t}\n\teip += instruction_length;\n}</span></code></pre>\n    </div>\n<p>内存的布局和实际上的物理内存一样（分成lower, BIOS, extension...）</p>\n\n    <div class=\"gatsby-highlight\" data-language=\"c\">\n      <pre class=\" cm-s-default\"\n      ><code><span>#define KB\t\t1024\n#define MB\t\t1024*1024\n\n#define LOW_MEMORY\t640*KB\n#define EXT_MEMORY\t10*MB\n\nuint8_t low_mem[LOW_MEMORY];\nuint8_t ext_mem[EXT_MEMORY];\nuint8_t bios_rom[64*KB];\n\nuint8_t read_byte(uint32_t phys_addr) {\n\tif (phys_addr < LOW_MEMORY)\n\t\treturn low_mem[phys_addr];\n\telse if (phys_addr >= 960*KB && phys_addr < 1*MB)\n\t\treturn rom_bios[phys_addr - 960*KB];\n\telse if (phys_addr >= 1*MB && phys_addr < 1*MB+EXT_MEMORY) {\n\t\treturn ext_mem[phys_addr-1*MB];\n\telse ...\n}\n\nvoid write_byte(uint32_t phys_addr, uint8_t val) {\n\tif (phys_addr < LOW_MEMORY)\n\t\tlow_mem[phys_addr] = val;\n\telse if (phys_addr >= 960*KB && phys_addr < 1*MB)\n\t\t; /* ignore attempted write to ROM! */\n\telse if (phys_addr >= 1*MB && phys_addr < 1*MB+EXT_MEMORY) {\n\t\text_mem[phys_addr-1*MB] = val;\n\telse ...\n}\n\t</span></code></pre>\n    </div>\n<p>通过检查对“特殊”内存及I/O space的访问并按照真是情况进行模拟来模拟I/O等，如,</p>\n<ul>\n<li>把对模拟的硬盘的读写转化成对host机上的文件的读写。</li>\n<li>对模拟VGA硬件的写入转化为drawing into an X window</li>\n<li>模拟的键盘读入转化为reads from X input event queue</li>\n</ul>","frontmatter":{"title":"6.828 笔记2"}}},"pageContext":{"slug":"/6.828-note2/"}}