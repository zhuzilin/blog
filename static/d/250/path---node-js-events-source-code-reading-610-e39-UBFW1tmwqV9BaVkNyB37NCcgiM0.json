{"data":{"markdownRemark":{"html":"<p>It is well-known that Node.js is an event based JavaScript  runtime environment. And today let's dig deeper into the source code and have a look at how this event mechanism is implemented.</p>\n<pre><code class=\"language-javascript\">const EventEmitter = require('events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\n</code></pre>\n<p>Here is demo of the core function of the events. Therefore it is reasonable that we just focus on functions shown in this demo.</p>\n<p>The event relevant code lies in the \"./lib/events.js\" file. Apparently, the code exports EventEmitter function as its default export.</p>\n<pre><code class=\"language-javascript\">function EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\n</code></pre>\n<p>And the initialization is also simple. It only give initial value to some properties.</p>\n<pre><code class=\"language-javascript\">EventEmitter.init = function() {\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n</code></pre>\n<p>Now comes the untrivial parts.</p>\n<p>The on function is a wrapper of the addListener, which is a wrapper of _addListener:</p>\n<pre><code>EventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n</code></pre>\n<p>So our main focus would be the _addListener function:</p>\n<pre><code class=\"language-javascript\">function _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = $getMaxListeners(target);\n    if (m > 0 &#x26;&#x26; existing.length > m &#x26;&#x26; !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      const w = new Error('Possible EventEmitter memory leak detected. ' +\n                          `${existing.length} ${String(type)} listeners ` +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      process.emitWarning(w);\n    }\n  }\n\n  return target;\n}\n</code></pre>\n<p>The comment in the code is really clear. And for emit: </p>\n<pre><code class=\"language-javascript\">EventEmitter.prototype.emit = function emit(type, ...args) {\n  let doError = (type === 'error');  // if we are emitting an error\n\n  const events = this._events;\n  if (events !== undefined)\n    doError = (doError &#x26;&#x26; events.error === undefined);\n  else if (!doError)  // event is undefined but emit event other than error.\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    let er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      try {\n        const { kExpandStackSymbol } = require('internal/util');\n        const capture = {};\n        Error.captureStackTrace(capture, EventEmitter.prototype.emit);\n        Object.defineProperty(er, kExpandStackSymbol, {\n          value: enhanceStackTrace.bind(null, er, capture),\n          configurable: true\n        });\n      } catch {}\n\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    const errors = lazyErrors();\n    const err = new errors.ERR_UNHANDLED_ERROR(er);\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  const handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    Reflect.apply(handler, this, args);\n  } else {\n    const len = handler.length;\n    const listeners = arrayClone(handler, len);\n    for (var i = 0; i &#x3C; len; ++i)\n      Reflect.apply(listeners[i], this, args);\n  }\n\n  return true;\n};\n</code></pre>\n<p>So basically, the events module is just save the event handlers in the EventEmitter and call it when emitting.</p>","frontmatter":{"title":"Node.js events source code reading"}}},"pageContext":{"slug":"/Node-js-events-source-code-reading/"}}