---
title: 6.828 Homework xv6 shell
---

这个作业是要求完成`sh.c`这个文件，来写一个shell。做这个作业之前还是需要看一下xv6 book的第一章的，不然有些地方会不明白。

## Executing simple commands

简单来说，shell就是一个会循环读入每一行并对每一行做出反应的程序。所以除去`cd`指令（比较例外...），都是先fork一下，然后在child里对读进来的buffer进行parse并然后依据parse的内容运行对应的程序。

对于执行简单工具，读过parse之后知道，simple commands就是用`type == ' '`来表示的，其`argv`就是`execv`需要的，所以核心是：

```c
  case ' ':
    ecmd = (struct execcmd*)cmd;
    if(ecmd->argv[0] == 0)
      _exit(0);
    execv(ecmd->argv[0], ecmd->argv);
    break;
```

注意，`runcmd`里面这个代码不能进行普通的`printf`，应该是因为都是在child里面运行的，而为什么输出最后都能返回parent，应该是因为执行的结果被重定向回了parent。但是神奇的是可以通过`stderr`输出，不知道为什么。。。

## I/O redirection

注意，`open`，`dup`都会选择当时没被用的最小的file descriptor。然后io redirection再xv6 book里面有很相似的例子，代码很简单：

```c
case '>':
case '<':
    rcmd = (struct redircmd*)cmd;
    int mode = S_IRUSR | S_IWUSR;
    if(close(rcmd->fd) == -1) {
        fprintf(stderr, "Fail to open %s\n", (rcmd->fd ? "stdout" : "stdin"));
        _exit(-1);
    }
    if(open(rcmd->file, rcmd->flags, mode) < 0) {
        fprintf(stderr, "Fail to open %s\n", rcmd->file);
        _exit(-1);
    }
    runcmd(rcmd->cmd);
    break;
```

## Implement pipes

这里的难点就是`pipe`。对于`pipe`的讲解可以用xv6 book里面的例子来说：

```c
int p[2];
char *argv[2];
argv[0] = "wc";
argv[1] = 0;
pipe(p);
if(fork() == 0) {  // 在child里面就留两个，一个是0 -> pipe read, 1 -> stdout
	close(0);  // child里不连上stdin了
	dup(p[0]);  // 0 -> pipe read
	close(p[0]);  // p[0]不连着pipe read
	close(p[1]);  // p[1]不连着pipe write了
	exec("/bin/wc", argv);
} else {  // parent里面不动0, 1从而能和之后的的接上，然后留下p[1] -> pipe write，来向chile写入
	close(p[0]);
	write(p[1], "hello world\n", 12);
	close(p[1]);
}
```

所以类似的，pipes为：

```c
case '|':
    pcmd = (struct pipecmd*)cmd;
    if(pipe(p) == -1) {
        fprintf(stderr, "Fail to create pipe\n");
        _exit(-1);
    }
    if(fork() == 0) {  // 0不变，1->pipe write
        close(1);
        dup(p[1]);
        close(p[0]);
        close(p[1]);
        runcmd(pcmd->left);
    } else {  // 0->pipe read，1不变
        close(0);
        dup(p[0]);
        close(p[0]);
        close(p[1]);
        wait(&r);  // 这个wait重要
        runcmd(pcmd->right);
    }
    break;
  }
```

写完这三部分之后就可以运行测试代码了，

```bash
$ ./sh
6.828$ sh < t.sh
     11      11      54
     10      10      51
```

注意这里我并没有去写`PATH`这部分，所以改了`t.sh`，具体每个指令在哪里可以通过运行`which`指令来获取，如

```bash
$ which ls
/bin/ls
```

等项目代码部署到git上之后，会在这里贴一下我的`sh.c`的代码链接的。