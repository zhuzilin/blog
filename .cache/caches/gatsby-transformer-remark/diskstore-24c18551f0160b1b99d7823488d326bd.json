{"expireTime":9007200818315814000,"key":"transformer-remark-markdown-html-b858f4e8d8bd5d18786a7fd9e5fbc4be-gatsby-remark-katexgatsby-remark-prismjs-","val":"<p>本文为阅读<em>Computer Networking: A Top-Down Approach (7th Edition)</em>的阅读笔记，估计会比较没有条理，只是我比较喜欢在看书的时候旁边随手记两笔。既然读的是电子书，自然笔记也得是。</p>\n<h2>HTTP</h2>\n<p>Web page consists of objects. An object is simply a file.</p>\n<p>HTTP用TCP作为传输层。client会先去和server发起一个TCP连接，当链接完成的时候，就会</p>\n<p>persistent connnection: use the same TCP connection</p>\n<p>non-persistent: use separate TCP connection</p>\n<h3>HTTP non persistent</h3>\n<p>HTTP既可以persistent又可以non-persistent，默认是persistent。</p>\n<p>输入网址<code class=\"language-text\">http://www.someSchool.edu/someDepartment/home.index</code>后</p>\n<ol>\n<li>HTTP client会向server <code class=\"language-text\">http://www.someSchool.edu/</code>的80端口发起一个TCP连接。</li>\n<li>HTTP client通过socket向server发送HTTP request。request中包含<code class=\"language-text\">/someDepartment/home.index</code>。</li>\n<li>server通过socket处理request，并从其RAM或者disk中获取<code class=\"language-text\">/someDepartment/home.index</code>，把这个object包在HTTP response message中，并通过socket发回client。</li>\n<li>HTTP server告诉TCP关闭TCP connection（但是TCP实际上会在确认client收到结果的时候断掉链接。）</li>\n<li>HTTP client收到response，TCP中断。client会从repsonse message中提取出index.html。在html文件中发现了多个图片，然后重复1-5来获取图片。</li>\n</ol>\n<p>现代浏览器可以有一定程度上的并行，大多数浏览器可以同时并行5到10个TCP。</p>\n<h3>HTTP persistent</h3>\n<p>如果使用non-persistent的链接，那么每次都需要一个新的链接，TCP的buffer需要重新被分配，TCP variables需要被保存。当请求数量很多时，这会给server很大的负担。而且每个object都需要2个RTT（round trip time）（一个是用来initiate TCP，另一个用来request与response），所以non-persistent会有更大的延迟。</p>\n<p>HTTP 1.1有了persistent connections。server会在send a response之后保持TCP链接。之后同一个client和server的request和response都会用同一个TCP，直到一定时间没有用，会超时断掉。</p>\n<p>HTTP 2基于HTTP 1.1允许multiple requests and replies to be interleaved in the same connection以及一个prioritizing HTTP message requests and replies within this connection.</p>\n<h3>HTTP Message Format</h3>\n<p>request message的例子</p>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre class=\"language-http\"><code class=\"language-http\"><span class=\"token request-line\"><span class=\"token property\">GET</span> /somedir/page.html HTTP/1.1</span>\n<span class=\"token header-name keyword\">Host:</span> www.someschool.edu\n<span class=\"token header-name keyword\">Connection:</span> close\n<span class=\"token header-name keyword\">User-agent:</span> Mozilla/5.0\n<span class=\"token header-name keyword\">Accept-language:</span> fr</code></pre></div>\n<p>用ASCII写的。the last line is followed by an additional carriage return and line feed.</p>\n<p>第一行叫request line，包含method，url和HTTP version。</p>\n<p>后面几行叫header line。首先是Host，</p>\n<blockquote>\n<p>You might think that this header line is unnecessary, as there is already a TCP connection in place to the host. But, as we’ll see in Section 2.2.5, the information provided by the host header line is required by Web proxy caches</p>\n</blockquote>\n<p>Connection: close表示不需要persistent connections</p>\n<p>User-agent指browser的类型，这一行的好处是server可以选择给不同的agent不同的response</p>\n<p>Accept-language: 语言，比如user可能更喜欢object的法语版本。</p>\n<p><img src=\"https://imgur.com/41ij8Hz.png\" alt=\"http request\"></p>\n<p>对于GET的参数，就是会出现在url中（如<code class=\"language-text\">www.somesite.com/animalsearch?monkeys&amp;bananas</code>）。</p>\n<p>response message的例子</p>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre class=\"language-http\"><code class=\"language-http\"><span class=\"token response-status\">HTTP/1.1 <span class=\"token property\">200 OK</span></span>\n<span class=\"token header-name keyword\">Connection:</span> close\n<span class=\"token header-name keyword\">Date:</span> Tue, 18 Aug 2015 15:44:04 GMT\n<span class=\"token header-name keyword\">Server:</span> Apache/2.2.3 (CentOS)\n<span class=\"token header-name keyword\">Last-Modified:</span> Tue, 18 Aug 2015 15:11:03 GMT\n<span class=\"token header-name keyword\">Content-Length:</span> 6821\n<span class=\"token header-name keyword\">Content-Type:</span> text/html<span class=\"token text/html\">\n\n(data data data data data ...)</span></code></pre></div>\n<p>仍然是3部分，status line, header lines, entity body。</p>\n<p>status line: http版本与status code</p>\n<p>header: Connection告诉client，server即将关闭连接，last-modified指Object被上次修改的时间。</p>\n<p><img src=\"https://imgur.com/rcDmqzq.png\" alt=\"http request\"></p>\n<p>常见的status code：</p>\n<ul>\n<li>200 OK: 成功</li>\n<li>301 Moved Permanently: requested object has been permanently moved; the new URL in Location (in header)</li>\n<li>400 Bad Request: the request could not be understood by the server</li>\n<li>404 Not Found: the request document does not exist on this server</li>\n<li>505 HTTP Version Not Supported: the requested HTTP protocal version is not supported by the server.</li>\n</ul>\n<h3>Cookies</h3>\n<p>HTTP server is stateless，因为stateless能允许高并发。为了计入一些状态，如authentication，HTTP从cookies。</p>\n<p>cookies主要有4个组成部分：</p>\n<p>(1) a cookie header line in the HTTP response message; </p>\n<p>(2) a cookie header line in the HTTP request message; </p>\n<p>(3) a cookie file kept on the user’s end system and managed by the user’s browser; </p>\n<p>(4) a back-end database at the Web site.</p>\n<p>第一次访问网站的时候，网站会在db中创建一条信息，并返回一个unique identification number。response中就会加一个<code class=\"language-text\">Set-cookie:</code>，如：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Set-cookie: 1678</code></pre></div>\n<p>brower收到cookie之后，会在一个special cookie file中加一行，记录了hostname和identification number。之后的每次访问，browser都会查看这个file，并把identification number加在request header中，如：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Cookie: 1678</code></pre></div>\n<p>db用这个数字来找到用户信息。用户信息可能不是其用户名之类的，而是一些用户行为。如amazon用cookie记录购物车。如果用户注册过，可以把db中的entry和用户名啥的联系起来。</p>\n<p>不过cookie有invasion of privacy的问题。</p>\n<h3>Web Caching</h3>\n<p>web caching也被称为Proxy server，is a network entity that satisfies HTTP requests on the behalf of an origin Web server. Web cache有自己的硬盘可以保存最近的数份request objects。其主要过程是</p>\n<ol>\n<li>browser和web cache建立一个TCP</li>\n<li>web cache检查request中提到的object是不是已经本地存储了，如果是就返回，不然就和origin server建立TCP，origin server把object返回给web cache。</li>\n<li>web cache收到object之后，本地保存一份，并发送一份给browser。（注意用的是最开始的链接）</li>\n</ol>\n<p>Typically a Web cache is purchased and installed by an ISP (Internet Service Provider). </p>\n<p>有两个使用web caching的原因</p>\n<ul>\n<li>can substantially reduce the response time</li>\n<li>can substantially reduce traffic on an institution's access link to the Internet.</li>\n</ul>\n<h4>Conditional GET</h4>\n<p>HTTP有一个机制来让cache取人object是up to date的，这个就是conditional GET。</p>\n<p>conditional GET是指web cache像web serer发送的时候会加上一行</p>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre class=\"language-http\"><code class=\"language-http\"><span class=\"token request-line\"><span class=\"token property\">GET</span> /fruit/kiwi.gif HTTP/1.1</span>\n<span class=\"token header-name keyword\">Host:</span> www.exotiquecuisine.com\n<span class=\"token header-name keyword\">If-modified-since:</span> Wed, 9 Sep 2015 09:23:24</code></pre></div>\n<p>然后如果没有改变，web server会返回</p>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre class=\"language-http\"><code class=\"language-http\"><span class=\"token response-status\">HTTP/1.1 <span class=\"token property\">304 Not Modified</span></span>\n<span class=\"token header-name keyword\">Date:</span> Sat, 10 Oct 2015 15:39:29\n<span class=\"token header-name keyword\">Server:</span> Apache/1.3.0 (Unix)\n\n(empty entity body)</code></pre></div>\n<p>cache就可以返回原来的那份。</p>\n<h2>SMTP (Simple Mail Transfer Protocol)</h2>\n<p>为了讲解SMTP的基本操作，我们来看一下如果Alice要给Bob发一封邮件，会过几个步骤。</p>\n<ol>\n<li>Alice用其user agent给Bob的email address发邮件</li>\n<li>Alice的user agent把message发给其mail server的message queue中。</li>\n<li>client side of SMTP，跑在Alice的mail server上，看到message queue中的信息，像另一个SMTP server开启一个TCP链接。</li>\n<li>完成SMTP handshaking之后，client把Alice的信息发给server。</li>\n<li>Bob的mail server收到信息，把信息放在mailbox中</li>\n<li>Bob查看user agent的时候会读到mail server中的mail box</li>\n</ol>\n<p>SMTP是port 25。然后handshake的方式是：</p>\n<ol>\n<li>the SMTP client indicates the email address of the sender and the e-mail address of the recipient.</li>\n<li>the SMTP client send message.</li>\n<li>The client then repeats this process over the same TCP connection if it has other messages to send to the server; otherwise, it instructs TCP to close the connection.</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">S: 220 hamburger.edu\nC: HELO crepes.fr\nS: 250 Hello crepes.fr, pleased to meet you\nC: MAIL FROM: &lt;alice@crepes.fr&gt;\nS: 250 alice@crepes.fr ... Sender ok\nC: RCPT TO: &lt;bob@hamburger.edu&gt;\nS: 250 bob@hamburger.edu ... Recipient ok\nC: DATA\nS: 354 Enter mail, end with ”.” on a line by itself\nC: Do you like ketchup?\nC: How about pickles?\nC: .\nS: 250 Message accepted for delivery\nC: QUIT\nS: 221 hamburger.edu closing connection</code></pre></div>\n<p>注意上面的C和S后面是真是的传输内容。C是client，S是server。这个例子是<code class=\"language-text\">crepes.fr</code>发给<code class=\"language-text\">hamburger.edu</code>。</p>\n<p>client有5个指令：<code class=\"language-text\">HELO</code>(hello), <code class=\"language-text\">MAIL FROM</code>,<code class=\"language-text\">RCPT TO</code>, <code class=\"language-text\">DATA</code>和<code class=\"language-text\">QUIT</code>。这些指令的名字自己就可以解释了。可以通过</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">telnet serverName 25</code></pre></div>\n<p>并按上述顺序输入client指令来模拟发送邮件。</p>\n<h3>SMTP与HTTP的对比</h3>\n<ol>\n<li>\n<p>HTTP是pull protocol，也就是web server load information，client需要的时候pull。</p>\n<p>SMTP是push protocol，sending mail server pushes the file to receiving mail server。</p>\n</li>\n<li>SMTP只能用7 bit ASCII。</li>\n</ol>\n<h3>Mail Message Format</h3>\n<p>这个是user agent发给mail server的还是什么别的</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">From: alice@crepes.fr\nTo: bob@hamburger.edu\nSubject: Searching for the meaning of life.\n\n(data data data)</code></pre></div>\n<h3>Mail Access Protocols</h3>\n<p>Bob 怎么从mail server中读取mail呢？注意Bob不能用SMTP来获取，因为SMTP是push而不是pull。常见的协议有Post Office Protocol—Version 3 (POP3)和Internet Mail Access Protocol (IMAP)。</p>\n<h4>POP3</h4>\n<p>POP3很简单。先在mail server的110端口创建TCP连接。当TCP连接创建，POP3有3个阶段：authorization, transaction and update。</p>\n<ol>\n<li>authorization: the user agent sends a username and password (in clear) to authenticate the user</li>\n<li>transaction: agent retrieves messages and mark messages for deletion, remove deletion marks and obtain mail statistics.</li>\n<li>update: after client has issued the quit command, ending the POP3 session. At this point, the mail server deletes the messages that were marked for deletion.</li>\n</ol>\n<p>mail server会返回<code class=\"language-text\">+OK</code>或<code class=\"language-text\">-ERR</code>作为回应。</p>\n<p>authorization phase: </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">telnet mailServer 110\n+OK POP3 server ready\nuser bob\n+OK\npass hungry\n+OK user successfully logged on</code></pre></div>\n<p>transaction phase:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">C: list\nS: 1 498\nS: 2 912\nS: .\nC: retr 1\nS: (blah blah ...\nS: .................\nS: ..........blah)\nS: .\nC: dele 1\nC: retr 2\nS: (blah blah ...\nS: .................\nS: ..........blah)\nS: .\nC: dele 2\nC: quit\nS: +OK POP3 server signing off</code></pre></div>\n<p>有<code class=\"language-text\">list</code>, <code class=\"language-text\">retr</code>, <code class=\"language-text\">dele</code>和<code class=\"language-text\">quit</code>这样的指令。</p>\n<h4>IMAP</h4>\n<p>如果用户需要在server里创建一个文件夹存放email，那么POP3就不行了。IMAP就可以实现这样的功能。IMAP比POP3要复杂很多。</p>\n<blockquote>\n<p>An IMAP server will associate each message with a folder; when a message first arrives at the server, it is associated with the recipient’s INBOX folder. The recipient can then move the message into a new, user-created folder, read the message, delete the message, and so on.</p>\n<p>The IMAP protocol provides commands to allow users to create folders and move messages from one folder to another</p>\n</blockquote>\n<p>Another important feature of IMAP is that it has commands that permit a user agent to obtain components of messages. 可以只获取header。</p>\n<h4>Web-Based E-mail</h4>\n<p>我们现在用的gmail啥的都是直接用HTTP来retrieve的。不过中间还是SMTP。</p>\n<h2>DNS (Domain Name System)</h2>\n<p>用于把hostname转化为IP address。具体步骤如下：</p>\n<ol>\n<li>the same user machine runs the client side of the DNS application</li>\n<li>brower从URL中提取出hostname，比如<code class=\"language-text\">www.someschool.edu</code>并把hostname传给DNS的client side。</li>\n<li>DNS client给DNS server发送一个包含hostname的query。</li>\n<li>DNS最终会收到一个回复，包含了IP</li>\n<li>browser收到IP地址之后，就可以用IP address来和server确立TCP连接了。</li>\n</ol>\n<p>虽然DNS会导致延迟，但是幸运的是，需要的IP往往就在很近的DNS server上，所以就相对减少了平均延迟。</p>\n<p>DNS还提供其他的重要的服务：</p>\n<ul>\n<li>Host aliasing: 一个有着复杂hostname的host可以又多了alias。</li>\n<li>Mail server alias：邮箱的地址最好能比较好记，所以DNS可以由mail applicatioin出发以获得canonical hostname fo ra supplied alias hostname as well as the IP address of the host.</li>\n<li>Load distribution：perform load distribution among replicated servers.</li>\n</ul>\n<p>如果只有一个DNS server的话，会出现如下的问题：</p>\n<ul>\n<li>A single point of failure: 如果DNS crashes，整个internet crash</li>\n<li>Traffic volume</li>\n<li>Distant centralized database: qurries可能需要横渡重洋</li>\n<li>Maintenance: 会updated frequently to account for every new host</li>\n</ul>\n<p><img src=\"https://imgur.com/ELPiv7g.png\" alt=\"DNS\"></p>\n<ul>\n<li>root DNS servers: 世界上有400个root name server。中国只有不到10个。</li>\n<li>top-level domain (TLD) servers: 为每个top-level domains，如com, org, net, edu, gov，或者是country TLD, uk, cn, fr, ca.</li>\n<li>authoritative DNS server: Every organization with publicly accessible hosts (such as Web servers\nand mail servers) on the Internet must provide publicly accessible DNS records that map the names\nof those hosts to IP addresses.</li>\n</ul>\n<p>还有一种重要的DNS server，是local DNS server。它不属于hierarchy of servers，然而是DNS的核心部分。每个ISP都有一个local DNS server，这里之后咋用的懒得记了...</p>\n<p><img src=\"https://imgur.com/BdHzFAG.png\" alt=\"local DNS server\"></p>\n<h4>DNS caching</h4>\n<p>当一个DNS server收到一个DNS reply的时候，它会把这个mapping cache到本地存储中。</p>\n<h3>DNS Records and Messages</h3>\n<p>一个DNS的resource record是这样的：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(Name, Value, Type, TTL)</code></pre></div>\n<p>其中TTL表四resource的存储时间，决定什么时候应该从cache中移除。在接下来的讨论中，先不考虑这个。</p>\n<ul>\n<li>\n<p><code class=\"language-text\">type=A</code>, <code class=\"language-text\">Name</code>就是hostname, <code class=\"language-text\">Value</code>是IP address。所以一个type A record提供了标准的hostname-to-IP address mapping。</p>\n<p><code class=\"language-text\">(relay1.bar.foo.com, 145.37.93.126, A)</code>是一个type A record。</p>\n</li>\n<li>\n<p><code class=\"language-text\">type=NS</code>, <code class=\"language-text\">Name</code>是domain，如<code class=\"language-text\">foo.com</code>，<code class=\"language-text\">Value</code>是hostname of an authoritative DNS server that knows how to obtain the IP addresses for hosts in the domain。</p>\n<p><code class=\"language-text\">(foo.com, dns.foo.com, NS)</code>是一个type NS record。</p>\n</li>\n<li>If <code class=\"language-text\">type=MX</code> , then Value is the canonical name of a mail server that has an alias hostname Name .\nAs an example, <code class=\"language-text\">(foo.com, mail.bar.foo.com, MX)</code>is an MX record.</li>\n</ul>\n<h4>DNS Messages</h4>"}